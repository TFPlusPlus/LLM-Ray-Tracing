[
    [
        "def intersect_sphere(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    a = Dx*Dx + Dy*Dy + Dz*Dz\n    b = 2*(Ox*Dx + Oy*Dy + Oz*Dz)\n    c = Ox*Ox + Oy*Oy + Oz*Oz - 1\n    disc = b*b - 4*a*c\n    if a == 0 or disc < 0:\n        return -1.0\n    sqrt_disc = disc**0.5\n    t0 = (-b - sqrt_disc) / (2*a)\n    t1 = (-b + sqrt_disc) / (2*a)\n    if t0 > 0:\n        return t0\n    if t1 > 0:\n        return t1\n    return -1.0",
        "def intersect_sphere(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    A = Dx*Dx + Dy*Dy + Dz*Dz\n    B = 2*(Dx*Ox + Dy*Oy + Dz*Oz)\n    C = Ox*Ox + Oy*Oy + Oz*Oz - 1.0\n    disc = B*B - 4*A*C\n    if disc < 0:\n        return -1.0\n    sqrt_disc = disc**0.5\n    t1 = (-B - sqrt_disc) / (2*A)\n    t2 = (-B + sqrt_disc) / (2*A)\n    t_near, t_far = (t1, t2) if t1 < t2 else (t2, t1)\n    if t_near >= 0:\n        return t_near\n    if t_far >= 0:\n        return t_far\n    return -1.0",
        "def intersect_sphere(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    a = dx*dx + dy*dy + dz*dz\n    b = 2 * (ox*dx + oy*dy + oz*dz)\n    c = ox*ox + oy*oy + oz*oz - 1\n    disc = b*b - 4*a*c\n    if disc < 0:\n        return -1.0\n    sqrt_disc = disc**0.5\n    t0 = (-b - sqrt_disc) / (2*a)\n    t1 = (-b + sqrt_disc) / (2*a)\n    if t0 > 0:\n        return t0\n    if t1 > 0:\n        return t1\n    return -1.0",
        "```python\ndef intersect_sphere(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    a = dx*dx + dy*dy + dz*dz\n    b = 2 * (dx*ox + dy*oy + dz*oz)\n    c = ox*ox + oy*oy + oz*oz - 1\n    disc = b*b - 4*a*c\n    if disc < 0:\n        return -1\n    sqrt_disc = disc**0.5\n    t0 = (-b - sqrt_disc) / (2*a)\n    t1 = (-b + sqrt_disc) / (2*a)\n    if t0 >= 0 and t1 >= 0:\n        return min(t0, t1)\n    if t0 >= 0:\n        return t0\n    if t1 >= 0:\n        return t1\n    return -1\n```",
        "```python\ndef intersect_sphere(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    a = Dx*Dx + Dy*Dy + Dz*Dz\n    b = 2 * (Dx*Ox + Dy*Oy + Dz*Oz)\n    c = Ox*Ox + Oy*Oy + Oz*Oz - 1\n    disc = b*b - 4*a*c\n    if disc < 0:\n        return -1\n    sqrt_disc = disc**0.5\n    t0 = (-b - sqrt_disc) / (2*a)\n    t1 = (-b + sqrt_disc) / (2*a)\n    ts = sorted((t0, t1))\n    for t in ts:\n        if t >= 0:\n            return t\n    return -1\n```",
        "def intersect_sphere(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    a = Dx*Dx + Dy*Dy + Dz*Dz\n    b = 2*(Ox*Dx + Oy*Dy + Oz*Dz)\n    c = Ox*Ox + Oy*Oy + Oz*Oz - 1\n    disc = b*b - 4*a*c\n    if disc < 0:\n        return -1\n    sqrt_disc = disc**0.5\n    t0 = (-b - sqrt_disc) / (2*a)\n    t1 = (-b + sqrt_disc) / (2*a)\n    if t0 >= 0:\n        return t0\n    if t1 >= 0:\n        return t1\n    return -1",
        "```python\ndef intersect_sphere(O, D):\n    import math\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    a = Dx*Dx + Dy*Dy + Dz*Dz\n    b = 2*(Ox*Dx + Oy*Dy + Oz*Dz)\n    c = Ox*Ox + Oy*Oy + Oz*Oz - 1\n    disc = b*b - 4*a*c\n    if disc < 0:\n        return -1\n    sqrt_disc = math.sqrt(disc)\n    t0 = (-b - sqrt_disc) / (2*a)\n    t1 = (-b + sqrt_disc) / (2*a)\n    t_min = min(t0, t1)\n    if t_min > 0:\n        return t_min\n    t_max = max(t0, t1)\n    if t_max > 0:\n        return t_max\n    return -1\n```",
        "```python\ndef intersect_sphere(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    a = dx*dx + dy*dy + dz*dz\n    b = 2*(ox*dx + oy*dy + oz*dz)\n    c = ox*ox + oy*oy + oz*oz - 1.0\n    disc = b*b - 4*a*c\n    if disc < 0:\n        return -1.0\n    sqrt_disc = disc**0.5\n    t1 = (-b - sqrt_disc) / (2*a)\n    t2 = (-b + sqrt_disc) / (2*a)\n    t = None\n    if t1 >= 0:\n        t = t1\n    if t2 >= 0 and (t is None or t2 < t):\n        t = t2\n    return t if t is not None else -1.0\n```",
        "def intersect_ray_sphere(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    a = dx*dx + dy*dy + dz*dz\n    b = 2*(ox*dx + oy*dy + oz*dz)\n    c = ox*ox + oy*oy + oz*oz - 1\n    disc = b*b - 4*a*c\n    if disc < 0:\n        return -1.0\n    sqrt_disc = disc**0.5\n    t0 = (-b - sqrt_disc) / (2*a)\n    t1 = (-b + sqrt_disc) / (2*a)\n    if t0 > 0 and t1 > 0:\n        return min(t0, t1)\n    if t0 > 0:\n        return t0\n    if t1 > 0:\n        return t1\n    return -1.0",
        "def intersect_sphere(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    a = dx*dx + dy*dy + dz*dz\n    b = 2*(ox*dx + oy*dy + oz*dz)\n    c = ox*ox + oy*oy + oz*oz - 1\n    disc = b*b - 4*a*c\n    if disc < 0:\n        return -1.0\n    sqrt_disc = disc**0.5\n    t1 = (-b - sqrt_disc) / (2*a)\n    t2 = (-b + sqrt_disc) / (2*a)\n    t = min(t1, t2)\n    if t >= 0:\n        return t\n    t = max(t1, t2)\n    if t >= 0:\n        return t\n    return -1.0"
    ],
    [
        "def intersect_cube(O, D):\n    tmin, tmax = float('-inf'), float('inf')\n    for o, d in zip(O, D):\n        if abs(d) < 1e-8:\n            if o < 0 or o > 1:\n                return -1.0\n        else:\n            t1 = (0 - o) / d\n            t2 = (1 - o) / d\n            t_near, t_far = min(t1, t2), max(t1, t2)\n            tmin = max(tmin, t_near)\n            tmax = min(tmax, t_far)\n            if tmin > tmax:\n                return -1.0\n    if tmax < 0:\n        return -1.0\n    return tmin if tmin >= 0 else tmax",
        "def intersect_cube(O, D):\n    tmin = -float('inf')\n    tmax = float('inf')\n    for o, d in zip(O, D):\n        if d != 0.0:\n            t1 = (0.0 - o) / d\n            t2 = (1.0 - o) / d\n            t_near = min(t1, t2)\n            t_far = max(t1, t2)\n            tmin = max(tmin, t_near)\n            tmax = min(tmax, t_far)\n            if tmin > tmax:\n                return -1.0\n        else:\n            if o < 0.0 or o > 1.0:\n                return -1.0\n    return tmin if tmin >= 0.0 else -1.0",
        "def intersect_cube(O, D):\n    tmin = -float('inf')\n    tmax = float('inf')\n    for i in range(3):\n        if D[i] != 0.0:\n            t1 = (0.0 - O[i]) / D[i]\n            t2 = (1.0 - O[i]) / D[i]\n            tmin = max(tmin, min(t1, t2))\n            tmax = min(tmax, max(t1, t2))\n            if tmax < tmin:\n                return -1.0\n        else:\n            if O[i] < 0.0 or O[i] > 1.0:\n                return -1.0\n    if tmax < 0.0:\n        return -1.0\n    return tmin if tmin >= 0.0 else tmax",
        "```python\ndef intersect_cube(O, D):\n    tmin, tmax = float('-inf'), float('inf')\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 1.0)]\n    for i in range(3):\n        o_i, d_i = O[i], D[i]\n        bmin, bmax = bounds[i]\n        if abs(d_i) < 1e-8:\n            if o_i < bmin or o_i > bmax:\n                return -1.0\n        else:\n            t1 = (bmin - o_i) / d_i\n            t2 = (bmax - o_i) / d_i\n            t_near, t_far = min(t1, t2), max(t1, t2)\n            tmin, tmax = max(tmin, t_near), min(tmax, t_far)\n            if tmax < tmin:\n                return -1.0\n    return tmin if tmin >= 0.0 else -1.0\n```",
        "```python\ndef intersect_cube(O, D):\n    tmin = float('-inf')\n    tmax = float('inf')\n    for o, d in zip(O, D):\n        if d == 0:\n            if o < 0 or o > 1:\n                return -1.0\n        else:\n            t1 = (0 - o) / d\n            t2 = (1 - o) / d\n            t_enter = min(t1, t2)\n            t_exit = max(t1, t2)\n            tmin = max(tmin, t_enter)\n            tmax = min(tmax, t_exit)\n            if tmin > tmax:\n                return -1.0\n    if tmax < 0:\n        return -1.0\n    return tmin if tmin >= 0 else tmax\n```",
        "def intersect_cube(O, D):\n    inf = float('inf')\n    tmin, tmax = -inf, inf\n    for o, d in zip(O, D):\n        if abs(d) < 1e-8:\n            if o < 0 or o > 1:\n                return -1.0\n            continue\n        t1 = (0 - o) / d\n        t2 = (1 - o) / d\n        t_near, t_far = min(t1, t2), max(t1, t2)\n        tmin = max(tmin, t_near)\n        tmax = min(tmax, t_far)\n        if tmin > tmax:\n            return -1.0\n    if tmax < 0:\n        return -1.0\n    return tmin if tmin >= 0 else tmax",
        "```python\ndef intersect_ray_cube(O, D):\n    import math\n    tmin, tmax = -math.inf, math.inf\n    for i in range(3):\n        if abs(D[i]) < 1e-8:\n            if O[i] < 0.0 or O[i] > 1.0:\n                return -1.0\n        else:\n            t1 = (0.0 - O[i]) / D[i]\n            t2 = (1.0 - O[i]) / D[i]\n            tnear, tfar = min(t1, t2), max(t1, t2)\n            tmin, tmax = max(tmin, tnear), min(tmax, tfar)\n            if tmin > tmax:\n                return -1.0\n    if tmax < 0:\n        return -1.0\n    return tmin if tmin >= 0 else tmax\n```",
        "```python\ndef intersect_cube(O, D):\n    tmin, tmax = float('-inf'), float('inf')\n    bounds = [(0.0, 1.0)] * 3\n    for o, d, (b0, b1) in zip(O, D, bounds):\n        if abs(d) < 1e-8:\n            if o < b0 or o > b1:\n                return -1.0\n            continue\n        t1 = (b0 - o) / d\n        t2 = (b1 - o) / d\n        t_near, t_far = min(t1, t2), max(t1, t2)\n        tmin = max(tmin, t_near)\n        tmax = min(tmax, t_far)\n        if tmin > tmax:\n            return -1.0\n    if tmax < 0.0:\n        return -1.0\n    return tmin if tmin >= 0.0 else tmax\n```",
        "```python\ndef intersect_cube(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    t_min, t_max = -float('inf'), float('inf')\n    for o, d, mn, mx in ((ox, dx, 0.0, 1.0), (oy, dy, 0.0, 1.0), (oz, dz, 0.0, 1.0)):\n        if d != 0.0:\n            t1 = (mn - o) / d\n            t2 = (mx - o) / d\n            t_near, t_far = min(t1, t2), max(t1, t2)\n        else:\n            if o < mn or o > mx:\n                return -1.0\n            t_near, t_far = -float('inf'), float('inf')\n        t_min = max(t_min, t_near)\n        t_max = min(t_max, t_far)\n        if t_min > t_max:\n            return -1.0\n    return t_min if t_min >= 0.0 else -1.0\n```",
        "def intersect_cube(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    t_min, t_max = -float('inf'), float('inf')\n    for Oi, Di in ((Ox, Dx), (Oy, Dy), (Oz, Dz)):\n        if Di != 0:\n            t1 = (0 - Oi) / Di\n            t2 = (1 - Oi) / Di\n            t_near, t_far = min(t1, t2), max(t1, t2)\n            t_min = max(t_min, t_near)\n            t_max = min(t_max, t_far)\n            if t_max < t_min:\n                return -1\n        else:\n            if Oi < 0 or Oi > 1:\n                return -1\n    return t_min if t_min >= 0 else -1"
    ],
    [
        "```python\ndef intersect_square(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    # Intersection with plane z=0\n    if Dz == 0.0:\n        return -1.0\n    t = -Oz / Dz\n    if t < 0.0:\n        return -1.0\n    # Compute intersection point\n    x = Ox + t * Dx\n    y = Oy + t * Dy\n    # Check if inside square [0,1]x[0,1]\n    if 0.0 <= x <= 1.0 and 0.0 <= y <= 1.0:\n        return t\n    return -1.0\n```",
        "```python\ndef intersect_ray_square(O, D):\n    eps = 1e-6\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    if abs(Dz) < eps:\n        return -1\n    t = -Oz / Dz\n    if t < 0:\n        return -1\n    Px = Ox + t * Dx\n    Py = Oy + t * Dy\n    if -eps <= Px <= 1 + eps and -eps <= Py <= 1 + eps:\n        return t\n    return -1\n```",
        "```python\ndef intersect_square(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    # Ray-plane intersection with z=0 plane\n    if abs(Dz) < 1e-8:\n        return -1.0\n    t = -Oz / Dz\n    if t < 0.0:\n        return -1.0\n    # Intersection point\n    x = Ox + t * Dx\n    y = Oy + t * Dy\n    # Check if point is inside the square [0,1] x [0,1]\n    if 0.0 <= x <= 1.0 and 0.0 <= y <= 1.0:\n        return t\n    return -1.0\n```",
        "```python\ndef intersect_square(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    if Dz == 0.0:\n        return -1.0\n    t = -Oz / Dz\n    if t < 0.0:\n        return -1.0\n    x = Ox + t * Dx\n    y = Oy + t * Dy\n    if 0.0 <= x <= 1.0 and 0.0 <= y <= 1.0:\n        return t\n    return -1.0\n```",
        "```python\ndef intersect_square(O, D):\n    if D[2] == 0.0:\n        return -1.0\n    t = -O[2] / D[2]\n    if t < 0.0:\n        return -1.0\n    x = O[0] + t * D[0]\n    y = O[1] + t * D[1]\n    if 0.0 <= x <= 1.0 and 0.0 <= y <= 1.0:\n        return t\n    return -1.0\n```",
        "```python\ndef intersect_square(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    # Ray is parallel to the square's plane\n    if abs(Dz) < 1e-8:\n        return -1.0\n    # Compute intersection with z=0 plane\n    t = -Oz / Dz\n    if t < 0:\n        return -1.0\n    x = Ox + t * Dx\n    y = Oy + t * Dy\n    # Check if the intersection point lies within the square bounds\n    if 0.0 <= x <= 1.0 and 0.0 <= y <= 1.0:\n        return t\n    return -1.0\n```",
        "```python\ndef intersect_ray_square(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    eps = 1e-6\n    if abs(Dz) < eps:\n        return -1.0\n    t = -Oz / Dz\n    if t < 0:\n        return -1.0\n    x = Ox + t * Dx\n    y = Oy + t * Dy\n    if -eps <= x <= 1 + eps and -eps <= y <= 1 + eps:\n        return t\n    return -1.0\n```",
        "```python\ndef intersect_square(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    if Dz == 0:\n        return -1.0\n    t = -Oz / Dz\n    if t <= 0:\n        return -1.0\n    x = Ox + t * Dx\n    y = Oy + t * Dy\n    if 0 <= x <= 1 and 0 <= y <= 1:\n        return t\n    return -1.0\n```",
        "```python\ndef intersect_square(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    # Ray parallel to square's plane\n    if Dz == 0:\n        return -1.0\n    # Compute intersection t with plane z=0\n    t = -Oz / Dz\n    if t < 0:\n        return -1.0\n    # Compute the intersection point\n    x = Ox + t * Dx\n    y = Oy + t * Dy\n    # Check if the point lies within the square [0,1] x [0,1]\n    if 0.0 <= x <= 1.0 and 0.0 <= y <= 1.0:\n        return t\n    return -1.0\n```",
        "```python\ndef intersect_square(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    # Plane z = 0 normal (0,0,1)\n    if abs(Dz) < 1e-8:\n        return -1.0\n    t = -Oz / Dz\n    if t < 0:\n        return -1.0\n    Px = Ox + t * Dx\n    Py = Oy + t * Dy\n    if 0.0 <= Px <= 1.0 and 0.0 <= Py <= 1.0:\n        return t\n    return -1.0\n```"
    ],
    [
        "def intersect_cylinder(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    ts = []\n    # side intersections\n    a = Dx*Dx + Dz*Dz\n    b = 2*(Ox*Dx + Oz*Dz)\n    c = Ox*Ox + Oz*Oz - 1\n    if a != 0:\n        disc = b*b - 4*a*c\n        if disc >= 0:\n            sqrt_disc = disc**0.5\n            for t in ((-b - sqrt_disc)/(2*a), (-b + sqrt_disc)/(2*a)):\n                if t > 0:\n                    y = Oy + t*Dy\n                    if 0 <= y <= 1:\n                        ts.append(t)\n    # cap intersections y=0 and y=1\n    if Dy != 0:\n        for y_plane in (0, 1):\n            t = (y_plane - Oy) / Dy\n            if t > 0:\n                x = Ox + t*Dx\n                z = Oz + t*Dz\n                if x*x + z*z <= 1:\n                    ts.append(t)\n    return min(ts) if ts else -1.0",
        "```python\ndef intersect_cylinder(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    t_vals = []\n    # Intersection with cylindrical surface\n    a = Dx*Dx + Dz*Dz\n    if a != 0.0:\n        b = 2*(Ox*Dx + Oz*Dz)\n        c = Ox*Ox + Oz*Oz - 1\n        disc = b*b - 4*a*c\n        if disc >= 0.0:\n            sqrt_disc = disc**0.5\n            inv2a = 0.5 / a\n            for sign in (-1, 1):\n                t = (-b + sign * sqrt_disc) * inv2a\n                if t >= 0.0:\n                    y = Oy + t * Dy\n                    if 0.0 <= y <= 1.0:\n                        t_vals.append(t)\n    # Intersection with caps at y=0 and y=1\n    if Dy != 0.0:\n        for y_plane in (0.0, 1.0):\n            t = (y_plane - Oy) / Dy\n            if t >= 0.0:\n                x = Ox + t * Dx\n                z = Oz + t * Dz\n                if x*x + z*z <= 1.0:\n                    t_vals.append(t)\n    if not t_vals:\n        return -1.0\n    return min(t_vals)\n```",
        "```python\ndef intersect_cylinder(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    ts = []\n    # side intersections\n    a = Dx*Dx + Dz*Dz\n    if abs(a) > 1e-8:\n        b = 2*(Ox*Dx + Oz*Dz)\n        c = Ox*Ox + Oz*Oz - 1\n        disc = b*b - 4*a*c\n        if disc >= 0:\n            sd = disc**0.5\n            for t in [(-b - sd)/(2*a), (-b + sd)/(2*a)]:\n                if t > 0:\n                    y = Oy + t*Dy\n                    if 0 <= y <= 1:\n                        ts.append(t)\n    # cap intersections\n    if abs(Dy) > 1e-8:\n        for y_plane in (0.0, 1.0):\n            t = (y_plane - Oy)/Dy\n            if t > 0:\n                x = Ox + t*Dx\n                z = Oz + t*Dz\n                if x*x + z*z <= 1:\n                    ts.append(t)\n    return min(ts) if ts else -1.0\n```",
        "def intersect_cylinder(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    ts = []\n    # lateral surface\n    A = Dx*Dx + Dz*Dz\n    B = 2*(Ox*Dx + Oz*Dz)\n    C = Ox*Ox + Oz*Oz - 1\n    if abs(A) > 1e-8:\n        disc = B*B - 4*A*C\n        if disc >= 0:\n            sqrt_disc = disc**0.5\n            for t in [(-B - sqrt_disc)/(2*A), (-B + sqrt_disc)/(2*A)]:\n                if t >= 0:\n                    y = Oy + Dy*t\n                    if 0 <= y <= 1:\n                        ts.append(t)\n    # caps\n    if abs(Dy) > 1e-8:\n        for y_plane in (0.0, 1.0):\n            t = (y_plane - Oy)/Dy\n            if t >= 0:\n                x = Ox + Dx*t\n                z = Oz + Dz*t\n                if x*x + z*z <= 1:\n                    ts.append(t)\n    return min(ts) if ts else -1",
        "def intersect_cylinder(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    t_min = float('inf')\n    a = dx*dx + dz*dz\n    b = 2*(ox*dx + oz*dz)\n    c = ox*ox + oz*oz - 1\n    if a != 0:\n        disc = b*b - 4*a*c\n        if disc >= 0:\n            sqrt_disc = disc**0.5\n            for t in [(-b - sqrt_disc) / (2*a), (-b + sqrt_disc) / (2*a)]:\n                if t > 0:\n                    y = oy + t*dy\n                    if 0 <= y <= 1 and t < t_min:\n                        t_min = t\n    if dy != 0:\n        for y_cap in (0, 1):\n            t = (y_cap - oy) / dy\n            if t > 0:\n                x = ox + t*dx\n                z = oz + t*dz\n                if x*x + z*z <= 1 and t < t_min:\n                    t_min = t\n    return t_min if t_min != float('inf') else -1",
        "def intersect_cylinder(O, D):\n    import math\n    x0, y0, z0 = O\n    dx, dy, dz = D\n    ts = []\n    a = dx*dx + dz*dz\n    if a != 0.0:\n        b = 2*(x0*dx + z0*dz)\n        c = x0*x0 + z0*z0 - 1\n        disc = b*b - 4*a*c\n        if disc >= 0.0:\n            sd = math.sqrt(disc)\n            for t in [(-b - sd)/(2*a), (-b + sd)/(2*a)]:\n                if t >= 0.0:\n                    y = y0 + dy*t\n                    if 0.0 <= y <= 1.0:\n                        ts.append(t)\n    if dy != 0.0:\n        for y_plane in (0.0, 1.0):\n            t = (y_plane - y0)/dy\n            if t >= 0.0:\n                x = x0 + dx*t\n                z = z0 + dz*t\n                if x*x + z*z <= 1.0:\n                    ts.append(t)\n    return min(ts) if ts else -1.0",
        "```python\ndef intersect_cylinder(O, D):\n    import math\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    ts = []\n\n    # Side intersections (infinite cylinder x^2 + z^2 = 1)\n    a = Dx*Dx + Dz*Dz\n    if a != 0.0:\n        b = 2.0*(Ox*Dx + Oz*Dz)\n        c = Ox*Ox + Oz*Oz - 1.0\n        disc = b*b - 4.0*a*c\n        if disc >= 0.0:\n            sd = math.sqrt(disc)\n            for t in [(-b - sd)/(2.0*a), (-b + sd)/(2.0*a)]:\n                if t > 0.0:\n                    y = Oy + t*Dy\n                    if 0.0 <= y <= 1.0:\n                        ts.append(t)\n\n    # Cap intersections (y = 0 and y = 1)\n    if Dy != 0.0:\n        for y_plane in (0.0, 1.0):\n            t = (y_plane - Oy) / Dy\n            if t > 0.0:\n                x = Ox + t*Dx\n                z = Oz + t*Dz\n                if x*x + z*z <= 1.0:\n                    ts.append(t)\n\n    if not ts:\n        return -1.0\n    return min(ts)\n```",
        "```python\ndef intersect_cylinder(O, D):\n    x0, y0, z0 = O\n    dx, dy, dz = D\n    ts = []\n    a = dx*dx + dz*dz\n    b = 2*(x0*dx + z0*dz)\n    c = x0*x0 + z0*z0 - 1\n    if abs(a) > 1e-6:\n        disc = b*b - 4*a*c\n        if disc >= 0:\n            sd = disc**0.5\n            t1 = (-b - sd) / (2*a)\n            t2 = (-b + sd) / (2*a)\n            for t in (t1, t2):\n                if t > 0:\n                    y = y0 + dy*t\n                    if 0 <= y <= 1:\n                        ts.append(t)\n    if abs(dy) > 1e-6:\n        for y_plane in (0, 1):\n            t = (y_plane - y0) / dy\n            if t > 0:\n                x = x0 + dx*t\n                z = z0 + dz*t\n                if x*x + z*z <= 1:\n                    ts.append(t)\n    return min(ts) if ts else -1.0\n```",
        "def intersect_cylinder(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    t_vals = []\n    A = Dx*Dx + Dz*Dz\n    if A != 0.0:\n        B = 2*(Ox*Dx + Oz*Dz)\n        C = Ox*Ox + Oz*Oz - 1.0\n        disc = B*B - 4*A*C\n        if disc >= 0.0:\n            sd = disc**0.5\n            for t in [(-B - sd)/(2*A), (-B + sd)/(2*A)]:\n                if t > 0.0:\n                    y = Oy + t*Dy\n                    if 0.0 <= y <= 1.0:\n                        t_vals.append(t)\n    for y_plane in (0.0, 1.0):\n        if Dy != 0.0:\n            t = (y_plane - Oy)/Dy\n            if t > 0.0:\n                x = Ox + t*Dx\n                z = Oz + t*Dz\n                if x*x + z*z <= 1.0:\n                    t_vals.append(t)\n    return min(t_vals) if t_vals else -1.0",
        "def intersect_cylinder(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    a = dx*dx + dz*dz\n    b = 2*(ox*dx + oz*dz)\n    c = ox*ox + oz*oz - 1\n    ts = []\n    # side intersections\n    if abs(a) > 1e-6:\n        disc = b*b - 4*a*c\n        if disc >= 0:\n            sqrt_disc = disc**0.5\n            for t in [(-b - sqrt_disc)/(2*a), (-b + sqrt_disc)/(2*a)]:\n                if t > 0:\n                    y = oy + t*dy\n                    if 0 <= y <= 1:\n                        ts.append(t)\n    # cap intersections\n    if abs(dy) > 1e-6:\n        for y_plane in (0.0, 1.0):\n            t = (y_plane - oy)/dy\n            if t > 0:\n                x = ox + t*dx\n                z = oz + t*dz\n                if x*x + z*z <= 1:\n                    ts.append(t)\n    return min(ts) if ts else -1"
    ],
    [
        "def intersect(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    best_t = float('inf')\n    for cx, cy, cz in ((0.0, 0.0, 0.0), (1.0, 0.0, 0.0)):\n        ocx = ox - cx\n        ocy = oy - cy\n        ocz = oz - cz\n        a = dx*dx + dy*dy + dz*dz\n        b = 2.0*(dx*ocx + dy*ocy + dz*ocz)\n        c = ocx*ocx + ocy*ocy + ocz*ocz - 1.0\n        disc = b*b - 4*a*c\n        if disc < 0:\n            continue\n        sqrt_disc = disc**0.5\n        t0 = (-b - sqrt_disc) / (2*a)\n        t1 = (-b + sqrt_disc) / (2*a)\n        if t0 >= 0 and t0 < best_t:\n            best_t = t0\n        if t1 >= 0 and t1 < best_t:\n            best_t = t1\n    return best_t if best_t != float('inf') else -1.0",
        "def intersect_two_spheres(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    best_t = float('inf')\n    for Cx, Cy, Cz in ((0.0, 0.0, 0.0), (1.0, 0.0, 0.0)):\n        ocx = Ox - Cx\n        ocy = Oy - Cy\n        ocz = Oz - Cz\n        a = Dx*Dx + Dy*Dy + Dz*Dz\n        b = 2 * (Dx*ocx + Dy*ocy + Dz*ocz)\n        c = ocx*ocx + ocy*ocy + ocz*ocz - 1.0\n        disc = b*b - 4*a*c\n        if disc < 0:\n            continue\n        sqrt_disc = disc**0.5\n        t0 = (-b - sqrt_disc) / (2*a)\n        t1 = (-b + sqrt_disc) / (2*a)\n        if t0 >= 0 and t0 < best_t:\n            best_t = t0\n        if t1 >= 0 and t1 < best_t:\n            best_t = t1\n    return best_t if best_t != float('inf') else -1.0",
        "def intersect_two_spheres(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    best_t = float('inf')\n    for Cx, Cy, Cz in [(0.0, 0.0, 0.0), (1.0, 0.0, 0.0)]:\n        ocx = Ox - Cx\n        ocy = Oy - Cy\n        ocz = Oz - Cz\n        a = Dx*Dx + Dy*Dy + Dz*Dz\n        b = 2*(Dx*ocx + Dy*ocy + Dz*ocz)\n        c = ocx*ocx + ocy*ocy + ocz*ocz - 1.0\n        disc = b*b - 4*a*c\n        if disc < 0:\n            continue\n        sqrt_disc = disc**0.5\n        t1 = (-b - sqrt_disc) / (2*a)\n        t2 = (-b + sqrt_disc) / (2*a)\n        for t in (t1, t2):\n            if t >= 0 and t < best_t:\n                best_t = t\n    return best_t if best_t != float('inf') else -1.0",
        "```python\ndef intersect_two_spheres(O, D):\n    def intersect_sphere(O, D, C, r):\n        Ox, Oy, Oz = O\n        Dx, Dy, Dz = D\n        Cx, Cy, Cz = C\n        ocx, ocy, ocz = Ox - Cx, Oy - Cy, Oz - Cz\n        a = Dx*Dx + Dy*Dy + Dz*Dz\n        b = 2*(Dx*ocx + Dy*ocy + Dz*ocz)\n        c = ocx*ocx + ocy*ocy + ocz*ocz - r*r\n        disc = b*b - 4*a*c\n        if disc < 0:\n            return None\n        sqrt_disc = disc**0.5\n        t1 = (-b - sqrt_disc) / (2*a)\n        t2 = (-b + sqrt_disc) / (2*a)\n        ts = [t for t in (t1, t2) if t >= 0]\n        return min(ts) if ts else None\n\n    t0 = intersect_sphere(O, D, (0.0, 0.0, 0.0), 1.0)\n    t1 = intersect_sphere(O, D, (1.0, 0.0, 0.0), 1.0)\n    ts = [t for t in (t0, t1) if t is not None]\n    return min(ts) if ts else -1.0\n```",
        "```python\ndef intersect(O, D):\n    a = D[0]*D[0] + D[1]*D[1] + D[2]*D[2]\n    t_vals = []\n    for C in [(0.0, 0.0, 0.0), (1.0, 0.0, 0.0)]:\n        oc = (O[0] - C[0], O[1] - C[1], O[2] - C[2])\n        b = 2 * (D[0]*oc[0] + D[1]*oc[1] + D[2]*oc[2])\n        c = oc[0]*oc[0] + oc[1]*oc[1] + oc[2]*oc[2] - 1.0\n        disc = b*b - 4*a*c\n        if disc < 0:\n            continue\n        sqrt_disc = disc**0.5\n        t0 = (-b - sqrt_disc) / (2*a)\n        t1 = (-b + sqrt_disc) / (2*a)\n        if t0 > 0:\n            t_vals.append(t0)\n        if t1 > 0:\n            t_vals.append(t1)\n    if not t_vals:\n        return -1.0\n    return min(t_vals)\n```",
        "def intersect_spheres(O, D):\n    import math\n    def sphere_intersect(C, r):\n        ox, oy, oz = O\n        dx, dy, dz = D\n        cx, cy, cz = C\n        ocx, ocy, ocz = ox-cx, oy-cy, oz-cz\n        a = dx*dx + dy*dy + dz*dz\n        b = 2*(dx*ocx + dy*ocy + dz*ocz)\n        c = ocx*ocx + ocy*ocy + ocz*ocz - r*r\n        disc = b*b - 4*a*c\n        if disc < 0: return None\n        sq = math.sqrt(disc)\n        t1 = (-b - sq)/(2*a); t2 = (-b + sq)/(2*a)\n        if t1 >= 0: return t1\n        if t2 >= 0: return t2\n        return None\n    t1 = sphere_intersect((0.0,0.0,0.0), 1.0)\n    t2 = sphere_intersect((1.0,0.0,0.0), 1.0)\n    ts = [t for t in (t1, t2) if t is not None]\n    return min(ts) if ts else -1.0",
        "def intersect_two_spheres(O, D):\n    import math\n    def intersect_sphere(C, r):\n        ocx, ocy, ocz = O[0]-C[0], O[1]-C[1], O[2]-C[2]\n        a = D[0]*D[0] + D[1]*D[1] + D[2]*D[2]\n        b = 2*(D[0]*ocx + D[1]*ocy + D[2]*ocz)\n        c = ocx*ocx + ocy*ocy + ocz*ocz - r*r\n        disc = b*b - 4*a*c\n        if disc < 0:\n            return None\n        sqrt_disc = math.sqrt(disc)\n        t1 = (-b - sqrt_disc) / (2*a)\n        t2 = (-b + sqrt_disc) / (2*a)\n        tmin, tmax = min(t1, t2), max(t1, t2)\n        if tmin >= 0:\n            return tmin\n        if tmax >= 0:\n            return tmax\n        return None\n    t0 = intersect_sphere((0.0, 0.0, 0.0), 1.0)\n    t1 = intersect_sphere((1.0, 0.0, 0.0), 1.0)\n    ts = [t for t in (t0, t1) if t is not None]\n    return min(ts) if ts else -1.0",
        "```python\ndef intersect_two_spheres(O, D):\n    import math\n    eps = 1e-6\n    ox, oy, oz = O\n    dx, dy, dz = D\n    a = dx*dx + dy*dy + dz*dz\n    ts = []\n    for cx, cy, cz in [(0.0, 0.0, 0.0), (1.0, 0.0, 0.0)]:\n        ocx, ocy, ocz = ox - cx, oy - cy, oz - cz\n        b = 2 * (dx*ocx + dy*ocy + dz*ocz)\n        c = ocx*ocx + ocy*ocy + ocz*ocz - 1.0\n        disc = b*b - 4*a*c\n        if disc < 0:\n            continue\n        s = math.sqrt(disc)\n        t0 = (-b - s) / (2*a)\n        t1 = (-b + s) / (2*a)\n        if t0 >= 0: ts.append(t0)\n        if t1 >= 0: ts.append(t1)\n    if not ts:\n        return -1.0\n    ts.sort()\n    for t in ts:\n        px, py, pz = ox + t*dx, oy + t*dy, oz + t*dz\n        d1 = math.sqrt(px*px + py*py + pz*pz)\n        d2 = math.sqrt((px-1.0)**2 + py*py + pz*pz)\n        if abs(d1 - 1.0) < eps and d2 > 1.0 + eps:\n            return t\n        if abs(d2 - 1.0) < eps and d1 > 1.0 + eps:\n            return t\n    return -1.0\n```",
        "def intersect(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    best_t = float('inf')\n    for cx, cy, cz in ((0.0, 0.0, 0.0), (1.0, 0.0, 0.0)):\n        ocx = ox - cx\n        ocy = oy - cy\n        ocz = oz - cz\n        a = dx*dx + dy*dy + dz*dz\n        b = 2.0 * (dx*ocx + dy*ocy + dz*ocz)\n        c = ocx*ocx + ocy*ocy + ocz*ocz - 1.0\n        disc = b*b - 4.0*a*c\n        if disc >= 0.0:\n            sq = disc**0.5\n            t1 = (-b - sq) / (2.0*a)\n            t2 = (-b + sq) / (2.0*a)\n            if 0.0 < t1 < best_t: best_t = t1\n            if 0.0 < t2 < best_t: best_t = t2\n    return best_t if best_t != float('inf') else -1.0",
        "def intersect_two_spheres(O, D):\n    import math\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    best_t = float('inf')\n    for Cx, Cy, Cz in ((0.0, 0.0, 0.0), (1.0, 0.0, 0.0)):\n        r = 1.0\n        ocx = Ox - Cx; ocy = Oy - Cy; ocz = Oz - Cz\n        a = Dx*Dx + Dy*Dy + Dz*Dz\n        b = 2.0 * (ocx*Dx + ocy*Dy + ocz*Dz)\n        c = ocx*ocx + ocy*ocy + ocz*ocz - r*r\n        disc = b*b - 4.0*a*c\n        if disc < 0.0: continue\n        sqrt_disc = math.sqrt(disc)\n        t1 = (-b - sqrt_disc) / (2.0*a)\n        t2 = (-b + sqrt_disc) / (2.0*a)\n        if t1 >= 0.0 and t1 < best_t: best_t = t1\n        if t2 >= 0.0 and t2 < best_t: best_t = t2\n    return best_t if best_t != float('inf') else -1.0"
    ],
    [
        "```python\ndef intersect_ray_disc(O, D):\n    n = (1.0, 1.0, 1.0)\n    denom = n[0]*D[0] + n[1]*D[1] + n[2]*D[2]\n    if abs(denom) < 1e-6:\n        return -1\n    numer = n[0]*O[0] + n[1]*O[1] + n[2]*O[2]\n    t = -numer / denom\n    if t < 0:\n        return -1\n    P = (O[0] + t*D[0], O[1] + t*D[1], O[2] + t*D[2])\n    if P[0]*P[0] + P[1]*P[1] + P[2]*P[2] <= 1.0:\n        return t\n    return -1\n```",
        "def intersect_disc(O, D):\n    # Plane normal (normalized)\n    inv_len = 1.0 / (3**0.5)\n    n = (inv_len, inv_len, inv_len)\n    # Dot product helper\n    dot = lambda a, b: a[0]*b[0] + a[1]*b[1] + a[2]*b[2]\n    # Compute denominator\n    denom = dot(D, n)\n    if abs(denom) < 1e-8:\n        return -1.0\n    # Compute t for intersection with plane\n    t = -dot(O, n) / denom\n    if t < 0.0:\n        return -1.0\n    # Compute intersection point P = O + t*D\n    P = (O[0] + t*D[0], O[1] + t*D[1], O[2] + t*D[2])\n    # Check if within disc radius (radius = 1)\n    if dot(P, P) <= 1.0:\n        return t\n    return -1.0",
        "```python\ndef intersect(O, D):\n    import math\n    # Disc parameters\n    cx, cy, cz = 0.0, 0.0, 0.0\n    radius = 1.0\n    # Normalize disc normal\n    nx, ny, nz = 1.0, 1.0, 1.0\n    inv_len = 1.0 / math.sqrt(nx*nx + ny*ny + nz*nz)\n    nx, ny, nz = nx*inv_len, ny*inv_len, nz*inv_len\n    # Ray-plane intersection\n    denom = D[0]*nx + D[1]*ny + D[2]*nz\n    if abs(denom) < 1e-6:\n        return -1.0\n    t = -((O[0]-cx)*nx + (O[1]-cy)*ny + (O[2]-cz)*nz) / denom\n    if t < 0.0:\n        return -1.0\n    # Compute intersection point\n    px = O[0] + t*D[0]\n    py = O[1] + t*D[1]\n    pz = O[2] + t*D[2]\n    # Check if within disc radius\n    dx, dy, dz = px-cx, py-cy, pz-cz\n    if dx*dx + dy*dy + dz*dz <= radius*radius:\n        return t\n    return -1.0\n```",
        "```python\ndef intersect_disc(O, D):\n    nx, ny, nz = 1.0, 1.0, 1.0\n    denom = nx*D[0] + ny*D[1] + nz*D[2]\n    if abs(denom) < 1e-6:\n        return -1\n    t = -(nx*O[0] + ny*O[1] + nz*O[2]) / denom\n    if t < 0:\n        return -1\n    Px = O[0] + t * D[0]\n    Py = O[1] + t * D[1]\n    Pz = O[2] + t * D[2]\n    if Px*Px + Py*Py + Pz*Pz <= 1.0:\n        return t\n    return -1\n```",
        "```python\ndef intersect_disc(O, D):\n    eps = 1e-6\n    Nx, Ny, Nz = 1.0, 1.0, 1.0\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    denom = Dx*Nx + Dy*Ny + Dz*Nz\n    if abs(denom) < eps:\n        return -1.0\n    t = -(Ox*Nx + Oy*Ny + Oz*Nz) / denom\n    if t < 0.0:\n        return -1.0\n    Px = Ox + t*Dx\n    Py = Oy + t*Dy\n    Pz = Oz + t*Dz\n    if Px*Px + Py*Py + Pz*Pz <= 1.0:\n        return t\n    return -1.0\n```",
        "def intersect_disc(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    nx, ny, nz = 1.0, 1.0, 1.0\n    denom = dx*nx + dy*ny + dz*nz\n    if abs(denom) < 1e-6:\n        return -1.0\n    t = (-(ox*nx + oy*ny + oz*nz)) / denom\n    if t < 0.0:\n        return -1.0\n    px = ox + t*dx\n    py = oy + t*dy\n    pz = oz + t*dz\n    if px*px + py*py + pz*pz <= 1.0:\n        return t\n    return -1.0",
        "```python\ndef intersect_disc(O, D):\n    nx, ny, nz = 1.0, 1.0, 1.0\n    denom = nx*D[0] + ny*D[1] + nz*D[2]\n    if abs(denom) < 1e-6:\n        return -1.0\n    t = - (nx*O[0] + ny*O[1] + nz*O[2]) / denom\n    if t < 0.0:\n        return -1.0\n    px = O[0] + t*D[0]\n    py = O[1] + t*D[1]\n    pz = O[2] + t*D[2]\n    if px*px + py*py + pz*pz <= 1.0:\n        return t\n    return -1.0\n```",
        "```python\ndef intersect_disc(O, D):\n    N = (1.0, 1.0, 1.0)\n    denom = D[0]*N[0] + D[1]*N[1] + D[2]*N[2]\n    if abs(denom) < 1e-6:\n        return -1.0\n    t = -(O[0]*N[0] + O[1]*N[1] + O[2]*N[2]) / denom\n    if t < 0:\n        return -1.0\n    P = (O[0] + t*D[0], O[1] + t*D[1], O[2] + t*D[2])\n    if P[0]*P[0] + P[1]*P[1] + P[2]*P[2] <= 1.0:\n        return t\n    return -1.0\n```",
        "def intersect_disc(O, D):\n    N = (1.0, 1.0, 1.0)\n    denom = D[0]*N[0] + D[1]*N[1] + D[2]*N[2]\n    if abs(denom) < 1e-6:\n        return -1.0\n    num = -(O[0]*N[0] + O[1]*N[1] + O[2]*N[2])\n    t = num / denom\n    if t < 0.0:\n        return -1.0\n    P = (O[0] + t*D[0], O[1] + t*D[1], O[2] + t*D[2])\n    if P[0]*P[0] + P[1]*P[1] + P[2]*P[2] <= 1.0:\n        return t\n    return -1.0",
        "def intersect_disc(O, D):\n    Nx, Ny, Nz = 1.0, 1.0, 1.0\n    denom = Nx*D[0] + Ny*D[1] + Nz*D[2]\n    if abs(denom) < 1e-6:\n        return -1.0\n    t = -(Nx*O[0] + Ny*O[1] + Nz*O[2]) / denom\n    if t < 0.0:\n        return -1.0\n    x, y, z = O[0] + t*D[0], O[1] + t*D[1], O[2] + t*D[2]\n    if x*x + y*y + z*z <= 1.0:\n        return t\n    return -1.0"
    ],
    [
        "```python\ndef intersect_ray_quad_with_circle_hole(O, D):\n    p0 = (1.0, 1.0, 1.0)\n    p1 = (-1.0, 1.0, -1.0)\n    p2 = (-2.0, -1.0, -2.0)\n    p3 = (2.0, -1.0, 2.0)\n    def sub(a, b): return (a[0]-b[0], a[1]-b[1], a[2]-b[2])\n    def dot(a, b): return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]\n    def cross(a, b): return (a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0])\n    n = cross(sub(p1, p0), sub(p3, p0))\n    denom = dot(D, n)\n    if abs(denom) < 1e-6:\n        return -1.0\n    t = dot(sub(p0, O), n) / denom\n    if t < 0:\n        return -1.0\n    P = (O[0] + t*D[0], O[1] + t*D[1], O[2] + t*D[2])\n    verts = [p0, p1, p2, p3]\n    for i in range(4):\n        vi = verts[i]\n        vj = verts[(i+1) % 4]\n        if dot(n, cross(sub(vj, vi), sub(P, vi))) < 0:\n            return -1.0\n    if P[0]*P[0] + P[1]*P[1] + P[2]*P[2] <= 1.0:\n        return -1.0\n    return t\n```",
        "```python\ndef intersect_quad_with_hole(O, D):\n    def sub(a, b): return (a[0]-b[0], a[1]-b[1], a[2]-b[2])\n    def dot(a, b): return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]\n    def cross(a, b): return (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n    def inside_tri(P, A, B, C):\n        v0, v1, v2 = sub(C, A), sub(B, A), sub(P, A)\n        d00, d01, d11 = dot(v0, v0), dot(v0, v1), dot(v1, v1)\n        d02, d12 = dot(v0, v2), dot(v1, v2)\n        denom = d00*d11 - d01*d01\n        if denom == 0: return False\n        inv = 1.0/denom\n        u = (d11*d02 - d01*d12)*inv\n        v = (d00*d12 - d01*d02)*inv\n        return u >= 0 and v >= 0 and u+v <= 1\n    v0 = (1, 1, 1); v1 = (-1, 1, -1)\n    v2 = (-2, -1, -2); v3 = (2, -1, 2)\n    N = cross(sub(v1, v0), sub(v3, v0))\n    denom = dot(N, D)\n    if abs(denom) < 1e-6: return -1.0\n    t = dot(N, sub(v0, O)) / denom\n    if t < 0: return -1.0\n    P = (O[0]+t*D[0], O[1]+t*D[1], O[2]+t*D[2])\n    if P[0]*P[0] + P[1]*P[1] + P[2]*P[2] <= 1.0: return -1.0\n    if inside_tri(P, v0, v1, v2) or inside_tri(P, v0, v2, v3):\n        return t\n    return -1.0\n```",
        "```python\ndef intersect_quad_with_hole(O, D):\n    v0 = (1.0, 1.0, 1.0)\n    v1 = (-1.0, 1.0, -1.0)\n    v2 = (-2.0, -1.0, -2.0)\n    v3 = (2.0, -1.0, 2.0)\n    eps = 1e-6\n    def sub(a, b):\n        return (a[0]-b[0], a[1]-b[1], a[2]-b[2])\n    def dot(a, b):\n        return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]\n    def cross(a, b):\n        return (\n            a[1]*b[2] - a[2]*b[1],\n            a[2]*b[0] - a[0]*b[2],\n            a[0]*b[1] - a[1]*b[0]\n        )\n\n    # Plane normal\n    N = cross(sub(v1, v0), sub(v3, v0))\n    denom = dot(N, D)\n    if abs(denom) < eps:\n        return -1.0\n\n    t = dot(N, sub(v0, O)) / denom\n    if t < 0.0:\n        return -1.0\n\n    # Intersection point\n    P = (O[0] + t*D[0], O[1] + t*D[1], O[2] + t*D[2])\n\n    # Inside quad test (edge-cross-halfspace)\n    for A, B in ((v0, v1), (v1, v2), (v2, v3), (v3, v0)):\n        if dot(cross(sub(B, A), sub(P, A)), N) < -eps:\n            return -1.0\n\n    # Circular hole test (radius = 1 at origin)\n    if P[0]*P[0] + P[1]*P[1] + P[2]*P[2] < 1.0 - eps:\n        return -1.0\n\n    return t\n```",
        "```python\ndef intersect_quad_hole(O, D):\n    epsilon = 1e-6\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    Ax, Ay, Az = 1.0, 1.0, 1.0\n    Bx, By, Bz = -1.0, 1.0, -1.0\n    Cx, Cy, Cz = -2.0, -1.0, -2.0\n    Dx2, Dy2, Dz2 = 2.0, -1.0, 2.0\n    # plane normal\n    ABx, ABy, ABz = Bx-Ax, By-Ay, Bz-Az\n    ADx, ADy, ADz = Dx2-Ax, Dy2-Ay, Dz2-Az\n    Nx = ABy*ADz - ABz*ADy\n    Ny = ABz*ADx - ABx*ADz\n    Nz = ABx*ADy - ABy*ADx\n    denom = Nx*Dx + Ny*Dy + Nz*Dz\n    if abs(denom) < epsilon:\n        return -1.0\n    t = (Nx*(Ax-Ox) + Ny*(Ay-Oy) + Nz*(Az-Oz)) / denom\n    if t <= epsilon:\n        return -1.0\n    Px = Ox + t*Dx; Py = Oy + t*Dy; Pz = Oz + t*Dz\n    # inside quad\n    verts = [(Ax,Ay,Az),(Bx,By,Bz),(Cx,Cy,Cz),(Dx2,Dy2,Dz2)]\n    for i in range(4):\n        x1,y1,z1 = verts[i]\n        x2,y2,z2 = verts[(i+1)%4]\n        ex, ey, ez = x2-x1, y2-y1, z2-z1\n        vx, vy, vz = Px-x1, Py-y1, Pz-z1\n        cx, cy, cz = ey*vz - ez*vy, ez*vx - ex*vz, ex*vy - ey*vx\n        if cx*Nx + cy*Ny + cz*Nz < -epsilon:\n            return -1.0\n    # hole check\n    if Px*Px + Py*Py + Pz*Pz < 1.0 - epsilon:\n        return -1.0\n    return t\n```",
        "def intersect_quad_with_hole(O, D):\n    epsilon = 1e-6\n    v0 = (1.0, 1.0, 1.0)\n    v1 = (-1.0, 1.0, -1.0)\n    v2 = (-2.0, -1.0, -2.0)\n    v3 = (2.0, -1.0, 2.0)\n    def sub(a, b): return (a[0]-b[0], a[1]-b[1], a[2]-b[2])\n    def dot(a, b): return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]\n    def cross(a, b): return (a[1]*b[2] - a[2]*b[1],\n                              a[2]*b[0] - a[0]*b[2],\n                              a[0]*b[1] - a[1]*b[0])\n    # plane normal\n    E1 = sub(v1, v0)\n    E3 = sub(v3, v0)\n    N = cross(E1, E3)\n    denom = dot(D, N)\n    if abs(denom) < epsilon:\n        return -1.0\n    t = dot(sub(v0, O), N) / denom\n    if t < 0:\n        return -1.0\n    P = (O[0] + t*D[0], O[1] + t*D[1], O[2] + t*D[2])\n    # inside quad test\n    verts = [v0, v1, v2, v3]\n    for i in range(4):\n        a = verts[i]\n        b = verts[(i+1) % 4]\n        if dot(N, cross(sub(b, a), sub(P, a))) < -epsilon:\n            return -1.0\n    # circular hole\n    if dot(P, P) >= 1.0:\n        return t\n    return -1.0",
        "```python\ndef intersect_ray_quad_with_circle_hole(O, D):\n    # Vector operations\n    def sub(a, b): return (a[0]-b[0], a[1]-b[1], a[2]-b[2])\n    def dot(a, b): return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]\n    def cross(a, b): return (a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0])\n    def add(a, b): return (a[0]+b[0], a[1]+b[1], a[2]+b[2])\n    def scale(v, s): return (v[0]*s, v[1]*s, v[2]*s)\n\n    # Quad vertices\n    v0 = (1.0, 1.0, 1.0)\n    v1 = (-1.0, 1.0, -1.0)\n    v2 = (-2.0, -1.0, -2.0)\n    v3 = (2.0, -1.0, 2.0)\n\n    # Compute plane normal\n    N = cross(sub(v1, v0), sub(v3, v0))\n    denom = dot(D, N)\n    if abs(denom) < 1e-6:\n        return -1.0\n    t = dot(sub(v0, O), N) / denom\n    if t < 0.0:\n        return -1.0\n\n    # Intersection point\n    P = add(O, scale(D, t))\n\n    # Inside quad test (convex polygon)\n    verts = (v0, v1, v2, v3)\n    for i in range(4):\n        vi = verts[i]\n        vj = verts[(i+1) % 4]\n        if dot(cross(sub(vj, vi), sub(P, vi)), N) < 0.0:\n            return -1.0\n\n    # Circular hole test (radius = 1)\n    if dot(P, P) < 1.0:\n        return -1.0\n\n    return t\n```",
        "def intersect_quad_with_hole(O, D):\n    eps = 1e-6\n    def add(a, b):\n        return (a[0]+b[0], a[1]+b[1], a[2]+b[2])\n    def sub(a, b):\n        return (a[0]-b[0], a[1]-b[1], a[2]-b[2])\n    def dot(a, b):\n        return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]\n    def cross(a, b):\n        return (a[1]*b[2] - a[2]*b[1],\n                a[2]*b[0] - a[0]*b[2],\n                a[0]*b[1] - a[1]*b[0])\n    def mul(a, s):\n        return (a[0]*s, a[1]*s, a[2]*s)\n    def length(a):\n        return (a[0]*a[0] + a[1]*a[1] + a[2]*a[2])**0.5\n\n    p0 = (1.0, 1.0, 1.0)\n    p1 = (-1.0, 1.0, -1.0)\n    p2 = (-2.0, -1.0, -2.0)\n    p3 = (2.0, -1.0, 2.0)\n    # plane normal\n    n = cross(sub(p1, p0), sub(p3, p0))\n    ln = length(n)\n    if ln < eps: return -1.0\n    n = mul(n, 1.0/ln)\n    denom = dot(n, D)\n    if abs(denom) < eps: return -1.0\n    t = dot(n, sub(p0, O)) / denom\n    if t < eps: return -1.0\n    P = add(O, mul(D, t))\n    # check inside convex quad\n    verts = [p0, p1, p2, p3]\n    for i in range(4):\n        vi, vj = verts[i], verts[(i+1)%4]\n        edge = sub(vj, vi)\n        vp = sub(P, vi)\n        if dot(cross(edge, vp), n) < -eps:\n            return -1.0\n    # check circular hole of radius 1 at plane center\n    vproj = sub(P, mul(n, dot(P, n)))\n    if length(vproj) < 1.0 - eps:\n        return -1.0\n    return t",
        "```python\ndef intersect_quad_with_circle_hole(O, D):\n    def dot(u, v): return u[0]*v[0] + u[1]*v[1] + u[2]*v[2]\n    def cross(u, v): return (u[1]*v[2] - u[2]*v[1],\n                              u[2]*v[0] - u[0]*v[2],\n                              u[0]*v[1] - u[1]*v[0])\n    def sub(u, v): return (u[0]-v[0], u[1]-v[1], u[2]-v[2])\n    A = (1.0, 1.0,  1.0)\n    B = (-1.0, 1.0, -1.0)\n    C = (-2.0,-1.0, -2.0)\n    Dv = (2.0,-1.0,  2.0)\n    # Plane normal\n    n = cross(sub(B, A), sub(Dv, A))\n    denom = dot(D, n)\n    if abs(denom) < 1e-6:\n        return -1.0\n    t = dot(sub(A, O), n) / denom\n    if t < 0.0:\n        return -1.0\n    P = (O[0] + t*D[0], O[1] + t*D[1], O[2] + t*D[2])\n    # Hole test (radius 1 at origin)\n    if P[0]*P[0] + P[1]*P[1] + P[2]*P[2] < 1.0:\n        return -1.0\n    # Quad containment test (CCW order)\n    verts = [A, B, C, Dv]\n    for i in range(4):\n        Vi, Vj = verts[i], verts[(i+1)%4]\n        if dot(n, cross(sub(Vj, Vi), sub(P, Vi))) < 0.0:\n            return -1.0\n    return t\n```",
        "```python\ndef intersect_ray_quad_with_hole(O, D):\n    Ax,Ay,Az = 1.0,1.0,1.0\n    Bx,By,Bz = -1.0,1.0,-1.0\n    Cx,Cy,Cz = -2.0,-1.0,-2.0\n    Dx,Dy,Dz = 2.0,-1.0,2.0\n    Ox,Oy,Oz = O\n    DxR,DyR,DzR = D\n    # compute plane normal\n    ux,uy,uz = Bx-Ax, By-Ay, Bz-Az\n    vx,vy,vz = Cx-Ax, Cy-Ay, Cz-Az\n    nx = uy*vz - uz*vy\n    ny = uz*vx - ux*vz\n    nz = ux*vy - uy*vx\n    denom = nx*DxR + ny*DyR + nz*DzR\n    if abs(denom) < 1e-6:\n        return -1.0\n    t = (nx*(Ax-Ox) + ny*(Ay-Oy) + nz*(Az-Oz)) / denom\n    if t < 0:\n        return -1.0\n    Px,Py,Pz = Ox + t*DxR, Oy + t*DyR, Oz + t*DzR\n    # circular hole test\n    if Px*Px + Py*Py + Pz*Pz < 1.0:\n        return -1.0\n    def point_in_triangle(Px,Py,Pz, x0,y0,z0, x1,y1,z1, x2,y2,z2):\n        u0,u1,u2 = x1-x0, y1-y0, z1-z0\n        v0,v1,v2 = x2-x0, y2-y0, z2-z0\n        w0,w1,w2 = Px-x0, Py-y0, Pz-z0\n        dot00 = u0*u0 + u1*u1 + u2*u2\n        dot01 = u0*v0 + u1*v1 + u2*v2\n        dot02 = u0*w0 + u1*w1 + u2*w2\n        dot11 = v0*v0 + v1*v1 + v2*v2\n        dot12 = v0*w0 + v1*w1 + v2*w2\n        denom2 = dot00*dot11 - dot01*dot01\n        if abs(denom2) < 1e-6:\n            return False\n        alpha = (dot11*dot02 - dot01*dot12) / denom2\n        beta  = (dot00*dot12 - dot01*dot02) / denom2\n        return alpha >= 0 and beta >= 0 and alpha + beta <= 1\n    if point_in_triangle(Px,Py,Pz, Ax,Ay,Az, Bx,By,Bz, Cx,Cy,Cz) or \\\n       point_in_triangle(Px,Py,Pz, Ax,Ay,Az, Cx,Cy,Cz, Dx,Dy,Dz):\n        return t\n    return -1.0\n```",
        "def intersect_quad_hole(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    p0 = (1.0, 1.0, 1.0)\n    p1 = (-1.0, 1.0, -1.0)\n    p2 = (-2.0, -1.0, -2.0)\n    p3 = (2.0, -1.0, 2.0)\n    # Plane normal n = (-1, 0, 1)\n    denom = -Dx + Dz\n    if abs(denom) < 1e-6:\n        return -1.0\n    # n \u00b7 (O - p0) = Oz - Ox\n    na = (Oz - Ox)\n    t = -na / denom\n    if t < 0.0:\n        return -1.0\n    # Intersection point\n    Px = Ox + t * Dx\n    Py = Oy + t * Dy\n    Pz = Oz + t * Dz\n    # Inside quad test\n    n0, n1, n2 = -1.0, 0.0, 1.0\n    for Vi, Vj in ((p0, p1), (p1, p2), (p2, p3), (p3, p0)):\n        Ex, Ey, Ez = Vj[0] - Vi[0], Vj[1] - Vi[1], Vj[2] - Vi[2]\n        VPx, VPy, VPz = Px - Vi[0], Py - Vi[1], Pz - Vi[2]\n        cx = Ey * VPz - Ez * VPy\n        cy = Ez * VPx - Ex * VPz\n        cz = Ex * VPy - Ey * VPx\n        if n0 * cx + n1 * cy + n2 * cz < 0.0:\n            return -1.0\n    # Circular hole test (radius 1 at origin)\n    if Px * Px + Py * Py + Pz * Pz < 1.0:\n        return -1.0\n    return t"
    ],
    [
        "def intersect_ray_plane_with_triangle_hole(O, D):\n    # Plane y = z \u2192 normal n and plane constant d\n    n = (0.0, 1.0, -1.0)\n    d = 0.0\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    denom = n[1]*Dy + n[2]*Dz  # n\u00b7D = 1*Dy + (-1)*Dz\n    if abs(denom) < 1e-8:\n        return -1.0\n    t = -(n[0]*Ox + n[1]*Oy + n[2]*Oz + d) / denom\n    if t < 0.0:\n        return -1.0\n    Px, Py, Pz = Ox + t*Dx, Oy + t*Dy, Oz + t*Dz\n    # Triangle hole vertices\n    A = (1.0, 1.0, 1.0)\n    B = (-1.0, 0.0, 0.0)\n    C = (0.0, -1.0, -1.0)\n    # check if P inside triangle ABC (hole) using edge tests\n    def edge_test(U, V, P):\n        # (V-U) x (P-U) \u00b7 n\n        Ex, Ey, Ez = V[0]-U[0], V[1]-U[1], V[2]-U[2]\n        Vx, Vy, Vz = P[0]-U[0], P[1]-U[1], P[2]-U[2]\n        cx = Ey*Vz - Ez*Vy\n        cy = Ez*Vx - Ex*Vz\n        cz = Ex*Vy - Ey*Vx\n        return cx*n[0] + cy*n[1] + cz*n[2]\n    if (edge_test(A, B, (Px,Py,Pz)) <= 1e-8 and\n        edge_test(B, C, (Px,Py,Pz)) <= 1e-8 and\n        edge_test(C, A, (Px,Py,Pz)) <= 1e-8):\n        return -1.0\n    return t",
        "```python\ndef intersect_plane_with_tri_hole(O, D):\n    eps = 1e-8\n    # Plane: y - z = 0, normal N = (0,1,-1)\n    N = (0.0, 1.0, -1.0)\n    denom = N[0]*D[0] + N[1]*D[1] + N[2]*D[2]\n    if abs(denom) < eps:\n        return -1.0\n    t = - (N[0]*O[0] + N[1]*O[1] + N[2]*O[2]) / denom\n    if t < 0.0:\n        return -1.0\n    P = (O[0] + t*D[0], O[1] + t*D[1], O[2] + t*D[2])\n    # Triangle hole vertices A, B, C in CCW order\n    A = (1.0, 1.0, 1.0)\n    B = (-1.0, 0.0, 0.0)\n    C = (0.0, -1.0, -1.0)\n    # Barycentric coordinate test\n    v0 = (B[0]-A[0], B[1]-A[1], B[2]-A[2])\n    v1 = (C[0]-A[0], C[1]-A[1], C[2]-A[2])\n    v2 = (P[0]-A[0], P[1]-A[1], P[2]-A[2])\n    dot00 = v0[0]*v0[0] + v0[1]*v0[1] + v0[2]*v0[2]\n    dot01 = v0[0]*v1[0] + v0[1]*v1[1] + v0[2]*v1[2]\n    dot02 = v0[0]*v2[0] + v0[1]*v2[1] + v0[2]*v2[2]\n    dot11 = v1[0]*v1[0] + v1[1]*v1[1] + v1[2]*v1[2]\n    dot12 = v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2]\n    denom2 = dot00*dot11 - dot01*dot01\n    if abs(denom2) < eps:\n        return t\n    u = (dot11*dot02 - dot01*dot12) / denom2\n    v = (dot00*dot12 - dot01*dot02) / denom2\n    # Strictly inside hole => no intersection\n    if u > eps and v > eps and u + v < 1.0 - eps:\n        return -1.0\n    return t\n```",
        "```python\ndef intersect_plane_with_triangle_hole(O, D):\n    eps = 1e-6\n    denom = D[1] - D[2]\n    if abs(denom) < eps:\n        return -1.0\n    t = (O[2] - O[1]) / denom\n    if t < 0:\n        return -1.0\n    # Intersection point\n    Px, Py, Pz = O[0] + D[0]*t, O[1] + D[1]*t, O[2] + D[2]*t\n    # Triangle vertices\n    Ax, Ay, Az = 1.0, 1.0, 1.0\n    Bx, By, Bz = -1.0, 0.0, 0.0\n    Cx, Cy, Cz = 0.0, -1.0, -1.0\n    # Vectors for barycentric\n    v0 = (Cx-Ax, Cy-Ay, Cz-Az)\n    v1 = (Bx-Ax, By-Ay, Bz-Az)\n    v2 = (Px-Ax, Py-Ay, Pz-Az)\n    dot00 = v0[0]*v0[0] + v0[1]*v0[1] + v0[2]*v0[2]\n    dot01 = v0[0]*v1[0] + v0[1]*v1[1] + v0[2]*v1[2]\n    dot02 = v0[0]*v2[0] + v0[1]*v2[1] + v0[2]*v2[2]\n    dot11 = v1[0]*v1[0] + v1[1]*v1[1] + v1[2]*v1[2]\n    dot12 = v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2]\n    invDenom = 1.0 / (dot00*dot11 - dot01*dot01)\n    u = (dot11*dot02 - dot01*dot12) * invDenom\n    v = (dot00*dot12 - dot01*dot02) * invDenom\n    # If inside triangle (including boundary), it's a hole -> no intersection\n    if u >= 0.0 and v >= 0.0 and u + v <= 1.0:\n        return -1.0\n    return t\n```",
        "def intersect_plane_with_triangle_hole(O, D):\n    x0, y0, z0 = O\n    dx, dy, dz = D\n    denom = dy - dz\n    if abs(denom) < 1e-8:\n        return -1.0\n    t = (z0 - y0) / denom\n    if t < 0.0:\n        return -1.0\n    px = x0 + t * dx\n    py = y0 + t * dy\n    pz = z0 + t * dz\n    ax, ay, az = 1.0, 1.0, 1.0\n    bx, by, bz = -1.0, 0.0, 0.0\n    cx, cy, cz = 0.0, -1.0, -1.0\n    v0x, v0y, v0z = cx - ax, cy - ay, cz - az\n    v1x, v1y, v1z = bx - ax, by - ay, bz - az\n    v2x, v2y, v2z = px - ax, py - ay, pz - az\n    dot00 = v0x*v0x + v0y*v0y + v0z*v0z\n    dot01 = v0x*v1x + v0y*v1y + v0z*v1z\n    dot02 = v0x*v2x + v0y*v2y + v0z*v2z\n    dot11 = v1x*v1x + v1y*v1y + v1z*v1z\n    dot12 = v1x*v2x + v1y*v2y + v1z*v2z\n    invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01)\n    u = (dot11 * dot02 - dot01 * dot12) * invDenom\n    v = (dot00 * dot12 - dot01 * dot02) * invDenom\n    if u > 0.0 and v > 0.0 and u + v < 1.0:\n        return -1.0\n    return t",
        "def intersect_ray_plane_with_triangle_hole(O, D):\n    # plane: y = z  ->  n\u00b7X = 0 with n = (0,1,-1)\n    n = (0.0, 1.0, -1.0)\n    denom = n[1]*D[1] + n[2]*D[2]\n    if abs(denom) < 1e-8:\n        return -1.0\n    t = -(n[1]*O[1] + n[2]*O[2]) / denom\n    if t < 0.0:\n        return -1.0\n    P = (O[0] + t*D[0], O[1] + t*D[1], O[2] + t*D[2])\n    # triangle hole vertices\n    A = (1.0, 1.0, 1.0)\n    B = (-1.0, 0.0, 0.0)\n    C = (0.0, -1.0, -1.0)\n    # barycentric test\n    v0 = (B[0]-A[0], B[1]-A[1], B[2]-A[2])\n    v1 = (C[0]-A[0], C[1]-A[1], C[2]-A[2])\n    v2 = (P[0]-A[0], P[1]-A[1], P[2]-A[2])\n    def dot(u, v):\n        return u[0]*v[0] + u[1]*v[1] + u[2]*v[2]\n    d00 = dot(v0, v0)\n    d01 = dot(v0, v1)\n    d11 = dot(v1, v1)\n    d20 = dot(v2, v0)\n    d21 = dot(v2, v1)\n    denom2 = d00*d11 - d01*d01\n    if abs(denom2) < 1e-8:\n        return t\n    v = (d11*d20 - d01*d21) / denom2\n    w = (d00*d21 - d01*d20) / denom2\n    u = 1.0 - v - w\n    # inside hole if strictly inside\n    if u > 0.0 and v > 0.0 and w > 0.0:\n        return -1.0\n    return t",
        "def intersect(O, D):\n    # Plane y = z: normal n = (0,1,-1)\n    denom = D[1] - D[2]\n    if abs(denom) < 1e-8:\n        return -1.0\n    t = (O[2] - O[1]) / denom\n    if t < 0:\n        return -1.0\n    # Intersection point\n    Px, Py, Pz = O[0] + t*D[0], O[1] + t*D[1], O[2] + t*D[2]\n    # Triangle hole vertices\n    Ax, Ay, Az = 1.0, 1.0, 1.0\n    Bx, By, Bz = -1.0, 0.0, 0.0\n    Cx, Cy, Cz = 0.0, -1.0, -1.0\n    # Vectors for barycentric\n    v0x, v0y, v0z = Bx - Ax, By - Ay, Bz - Az\n    v1x, v1y, v1z = Cx - Ax, Cy - Ay, Cz - Az\n    v2x, v2y, v2z = Px - Ax, Py - Ay, Pz - Az\n    # Dot products\n    dot00 = v0x*v0x + v0y*v0y + v0z*v0z\n    dot01 = v0x*v1x + v0y*v1y + v0z*v1z\n    dot02 = v0x*v2x + v0y*v2y + v0z*v2z\n    dot11 = v1x*v1x + v1y*v1y + v1z*v1z\n    dot12 = v1x*v2x + v1y*v2y + v1z*v2z\n    denomB = dot00 * dot11 - dot01 * dot01\n    if abs(denomB) < 1e-8:\n        return t\n    invDen = 1.0 / denomB\n    u = (dot11 * dot02 - dot01 * dot12) * invDen\n    v = (dot00 * dot12 - dot01 * dot02) * invDen\n    # Strict inside triangle => hole\n    if u > 0 and v > 0 and (u + v) < 1:\n        return -1.0\n    return t",
        "```python\ndef intersect_plane_with_triangle_hole(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    denom = dy - dz\n    if abs(denom) < 1e-6:\n        return -1.0\n    t = (oz - oy) / denom\n    if t < 0.0:\n        return -1.0\n    px = ox + t * dx\n    py = oy + t * dy\n    pz = oz + t * dz\n    p1 = (1.0, 1.0, 1.0)\n    p2 = (-1.0, 0.0, 0.0)\n    p3 = (0.0, -1.0, -1.0)\n    v0 = (p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2])\n    v1 = (p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2])\n    v2 = (px   - p1[0], py   - p1[1], pz   - p1[2])\n    dot00 = v0[0]*v0[0] + v0[1]*v0[1] + v0[2]*v0[2]\n    dot01 = v0[0]*v1[0] + v0[1]*v1[1] + v0[2]*v1[2]\n    dot02 = v0[0]*v2[0] + v0[1]*v2[1] + v0[2]*v2[2]\n    dot11 = v1[0]*v1[0] + v1[1]*v1[1] + v1[2]*v1[2]\n    dot12 = v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2]\n    inv_denom = 1.0 / (dot00 * dot11 - dot01 * dot01)\n    u = (dot11 * dot02 - dot01 * dot12) * inv_denom\n    v = (dot00 * dot12 - dot01 * dot02) * inv_denom\n    if u >= 0.0 and v >= 0.0 and u + v <= 1.0:\n        return -1.0\n    return t\n```",
        "```python\ndef intersect_plane_with_triangle_hole(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    denom = Dy - Dz\n    if abs(denom) < 1e-8:\n        return -1.0\n    t = (Oz - Oy) / denom\n    if t < 0.0:\n        return -1.0\n    Px = Ox + t * Dx\n    Py = Oy + t * Dy\n    # Project to 2D (x,y), since on plane y=z we have Py == Pz\n    P2x, P2y = Px, Py\n    tri = [(1.0, 1.0), (-1.0, 0.0), (0.0, -1.0)]\n    for i in range(3):\n        ax, ay = tri[i]\n        bx, by = tri[(i + 1) % 3]\n        cross = (ax - bx) * (P2y - by) - (ay - by) * (P2x - bx)\n        if cross < 0.0:\n            return t\n    return -1.0\n```",
        "def intersect_plane_triangle_hole(O, D):\n    tol = 1e-6\n    ox, oy, oz = O\n    dx, dy, dz = D\n    den = dy - dz\n    if abs(den) < tol:\n        return -1.0\n    t = (oz - oy) / den\n    if t < 0:\n        return -1.0\n    px = ox + t * dx\n    py = oy + t * dy\n    pz = oz + t * dz\n    Ax, Ay, Az = 1.0, 1.0, 1.0\n    Bx, By, Bz = -1.0, 0.0, 0.0\n    Cx, Cy, Cz = 0.0, -1.0, -1.0\n    nx, ny, nz = 0.0, -3.0, 3.0\n    # edge AB\n    ex0, ey0, ez0 = Bx - Ax, By - Ay, Bz - Az\n    vx0, vy0, vz0 = px - Ax, py - Ay, pz - Az\n    cx0 = ey0 * vz0 - ez0 * vy0\n    cy0 = ez0 * vx0 - ex0 * vz0\n    cz0 = ex0 * vy0 - ey0 * vx0\n    dot0 = cx0 * nx + cy0 * ny + cz0 * nz\n    # edge BC\n    ex1, ey1, ez1 = Cx - Bx, Cy - By, Cz - Bz\n    vx1, vy1, vz1 = px - Bx, py - By, pz - Bz\n    cx1 = ey1 * vz1 - ez1 * vy1\n    cy1 = ez1 * vx1 - ex1 * vz1\n    cz1 = ex1 * vy1 - ey1 * vx1\n    dot1 = cx1 * nx + cy1 * ny + cz1 * nz\n    # edge CA\n    ex2, ey2, ez2 = Ax - Cx, Ay - Cy, Az - Cz\n    vx2, vy2, vz2 = px - Cx, py - Cy, pz - Cz\n    cx2 = ey2 * vz2 - ez2 * vy2\n    cy2 = ez2 * vx2 - ex2 * vz2\n    cz2 = ex2 * vy2 - ey2 * vx2\n    dot2 = cx2 * nx + cy2 * ny + cz2 * nz\n    if dot0 > 0 and dot1 > 0 and dot2 > 0:\n        return -1.0\n    return t",
        "```python\ndef intersect_plane_triangle_hole(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    eps = 1e-8\n    # intersect with plane y = z\n    denom = Dy - Dz\n    if abs(denom) < eps:\n        return -1.0\n    t = -(Oy - Oz) / denom\n    if t < 0.0:\n        return -1.0\n    # intersection point\n    Px = Ox + t * Dx\n    Py = Oy + t * Dy\n    Pz = Oz + t * Dz\n    # triangle vertices\n    Ax, Ay, Az = 1.0, 1.0, 1.0\n    Bx, By, Bz = -1.0, 0.0, 0.0\n    Cx, Cy, Cz = 0.0, -1.0, -1.0\n    # barycentric coordinates\n    v0x, v0y, v0z = Bx - Ax, By - Ay, Bz - Az\n    v1x, v1y, v1z = Cx - Ax, Cy - Ay, Cz - Az\n    v2x, v2y, v2z = Px - Ax, Py - Ay, Pz - Az\n    dot00 = v0x*v0x + v0y*v0y + v0z*v0z\n    dot01 = v0x*v1x + v0y*v1y + v0z*v1z\n    dot11 = v1x*v1x + v1y*v1y + v1z*v1z\n    dot02 = v0x*v2x + v0y*v2y + v0z*v2z\n    dot12 = v1x*v2x + v1y*v2y + v1z*v2z\n    inv_denom = 1.0 / (dot00 * dot11 - dot01 * dot01)\n    u = (dot11 * dot02 - dot01 * dot12) * inv_denom\n    v = (dot00 * dot12 - dot01 * dot02) * inv_denom\n    # if inside triangle hole (open region), no intersection\n    if u > eps and v > eps and u + v < 1.0 - eps:\n        return -1.0\n    return t\n```"
    ],
    [
        "def intersect_ray_ellipsoid(O, D):\n    Cx, Cy, Cz = 1.0, 1.0, 1.0\n    a, b, c = 2.0, 3.0, 4.0\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    A = Dx*Dx/(a*a) + Dy*Dy/(b*b) + Dz*Dz/(c*c)\n    B = 2*((Ox-Cx)*Dx/(a*a) + (Oy-Cy)*Dy/(b*b) + (Oz-Cz)*Dz/(c*c))\n    C = (Ox-Cx)*(Ox-Cx)/(a*a) + (Oy-Cy)*(Oy-Cy)/(b*b) + (Oz-Cz)*(Oz-Cz)/(c*c) - 1.0\n    disc = B*B - 4*A*C\n    if disc < 0.0:\n        return -1.0\n    sqrt_disc = disc**0.5\n    t1 = (-B - sqrt_disc) / (2*A)\n    t2 = (-B + sqrt_disc) / (2*A)\n    t = float('inf')\n    if t1 > 0 and t1 < t: t = t1\n    if t2 > 0 and t2 < t: t = t2\n    return t if t < float('inf') else -1.0",
        "def intersect_ellipsoid(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    cx, cy, cz = 1.0, 1.0, 1.0\n    a, b, c = 2.0, 3.0, 4.0\n    ox = (ox - cx) / a\n    oy = (oy - cy) / b\n    oz = (oz - cz) / c\n    dx /= a\n    dy /= b\n    dz /= c\n    A = dx*dx + dy*dy + dz*dz\n    B = 2.0*(ox*dx + oy*dy + oz*dz)\n    C = ox*ox + oy*oy + oz*oz - 1.0\n    disc = B*B - 4.0*A*C\n    if disc < 0.0:\n        return -1.0\n    sqrt_disc = disc**0.5\n    t0 = (-B - sqrt_disc) / (2.0*A)\n    t1 = (-B + sqrt_disc) / (2.0*A)\n    if t0 > 0.0 and t1 > 0.0:\n        return min(t0, t1)\n    elif t0 > 0.0:\n        return t0\n    elif t1 > 0.0:\n        return t1\n    else:\n        return -1.0",
        "def intersect_ellipsoid(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    ox -= 1.0; oy -= 1.0; oz -= 1.0\n    A = (dx/2.0)**2 + (dy/3.0)**2 + (dz/4.0)**2\n    B = 2.0 * (dx*ox/4.0 + dy*oy/9.0 + dz*oz/16.0)\n    C = (ox/2.0)**2 + (oy/3.0)**2 + (oz/4.0)**2 - 1.0\n    disc = B*B - 4.0*A*C\n    if disc < 0.0 or A == 0.0:\n        return -1.0\n    sqrt_disc = disc**0.5\n    t1 = (-B - sqrt_disc) / (2.0*A)\n    t2 = (-B + sqrt_disc) / (2.0*A)\n    t0 = t1 if t1 < t2 else t2\n    if t0 >= 0.0:\n        return t0\n    t1, t2 = t2, t1  # ensure t1 is the larger\n    return t1 if t1 >= 0.0 else -1.0",
        "```python\ndef intersect_ray_ellipsoid(O, D):\n    import math\n    Cx, Cy, Cz = 1.0, 1.0, 1.0\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    Px = Ox - Cx\n    Py = Oy - Cy\n    Pz = Oz - Cz\n    a = Dx*Dx/4.0 + Dy*Dy/9.0 + Dz*Dz/16.0\n    b = 2.0*(Px*Dx/4.0 + Py*Dy/9.0 + Pz*Dz/16.0)\n    c = Px*Px/4.0 + Py*Py/9.0 + Pz*Pz/16.0 - 1.0\n    disc = b*b - 4.0*a*c\n    if disc < 0.0:\n        return -1.0\n    sqrt_disc = math.sqrt(disc)\n    t0 = (-b - sqrt_disc) / (2.0*a)\n    t1 = (-b + sqrt_disc) / (2.0*a)\n    t_near = min(t0, t1)\n    t_far = max(t0, t1)\n    if t_near >= 0.0:\n        return t_near\n    if t_far >= 0.0:\n        return t_far\n    return -1.0\n```",
        "```python\ndef intersect_ellipsoid(O, D):\n    import math\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    cx, cy, cz = 1.0, 1.0, 1.0\n    a2, b2, c2 = 4.0, 9.0, 16.0\n    ex, ey, ez = Ox - cx, Oy - cy, Oz - cz\n    A = Dx*Dx/a2 + Dy*Dy/b2 + Dz*Dz/c2\n    B = 2.0*(ex*Dx/a2 + ey*Dy/b2 + ez*Dz/c2)\n    C = ex*ex/a2 + ey*ey/b2 + ez*ez/c2 - 1.0\n    disc = B*B - 4.0*A*C\n    if disc < 0.0:\n        return -1.0\n    sqrt_d = math.sqrt(disc)\n    t0 = (-B - sqrt_d) / (2.0*A)\n    t1 = (-B + sqrt_d) / (2.0*A)\n    tmin, tmax = min(t0, t1), max(t0, t1)\n    if tmin >= 0.0:\n        return tmin\n    if tmax >= 0.0:\n        return tmax\n    return -1.0\n```",
        "def intersect_ray_ellipsoid(O, D):\n    from math import sqrt\n    cx, cy, cz = 1.0, 1.0, 1.0\n    a2, b2, c2 = 4.0, 9.0, 16.0\n    Lx, Ly, Lz = O[0] - cx, O[1] - cy, O[2] - cz\n    Dx, Dy, Dz = D\n    A = Dx*Dx/a2 + Dy*Dy/b2 + Dz*Dz/c2\n    B = Lx*Dx/a2 + Ly*Dy/b2 + Lz*Dz/c2\n    C = Lx*Lx/a2 + Ly*Ly/b2 + Lz*Lz/c2 - 1.0\n    disc = B*B - A*C\n    if disc < 0 or A == 0:\n        return -1.0\n    sqrt_disc = sqrt(disc)\n    t0 = (-B - sqrt_disc)/A\n    t1 = (-B + sqrt_disc)/A\n    if t0 > 0:\n        return t0\n    if t1 > 0:\n        return t1\n    return -1.0",
        "```python\ndef intersect_ellipsoid(O, D):\n    import math\n    # Ellipsoid parameters\n    cx, cy, cz = 1.0, 1.0, 1.0\n    a2, b2, c2 = 2.0**2, 3.0**2, 4.0**2\n    # Ray origin and direction\n    ox, oy, oz = O\n    dx, dy, dz = D\n    # Coefficients for quadratic At^2 + Bt + C = 0\n    xo, yo, zo = ox - cx, oy - cy, oz - cz\n    A = dx*dx/a2 + dy*dy/b2 + dz*dz/c2\n    B = 2*(dx*xo/a2 + dy*yo/b2 + dz*zo/c2)\n    C = xo*xo/a2 + yo*yo/b2 + zo*zo/c2 - 1.0\n    # Solve\n    if abs(A) < 1e-8:\n        if abs(B) < 1e-8:\n            return -1.0\n        t = -C / B\n        return t if t >= 0.0 else -1.0\n    disc = B*B - 4*A*C\n    if disc < 0.0:\n        return -1.0\n    sqrt_disc = math.sqrt(disc)\n    t0 = (-B - sqrt_disc) / (2*A)\n    t1 = (-B + sqrt_disc) / (2*A)\n    ts = [t for t in (t0, t1) if t >= 0.0]\n    return min(ts) if ts else -1.0\n```",
        "```python\ndef intersect_ray_ellipsoid(O, D):\n    import math\n    # Ellipsoid center and squared semi-axes\n    cx, cy, cz = 1.0, 1.0, 1.0\n    a2, b2, c2 = 2.0**2, 3.0**2, 4.0**2\n    # Translate ray origin\n    ox, oy, oz = O[0] - cx, O[1] - cy, O[2] - cz\n    dx, dy, dz = D\n    # Quadratic coefficients\n    A = dx*dx/a2 + dy*dy/b2 + dz*dz/c2\n    B = 2*(ox*dx/a2 + oy*dy/b2 + oz*dz/c2)\n    C = ox*ox/a2 + oy*oy/b2 + oz*oz/c2 - 1.0\n    # Discriminant\n    disc = B*B - 4*A*C\n    if disc < 0 or abs(A) < 1e-8:\n        return -1.0\n    sqrt_disc = math.sqrt(disc)\n    t0 = (-B - sqrt_disc) / (2*A)\n    t1 = (-B + sqrt_disc) / (2*A)\n    # Select smallest non-negative t\n    if t0 >= 0 and t1 >= 0:\n        return min(t0, t1)\n    if t0 >= 0:\n        return t0\n    if t1 >= 0:\n        return t1\n    return -1.0\n```",
        "```python\ndef intersect_ray_ellipsoid(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    # Ellipsoid center and squared semi-axes\n    cx, cy, cz = 1.0, 1.0, 1.0\n    a2, b2, c2 = 4.0, 9.0, 16.0\n    # Translate ray origin to ellipsoid coordinate\n    xo, yo, zo = ox - cx, oy - cy, oz - cz\n    # Quadratic coefficients\n    A = dx*dx/a2 + dy*dy/b2 + dz*dz/c2\n    B = 2*(dx*xo/a2 + dy*yo/b2 + dz*zo/c2)\n    C = xo*xo/a2 + yo*yo/b2 + zo*zo/c2 - 1.0\n    # Discriminant\n    disc = B*B - 4*A*C\n    if A == 0 or disc < 0:\n        return -1.0\n    sqrt_disc = disc**0.5\n    t0 = (-B - sqrt_disc) / (2*A)\n    t1 = (-B + sqrt_disc) / (2*A)\n    # Choose smallest positive t\n    t = min(t0, t1) if min(t0, t1) > 0 else max(t0, t1)\n    return t if t > 0 else -1.0\n```",
        "def intersect_ray_ellipsoid(O, D):\n    import math\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    ocx = Ox - 1.0\n    ocy = Oy - 1.0\n    ocz = Oz - 1.0\n    a = Dx*Dx/4.0 + Dy*Dy/9.0 + Dz*Dz/16.0\n    b = 2.0*(ocx*Dx/4.0 + ocy*Dy/9.0 + ocz*Dz/16.0)\n    c = ocx*ocx/4.0 + ocy*ocy/9.0 + ocz*ocz/16.0 - 1.0\n    disc = b*b - 4.0*a*c\n    if disc < 0.0:\n        return -1.0\n    sqrt_disc = math.sqrt(disc)\n    t1 = (-b - sqrt_disc) / (2.0*a)\n    t2 = (-b + sqrt_disc) / (2.0*a)\n    t = float('inf')\n    if t1 >= 0.0:\n        t = t1\n    if t2 >= 0.0 and t2 < t:\n        t = t2\n    return t if t != float('inf') else -1.0"
    ],
    [
        "def intersect_cut_sphere(O, D):\n    import math\n    x0, y0, z0 = O\n    dx, dy, dz = D\n    # intersection with cut disc\n    t_disc = None\n    denom = dx + dy\n    if denom != 0:\n        t = (1 - (x0 + y0)) / denom\n        if t > 0 and denom < 0:\n            px, py, pz = x0 + t*dx, y0 + t*dy, z0 + t*dz\n            if px*px + py*py + pz*pz <= 1:\n                t_disc = t\n    # intersection with sphere\n    a = dx*dx + dy*dy + dz*dz\n    b = 2*(x0*dx + y0*dy + z0*dz)\n    c = x0*x0 + y0*y0 + z0*z0 - 1\n    disc = b*b - 4*a*c\n    t_sph = None\n    if disc >= 0:\n        sd = math.sqrt(disc)\n        for t in sorted([(-b - sd)/(2*a), (-b + sd)/(2*a)]):\n            if t > 0:\n                px, py = x0 + t*dx, y0 + t*dy\n                if px + py <= 1:\n                    t_sph = t\n                    break\n    ts = [t for t in (t_disc, t_sph) if t is not None]\n    return min(ts) if ts else -1.0",
        "def intersect_ray_cut_sphere(O, D):\n    import math\n    ox, oy, oz = O\n    dx, dy, dz = D\n    # Sphere intersection (centered at origin, radius=1)\n    a = dx*dx + dy*dy + dz*dz\n    b = 2*(ox*dx + oy*dy + oz*dz)\n    c = ox*ox + oy*oy + oz*oz - 1\n    disc = b*b - 4*a*c\n    ts = []\n    if disc >= 0:\n        sd = math.sqrt(disc)\n        for t in [(-b - sd)/(2*a), (-b + sd)/(2*a)]:\n            if t > 0:\n                px, py, pz = ox + t*dx, oy + t*dy, oz + t*dz\n                if px + py <= 1:\n                    ts.append(t)\n    # Plane intersection (x + y = 1)\n    nx, ny, nz = 1, 1, 0\n    denom = nx*dx + ny*dy + nz*dz\n    if abs(denom) > 1e-6:\n        t_plane = (1 - (nx*ox + ny*oy + nz*oz)) / denom\n        if t_plane > 0:\n            px, py, pz = ox + t_plane*dx, oy + t_plane*dy, oz + t_plane*dz\n            if px*px + py*py + pz*pz <= 1:\n                ts.append(t_plane)\n    return min(ts) if ts else -1.0",
        "def intersect_cut_sphere(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    # Sphere intersection (center=0, radius=1)\n    a = dx*dx + dy*dy + dz*dz\n    b = 2*(ox*dx + oy*dy + oz*dz)\n    c = ox*ox + oy*oy + oz*oz - 1\n    disc = b*b - 4*a*c\n    t_hit = float('inf')\n    if disc >= 0:\n        sqrt_disc = disc**0.5\n        t0 = (-b - sqrt_disc) / (2*a)\n        t1 = (-b + sqrt_disc) / (2*a)\n        for t in (t0, t1):\n            if t >= 0:\n                x = ox + t*dx\n                y = oy + t*dy\n                z = oz + t*dz\n                if x + y <= 1:\n                    t_hit = t\n                    break\n    # Plane intersection (x+y=1)\n    denom = dx + dy\n    if denom != 0:\n        t_plane = (1 - ox - oy) / denom\n        if t_plane >= 0:\n            x = ox + t_plane*dx\n            y = oy + t_plane*dy\n            z = oz + t_plane*dz\n            if x*x + y*y + z*z <= 1:\n                t_hit = min(t_hit, t_plane)\n    return t_hit if t_hit != float('inf') else -1.0",
        "```python\ndef intersect_cut_sphere(O, D):\n    import math\n    eps = 1e-6\n    ox, oy, oz = O\n    dx, dy, dz = D\n\n    # Sphere intersection\n    a = dx*dx + dy*dy + dz*dz\n    b = 2*(ox*dx + oy*dy + oz*dz)\n    c = ox*ox + oy*oy + oz*oz - 1\n    disc = b*b - 4*a*c\n    ts = []\n    if disc >= 0:\n        sd = math.sqrt(disc)\n        t1 = (-b - sd) / (2*a)\n        t2 = (-b + sd) / (2*a)\n        for t in sorted((t1, t2)):\n            if t >= 0:\n                px = ox + t*dx\n                py = oy + t*dy\n                if px + py <= 1 + eps:\n                    ts.append(t)\n\n    # Plane intersection (x+y=1)\n    nx, ny, nz = 1.0, 1.0, 0.0\n    denom = nx*dx + ny*dy + nz*dz\n    if abs(denom) > eps:\n        t_plane = (1 - (nx*ox + ny*oy + nz*oz)) / denom\n        if t_plane >= 0:\n            px = ox + t_plane*dx\n            py = oy + t_plane*dy\n            pz = oz + t_plane*dz\n            if (px-0.5)**2 + (py-0.5)**2 + pz*pz <= 0.5 + eps:\n                ts.append(t_plane)\n\n    return min(ts) if ts else -1\n```",
        "```python\ndef intersect_cut_sphere(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    # Sphere intersection (centered at 0, radius = 1)\n    a = dx*dx + dy*dy + dz*dz\n    b = ox*dx + oy*dy + oz*dz\n    c = ox*ox + oy*oy + oz*oz - 1.0\n    disc = b*b - a*c\n    t_sph = None\n    if disc >= 0.0:\n        sqrt_disc = disc**0.5\n        t1 = (-b - sqrt_disc) / a\n        t2 = (-b + sqrt_disc) / a\n        ts = [t for t in (t1, t2) if t > 0.0]\n        if ts:\n            t_candidate = min(ts)\n            px, py, pz = ox + t_candidate*dx, oy + t_candidate*dy, oz + t_candidate*dz\n            if px + py <= 1.0:\n                t_sph = t_candidate\n    # Plane-cut intersection (plane x+y=1, disc radius 1)\n    denom = dx + dy\n    t_pl = None\n    if denom != 0.0:\n        t_plane = (1.0 - ox - oy) / denom\n        if t_plane > 0.0 and ox + oy > 1.0 and denom < 0.0:\n            px, py, pz = ox + t_plane*dx, oy + t_plane*dy, oz + t_plane*dz\n            if px*px + py*py + pz*pz <= 1.0:\n                t_pl = t_plane\n    # Choose nearest positive intersection\n    ts = [t for t in (t_sph, t_pl) if t is not None]\n    return min(ts) if ts else -1.0\n```",
        "def intersect_cut_sphere(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    # Sphere intersection (x^2+y^2+z^2=1)\n    a = dx*dx + dy*dy + dz*dz\n    b = 2*(ox*dx + oy*dy + oz*dz)\n    c = ox*ox + oy*oy + oz*oz - 1\n    disc = b*b - 4*a*c\n    ts = []\n    if disc >= 0:\n        sd = disc**0.5\n        for t in [(-b - sd)/(2*a), (-b + sd)/(2*a)]:\n            if t >= 0:\n                x, y, z = ox + t*dx, oy + t*dy, oz + t*dz\n                if x + y <= 1:\n                    ts.append(t)\n    # Plane intersection (x+y=1) with disc\n    denom = dx + dy\n    if abs(denom) > 1e-6:\n        t = (1 - (ox + oy)) / denom\n        if t >= 0:\n            x, y, z = ox + t*dx, oy + t*dy, oz + t*dz\n            if x*x + y*y + z*z <= 1:\n                ts.append(t)\n    return min(ts) if ts else -1.0",
        "def intersect_cut_sphere(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    A = Dx*Dx + Dy*Dy + Dz*Dz\n    B = 2*(Ox*Dx + Oy*Dy + Oz*Dz)\n    C = Ox*Ox + Oy*Oy + Oz*Oz - 1\n    disc = B*B - 4*A*C\n    ts = []\n    eps = 1e-6\n    if disc >= 0:\n        sqrt_disc = disc**0.5\n        for t in [(-B - sqrt_disc)/(2*A), (-B + sqrt_disc)/(2*A)]:\n            if t > eps:\n                Px = Ox + t*Dx\n                Py = Oy + t*Dy\n                if Px + Py <= 1:\n                    ts.append(t)\n    denom = Dx + Dy\n    if abs(denom) > eps:\n        t_plane = (1 - (Ox + Oy)) / denom\n        if t_plane > eps:\n            Px = Ox + t_plane*Dx\n            Py = Oy + t_plane*Dy\n            Pz = Oz + t_plane*Dz\n            if Px*Px + Py*Py + Pz*Pz <= 1:\n                ts.append(t_plane)\n    return min(ts) if ts else -1",
        "```python\ndef intersect(O, D):\n    import math\n    ox, oy, oz = O\n    dx, dy, dz = D\n    # Sphere intersection\n    a = dx*dx + dy*dy + dz*dz\n    b = 2*(ox*dx + oy*dy + oz*dz)\n    c = ox*ox + oy*oy + oz*oz - 1\n    disc = b*b - 4*a*c\n    ts = []\n    if disc >= 0:\n        sd = math.sqrt(disc)\n        for t in [(-b - sd) / (2*a), (-b + sd) / (2*a)]:\n            if t > 0:\n                px, py = ox + t*dx, oy + t*dy\n                if px + py <= 1:\n                    ts.append(t)\n    # Plane intersection (x + y = 1)\n    denom = dx + dy\n    if abs(denom) > 1e-6:\n        t_p = (1 - ox - oy) / denom\n        if t_p > 0:\n            px, py, pz = ox + t_p*dx, oy + t_p*dy, oz + t_p*dz\n            if px*px + py*py + pz*pz <= 1:\n                ts.append(t_p)\n    return min(ts) if ts else -1.0\n```",
        "```python\ndef intersect_cut_sphere(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    eps = 1e-6\n    # Sphere intersection (centered at origin, radius=1)\n    a = Dx*Dx + Dy*Dy + Dz*Dz\n    b = 2*(Ox*Dx + Oy*Dy + Oz*Dz)\n    c = Ox*Ox + Oy*Oy + Oz*Oz - 1\n    disc = b*b - 4*a*c\n    ts = []\n    if disc >= 0:\n        sqrt_disc = disc**0.5\n        t0 = (-b - sqrt_disc) / (2*a)\n        t1 = (-b + sqrt_disc) / (2*a)\n        for t in (t0, t1):\n            if t > eps:\n                x, y = Ox + t*Dx, Oy + t*Dy\n                if x + y <= 1 + eps:\n                    ts.append(t)\n    # Plane intersection (x + y = 1) disk check\n    denom = Dx + Dy\n    if abs(denom) > eps:\n        t_plane = (1 - (Ox + Oy)) / denom\n        if t_plane > eps:\n            x, y, z = Ox + t_plane*Dx, Oy + t_plane*Dy, Oz + t_plane*Dz\n            if x*x + y*y + z*z <= 1 + eps:\n                ts.append(t_plane)\n    if not ts:\n        return -1.0\n    return min(ts)\n```",
        "def intersect_cut_sphere(O, D):\n    from math import sqrt\n    eps = 1e-6\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    ts = []\n    # plane intersection (cut disc)\n    denom = Dx + Dy\n    if abs(denom) > eps:\n        t_plane = (1 - (Ox + Oy)) / denom\n        if t_plane > eps:\n            Px = Ox + t_plane * Dx; Py = Oy + t_plane * Dy; Pz = Oz + t_plane * Dz\n            vx = Px - 0.5; vy = Py - 0.5; vz = Pz\n            if vx*vx + vy*vy + vz*vz <= 0.5 + eps:\n                # outward normal is (1,1,0)\n                if Dx + Dy < 0:\n                    ts.append(t_plane)\n    # sphere intersection\n    a = Dx*Dx + Dy*Dy + Dz*Dz\n    b = 2 * (Ox*Dx + Oy*Dy + Oz*Dz)\n    c = Ox*Ox + Oy*Oy + Oz*Oz - 1\n    disc = b*b - 4*a*c\n    if disc >= 0:\n        sqrt_disc = sqrt(disc)\n        inv2a = 1 / (2*a)\n        for t in ((-b - sqrt_disc) * inv2a, (-b + sqrt_disc) * inv2a):\n            if t > eps:\n                Px = Ox + t*Dx; Py = Oy + t*Dy; Pz = Oz + t*Dz\n                if Px + Py <= 1 + eps:\n                    # sphere normal = P (radius=1)\n                    if Dx*Px + Dy*Py + Dz*Pz < 0:\n                        ts.append(t)\n                        break\n    return min(ts) if ts else -1.0"
    ],
    [
        "def intersect(O, D):\n    from math import sqrt\n    def dot(a, b): return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]\n    def sub(a, b): return (a[0]-b[0], a[1]-b[1], a[2]-b[2])\n    def sphere_hits(O, D, C, r):\n        OC = sub(O, C)\n        a = dot(D, D)\n        b = 2 * dot(D, OC)\n        c = dot(OC, OC) - r*r\n        disc = b*b - 4*a*c\n        if disc < 0: return None\n        s = sqrt(disc)\n        t0 = (-b - s) / (2*a)\n        t1 = (-b + s) / (2*a)\n        if t0 > t1: t0, t1 = t1, t0\n        return t0, t1\n    h1 = sphere_hits(O, D, (0.0,0.0,0.0), 1.0)\n    if h1 is None: return -1\n    t01, t11 = h1\n    h2 = sphere_hits(O, D, (0.5,0.5,0.0), 1.0)\n    intervals = []\n    if h2 is None:\n        intervals.append((t01, t11))\n    else:\n        t02, t12 = h2\n        a, b = t01, t11\n        c, d = t02, t12\n        if c > b or d < a:\n            intervals.append((a, b))\n        else:\n            if a < c: intervals.append((a, min(b, c)))\n            if d < b: intervals.append((max(a, d), b))\n    t_hit = None\n    for start, end in intervals:\n        if end < 0: continue\n        t = start if start >= 0 else end\n        if t_hit is None or t < t_hit: t_hit = t\n    return t_hit if t_hit is not None else -1",
        "def intersect_sphere_hole(O, D):\n    import math\n    def dot(u, v): return u[0]*v[0] + u[1]*v[1] + u[2]*v[2]\n    a = dot(D, D)\n    oc = O\n    b = 2 * dot(oc, D)\n    c = dot(oc, oc) - 1.0\n    disc = b*b - 4*a*c\n    if disc < 0: return -1.0\n    sqrt_disc = math.sqrt(disc)\n    t1 = (-b - sqrt_disc) / (2*a)\n    t2 = (-b + sqrt_disc) / (2*a)\n    t_min, t_max = min(t1, t2), max(t1, t2)\n    oc2 = (O[0]-0.5, O[1]-0.5, O[2])\n    b2 = 2 * dot(oc2, D)\n    c2 = dot(oc2, oc2) - 1.0\n    disc2 = b2*b2 - 4*a*c2\n    segments = []\n    if disc2 < 0:\n        segments.append((t_min, t_max))\n    else:\n        sqrt_disc2 = math.sqrt(disc2)\n        u1 = (-b2 - sqrt_disc2) / (2*a)\n        u2 = (-b2 + sqrt_disc2) / (2*a)\n        u_min, u_max = min(u1, u2), max(u1, u2)\n        if u_max <= t_min or u_min >= t_max:\n            segments.append((t_min, t_max))\n        else:\n            if u_min > t_min:\n                segments.append((t_min, min(u_min, t_max)))\n            if u_max < t_max:\n                segments.append((max(u_max, t_min), t_max))\n    t_hit = None\n    for s, e in segments:\n        if e < 0: continue\n        t_candidate = s if s > 0 else e\n        if t_candidate <= 0: continue\n        if t_hit is None or t_candidate < t_hit:\n            t_hit = t_candidate\n    return t_hit if t_hit is not None else -1.0",
        "def intersect_sphere_hole(O, D):\n    import math\n    def dot(u, v): return u[0]*v[0] + u[1]*v[1] + u[2]*v[2]\n    def sub(u, v): return (u[0]-v[0], u[1]-v[1], u[2]-v[2])\n    # Sphere0: center (0,0,0), r=1\n    a = dot(D, D)\n    b = 2 * dot(O, D)\n    c = dot(O, O) - 1\n    disc = b*b - 4*a*c\n    if disc < 0: return -1.0\n    sd = math.sqrt(disc)\n    t0a = (-b - sd) / (2*a)\n    t0b = (-b + sd) / (2*a)\n    t0_near, t0_far = (t0a, t0b) if t0a < t0b else (t0b, t0a)\n    if t0_far < 0: return -1.0\n    # Sphere1 (hole): center (0.5,0.5,0), r=1\n    C1 = (0.5, 0.5, 0.0)\n    OC1 = sub(O, C1)\n    b1 = 2 * dot(OC1, D)\n    c1 = dot(OC1, OC1) - 1\n    disc1 = b1*b1 - 4*a*c1\n    intervals = []\n    if disc1 < 0:\n        intervals = [(t0_near, t0_far)]\n    else:\n        sd1 = math.sqrt(disc1)\n        t1a = (-b1 - sd1) / (2*a)\n        t1b = (-b1 + sd1) / (2*a)\n        t1_near, t1_far = (t1a, t1b) if t1a < t1b else (t1b, t1a)\n        if t1_near > t0_near:\n            intervals.append((t0_near, min(t1_near, t0_far)))\n        if t1_far < t0_far:\n            intervals.append((max(t1_far, t0_near), t0_far))\n    t_hit = None\n    for u, v in intervals:\n        if v < 0: continue\n        t = max(u, 0.0)\n        if t <= v and (t_hit is None or t < t_hit):\n            t_hit = t\n    return t_hit if t_hit is not None else -1.0",
        "```python\ndef intersect(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    def solve(Cx, Cy, Cz, r):\n        rx, ry, rz = Ox - Cx, Oy - Cy, Oz - Cz\n        a = Dx*Dx + Dy*Dy + Dz*Dz\n        b = 2*(Dx*rx + Dy*ry + Dz*rz)\n        c = rx*rx + ry*ry + rz*rz - r*r\n        disc = b*b - 4*a*c\n        if disc < 0:\n            return ()\n        sd = disc**0.5\n        t1 = (-b - sd) / (2*a)\n        t2 = (-b + sd) / (2*a)\n        return (t1, t2) if t1 <= t2 else (t2, t1)\n\n    # Primary sphere (center=(0,0,0), r=1)\n    I1 = solve(0.0, 0.0, 0.0, 1.0)\n    if not I1:\n        return -1.0\n    t1, t2 = I1\n    if t2 < 0.0:\n        return -1.0\n    a = t1 if t1 > 0.0 else 0.0\n    b = t2\n\n    # Subtracting sphere (center=(0.5,0.5,0), r=1)\n    I2 = solve(0.5, 0.5, 0.0, 1.0)\n    if not I2:\n        return a\n    u1, u2 = I2\n    if u2 < 0.0:\n        return a\n    c = u1 if u1 > 0.0 else 0.0\n    d = u2\n\n    # Compute set difference of intervals [a,b] \\ [c,d]\n    if b <= c or a >= d:\n        return a\n    if a < c:\n        return a\n    if d <= b:\n        return d\n    return -1.0\n```",
        "def intersect(O, D):\n    import math\n    ox, oy, oz = O\n    dx, dy, dz = D\n    a = dx*dx + dy*dy + dz*dz\n    b = 2 * (dx*ox + dy*oy + dz*oz)\n    c = ox*ox + oy*oy + oz*oz - 1\n    disc = b*b - 4*a*c\n    if disc < 0:\n        return -1.0\n    sqrt_disc = math.sqrt(disc)\n    t1 = (-b - sqrt_disc) / (2*a)\n    t2 = (-b + sqrt_disc) / (2*a)\n    # sphere hole\n    ox2, oy2, oz2 = ox - 0.5, oy - 0.5, oz\n    b2 = 2 * (dx*ox2 + dy*oy2 + dz*oz2)\n    c2 = ox2*ox2 + oy2*oy2 + oz2*oz2 - 1\n    disc2 = b2*b2 - 4*a*c2\n    hole = False\n    if disc2 >= 0:\n        sqrt2 = math.sqrt(disc2)\n        u1 = (-b2 - sqrt2) / (2*a)\n        u2 = (-b2 + sqrt2) / (2*a)\n        if u1 > u2:\n            u1, u2 = u2, u1\n        hole = True\n    if t1 > t2:\n        t1, t2 = t2, t1\n    for t in (t1, t2):\n        if t >= 0 and (not hole or t < u1 or t > u2):\n            return t\n    return -1.0",
        "def intersect_sphere_hole(O, D):\n    import math\n    def intersect_sphere(O, D, C, r):\n        px, py, pz = O[0]-C[0], O[1]-C[1], O[2]-C[2]\n        a = D[0]*D[0] + D[1]*D[1] + D[2]*D[2]\n        b = 2*(D[0]*px + D[1]*py + D[2]*pz)\n        c = px*px + py*py + pz*pz - r*r\n        disc = b*b - 4*a*c\n        if disc < 0: return None\n        s = math.sqrt(disc)\n        t0 = (-b - s) / (2*a)\n        t1 = (-b + s) / (2*a)\n        if t0 > t1: t0, t1 = t1, t0\n        return (t0, t1)\n    s1 = intersect_sphere(O, D, (0.0, 0.0, 0.0), 1.0)\n    if s1 is None or s1[1] < 0: return -1.0\n    t1_0, t1_1 = max(s1[0], 0.0), s1[1]\n    s2 = intersect_sphere(O, D, (0.5, 0.5, 0.0), 1.0)\n    if s2 is None or s2[1] < 0: return t1_0\n    t2_0, t2_1 = max(s2[0], 0.0), s2[1]\n    if t1_1 <= t2_0 or t1_0 >= t2_1: return t1_0\n    if t1_0 < t2_0: return t1_0\n    return t2_1 if t2_1 <= t1_1 else -1.0",
        "def intersect_sphere_with_hole(O, D):\n    import math\n    ox, oy, oz = O\n    dx, dy, dz = D\n    a = dx*dx + dy*dy + dz*dz\n    b = 2*(ox*dx + oy*dy + oz*dz)\n    c = ox*ox + oy*oy + oz*oz - 1.0\n    disc = b*b - 4*a*c\n    if disc < 0:\n        return -1.0\n    sqrt_disc = math.sqrt(disc)\n    t1 = (-b - sqrt_disc) / (2*a)\n    t2 = (-b + sqrt_disc) / (2*a)\n    t_near1, t_far1 = (t1, t2) if t1 <= t2 else (t2, t1)\n    if t_far1 < 0:\n        return -1.0\n    # Sphere 2 (hole) centered at (0.5,0.5,0)\n    ox2, oy2, oz2 = ox - 0.5, oy - 0.5, oz\n    b2 = 2*(ox2*dx + oy2*dy + oz2*dz)\n    c2 = ox2*ox2 + oy2*oy2 + oz2*oz2 - 1.0\n    disc2 = b2*b2 - 4*a*c2\n    if disc2 < 0:\n        return t_near1 if t_near1 >= 0 else (t_far1 if t_far1 >= 0 else -1.0)\n    sqrt_disc2 = math.sqrt(disc2)\n    s1 = (-b2 - sqrt_disc2) / (2*a)\n    s2 = (-b2 + sqrt_disc2) / (2*a)\n    t_near2, t_far2 = (s1, s2) if s1 <= s2 else (s2, s1)\n    # No overlap between sphere1 interval and hole interval\n    if t_far2 <= t_near1 or t_near2 >= t_far1:\n        return t_near1 if t_near1 >= 0 else (t_far1 if t_far1 >= 0 else -1.0)\n    # Compute valid segments = [t_near1, t_far1] \\ [t_near2, t_far2]\n    candidates = []\n    # Left segment\n    left_start, left_end = t_near1, min(t_far1, t_near2)\n    if left_end >= left_start and left_end >= 0:\n        candidates.append(max(left_start, 0.0))\n    # Right segment\n    right_start, right_end = max(t_near1, t_far2), t_far1\n    if right_end >= right_start and right_end >= 0:\n        candidates.append(max(right_start, 0.0))\n    return min(candidates) if candidates else -1.0",
        "def intersect_sphere_with_hole(O, D):\n    import math\n    def dot(u, v):\n        return u[0]*v[0] + u[1]*v[1] + u[2]*v[2]\n    def sub(u, v):\n        return (u[0]-v[0], u[1]-v[1], u[2]-v[2])\n    def intersect_sphere(C, r):\n        OC = sub(O, C)\n        A = dot(D, D)\n        B = 2 * dot(D, OC)\n        Cc = dot(OC, OC) - r*r\n        disc = B*B - 4*A*Cc\n        if disc < 0:\n            return None\n        s = math.sqrt(disc)\n        t0 = (-B - s) / (2*A)\n        t1 = (-B + s) / (2*A)\n        return (t0, t1) if t0 <= t1 else (t1, t0)\n    s1 = intersect_sphere((0.0,0.0,0.0), 1.0)\n    if s1 is None:\n        return -1.0\n    a, b = s1\n    s2 = intersect_sphere((0.5,0.5,0.0), 1.0)\n    if s2 is None:\n        return a if a >= 0 else -1.0\n    c, d = s2\n    o_start, o_end = max(a, c), min(b, d)\n    if o_start >= o_end:\n        return a if a >= 0 else -1.0\n    if o_start <= a and o_end >= b:\n        return -1.0\n    t = o_end if o_start <= a else a\n    return t if t >= 0 else -1.0",
        "def ray_sphere_hole_intersection(O, D):\n    def intersect_sphere(O, D, C, r):\n        ox, oy, oz = O; dx, dy, dz = D; cx, cy, cz = C\n        Lx, Ly, Lz = ox - cx, oy - cy, oz - cz\n        a = dx*dx + dy*dy + dz*dz\n        b = 2*(dx*Lx + dy*Ly + dz*Lz)\n        c = Lx*Lx + Ly*Ly + Lz*Lz - r*r\n        disc = b*b - 4*a*c\n        if disc < 0: return ()\n        sqrt_disc = disc**0.5\n        t1 = (-b - sqrt_disc)/(2*a)\n        t2 = (-b + sqrt_disc)/(2*a)\n        if abs(disc) < 1e-9: return (t1,)\n        if t1 < t2: return (t1, t2)\n        return (t2, t1)\n    C1, r1 = (0.0, 0.0, 0.0), 1.0\n    C2, r2 = (0.5, 0.5, 0.0), 1.0\n    eps = 1e-6\n    candidates = []\n    for t in intersect_sphere(O, D, C1, r1):\n        if t < 0: continue\n        px, py, pz = O[0]+t*D[0], O[1]+t*D[1], O[2]+t*D[2]\n        dx2, dy2, dz2 = px-C2[0], py-C2[1], pz-C2[2]\n        if dx2*dx2 + dy2*dy2 + dz2*dz2 >= r2*r2 - eps:\n            candidates.append(t)\n    for t in intersect_sphere(O, D, C2, r2):\n        if t < 0: continue\n        px, py, pz = O[0]+t*D[0], O[1]+t*D[1], O[2]+t*D[2]\n        dx1, dy1, dz1 = px-C1[0], py-C1[1], pz-C1[2]\n        if dx1*dx1 + dy1*dy1 + dz1*dz1 <= r1*r1 + eps:\n            candidates.append(t)\n    return min(candidates) if candidates else -1.0",
        "```python\ndef ray_sphere_hole_intersection(O, D):\n    from math import sqrt\n    eps = 1e-6\n    def dot(u, v): return u[0]*v[0] + u[1]*v[1] + u[2]*v[2]\n    def sub(u, v): return (u[0]-v[0], u[1]-v[1], u[2]-v[2])\n    def add(u, v): return (u[0]+v[0], u[1]+v[1], u[2]+v[2])\n    def mul(u, s): return (u[0]*s, u[1]*s, u[2]*s)\n    def sphere_intersect(C):\n        OC = sub(O, C)\n        a = dot(D, D)\n        b = 2 * dot(D, OC)\n        c = dot(OC, OC) - 1.0\n        disc = b*b - 4*a*c\n        if disc < 0: return []\n        if abs(disc) < eps: return [-b / (2*a)]\n        sd = sqrt(disc)\n        return [(-b - sd) / (2*a), (-b + sd) / (2*a)]\n    ts = sphere_intersect((0.0, 0.0, 0.0)) + sphere_intersect((0.5, 0.5, 0.0))\n    ts.sort()\n    prev = None\n    for t in ts:\n        if t < 0: continue\n        if prev is not None and abs(t - prev) < eps: continue\n        prev = t\n        P = add(O, mul(D, t))\n        d1 = sqrt(dot(P, P))\n        v2 = sub(P, (0.5, 0.5, 0.0))\n        d2 = sqrt(dot(v2, v2))\n        if abs(d1 - 1.0) < eps and d2 > 1.0 - eps: return t\n        if abs(d2 - 1.0) < eps and d1 < 1.0 + eps: return t\n    return -1.0\n```"
    ],
    [
        "def intersect(O, D):\n    import math\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    hits = []\n    # Sphere intersection\n    a = Dx*Dx + Dy*Dy + Dz*Dz\n    b = 2*(Ox*Dx + Oy*Dy + Oz*Dz)\n    c = Ox*Ox + Oy*Oy + Oz*Oz - 1\n    disc = b*b - 4*a*c\n    if disc >= 0:\n        sd = math.sqrt(disc)\n        for t in [(-b - sd)/(2*a), (-b + sd)/(2*a)]:\n            if t >= 0:\n                y = Oy + t*Dy\n                z = Oz + t*Dz\n                if y*y + z*z >= 0.49:\n                    hits.append(t)\n    # Cylinder intersection (axis along x)\n    ac = Dy*Dy + Dz*Dz\n    if ac != 0:\n        bc = 2*(Oy*Dy + Oz*Dz)\n        cc = Oy*Oy + Oz*Oz - 0.49\n        disc_c = bc*bc - 4*ac*cc\n        if disc_c >= 0:\n            sc = math.sqrt(disc_c)\n            for t in [(-bc - sc)/(2*ac), (-bc + sc)/(2*ac)]:\n                if t >= 0:\n                    x = Ox + t*Dx\n                    y = Oy + t*Dy\n                    z = Oz + t*Dz\n                    if x*x + y*y + z*z <= 1:\n                        hits.append(t)\n    return min(hits) if hits else -1.0",
        "def intersect_sphere_cylinder(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    # Sphere intersection\n    a = Dx*Dx + Dy*Dy + Dz*Dz\n    b = 2*(Ox*Dx + Oy*Dy + Oz*Dz)\n    c = Ox*Ox + Oy*Oy + Oz*Oz - 1.0\n    disc = b*b - 4*a*c\n    if disc < 0: return -1.0\n    sd = disc**0.5\n    t0 = (-b - sd)/(2*a)\n    t1 = (-b + sd)/(2*a)\n    if t0 > t1: t0, t1 = t1, t0\n    # Cylinder intersection (along x-axis)\n    rc2 = 0.7*0.7\n    ac = Dy*Dy + Dz*Dz\n    bc = 2*(Oy*Dy + Oz*Dz)\n    cc = Oy*Oy + Oz*Oz - rc2\n    if ac == 0:\n        if cc < 0: return -1.0\n        return t0 if t0 > 0 else (t1 if t1 > 0 else -1.0)\n    disc_c = bc*bc - 4*ac*cc\n    if disc_c <= 0:\n        if cc <= 0: return -1.0\n        return t0 if t0 > 0 else (t1 if t1 > 0 else -1.0)\n    sc = disc_c**0.5\n    c0 = (-bc - sc)/(2*ac)\n    c1 = (-bc + sc)/(2*ac)\n    if c0 > c1: c0, c1 = c1, c0\n    # Determine intersections with sphere minus cylinder\n    ts = []\n    # before cylinder hole\n    if t0 < c0:\n        t_end = min(t1, c0)\n        if t_end > t0:\n            if t0 > 0: ts.append(t0)\n            elif t_end > 0: ts.append(t_end)\n    # after cylinder hole\n    if t1 > c1:\n        t_start = max(t0, c1)\n        if t1 > t_start:\n            if t_start > 0: ts.append(t_start)\n            elif t1 > 0: ts.append(t1)\n    return min(ts) if ts else -1.0",
        "def intersect(O, D):\n    import math\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    # Sphere intersection (radius 1 at origin)\n    a = Dx*Dx + Dy*Dy + Dz*Dz\n    b = 2*(Ox*Dx + Oy*Dy + Oz*Dz)\n    c = Ox*Ox + Oy*Oy + Oz*Oz - 1.0\n    disc = b*b - 4*a*c\n    events = []\n    if disc >= 0.0:\n        sd = math.sqrt(disc)\n        t0 = (-b - sd) / (2*a)\n        t1 = (-b + sd) / (2*a)\n        events.append((t0, \"sphere\"))\n        events.append((t1, \"sphere\"))\n    # Cylinder intersection (axis along x, radius 0.7)\n    rr = 0.7*0.7\n    a2 = Dy*Dy + Dz*Dz\n    if a2 != 0.0:\n        b2 = 2*(Oy*Dy + Oz*Dz)\n        c2 = Oy*Oy + Oz*Oz - rr\n        disc2 = b2*b2 - 4*a2*c2\n        if disc2 >= 0.0:\n            sd2 = math.sqrt(disc2)\n            tc0 = (-b2 - sd2) / (2*a2)\n            tc1 = (-b2 + sd2) / (2*a2)\n            events.append((tc0, \"cylinder\"))\n            events.append((tc1, \"cylinder\"))\n    # Filter and sort events\n    events = [(t, typ) for t, typ in events if t >= 0.0]\n    events.sort(key=lambda e: e[0])\n    # Test each event for actual boundary intersection\n    for t, typ in events:\n        x = Ox + Dx*t\n        y = Oy + Dy*t\n        z = Oz + Dz*t\n        if typ == \"sphere\":\n            # sphere surface outside hole\n            if y*y + z*z > rr:\n                return t\n        else:\n            # cylinder surface inside sphere\n            if x*x + y*y + z*z < 1.0:\n                return t\n    return -1.0",
        "```python\ndef intersect(O, D):\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    candidates = []\n    # Sphere intersection (radius=1)\n    A = Dx*Dx + Dy*Dy + Dz*Dz\n    B = 2*(Ox*Dx + Oy*Dy + Oz*Dz)\n    C = Ox*Ox + Oy*Oy + Oz*Oz - 1.0\n    disc = B*B - 4*A*C\n    if A != 0 and disc >= 0:\n        sqrt_disc = disc**0.5\n        for t in ((-B - sqrt_disc)/(2*A), (-B + sqrt_disc)/(2*A)):\n            if t >= 0:\n                y = Oy + t*Dy\n                z = Oz + t*Dz\n                if y*y + z*z >= 0.49:\n                    candidates.append(t)\n    # Cylinder intersection (radius=0.7 along x-axis)\n    a = Dy*Dy + Dz*Dz\n    if a != 0:\n        b = 2*(Oy*Dy + Oz*Dz)\n        c = Oy*Oy + Oz*Oz - 0.49\n        disc_c = b*b - 4*a*c\n        if disc_c >= 0:\n            sqrt_c = disc_c**0.5\n            for t in ((-b - sqrt_c)/(2*a), (-b + sqrt_c)/(2*a)):\n                if t >= 0:\n                    x = Ox + t*Dx\n                    y = Oy + t*Dy\n                    z = Oz + t*Dz\n                    if x*x + y*y + z*z <= 1.0:\n                        candidates.append(t)\n    return min(candidates) if candidates else -1.0\n```",
        "```python\ndef intersect_ray_sphere_with_cylinder_hole(O, D):\n    import math\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    t_min = float('inf')\n    # Sphere intersection\n    a = Dx*Dx + Dy*Dy + Dz*Dz\n    b = 2*(Ox*Dx + Oy*Dy + Oz*Dz)\n    c = Ox*Ox + Oy*Oy + Oz*Oz - 1\n    disc = b*b - 4*a*c\n    if disc >= 0:\n        sqrt_disc = math.sqrt(disc)\n        ts = [(-b - sqrt_disc) / (2*a), (-b + sqrt_disc) / (2*a)]\n        for t in sorted(ts):\n            if t >= 0:\n                y = Oy + t*Dy\n                z = Oz + t*Dz\n                if y*y + z*z >= 0.49:\n                    t_min = t\n                    break\n    # Cylinder intersection (along x-axis, radius 0.7)\n    a_c = Dy*Dy + Dz*Dz\n    if a_c != 0:\n        b_c = 2*(Oy*Dy + Oz*Dz)\n        c_c = Oy*Oy + Oz*Oz - 0.49\n        disc_c = b_c*b_c - 4*a_c*c_c\n        if disc_c >= 0:\n            sqrt_disc_c = math.sqrt(disc_c)\n            ts_c = [(-b_c - sqrt_disc_c) / (2*a_c), (-b_c + sqrt_disc_c) / (2*a_c)]\n            for t in sorted(ts_c):\n                if t >= 0:\n                    x = Ox + t*Dx\n                    y = Oy + t*Dy\n                    z = Oz + t*Dz\n                    if x*x + y*y + z*z <= 1:\n                        t_min = min(t_min, t)\n                        break\n    return t_min if t_min != float('inf') else -1\n```",
        "def intersect(O, D):\n    from math import sqrt\n    eps = 1e-6\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    def is_inside(px, py, pz):\n        return px*px + py*py + pz*pz <= 1 and py*py + pz*pz >= 0.49\n    candidates = []\n    # Sphere intersection\n    A = Dx*Dx + Dy*Dy + Dz*Dz\n    B = 2 * (Ox*Dx + Oy*Dy + Oz*Dz)\n    C = Ox*Ox + Oy*Oy + Oz*Oz - 1\n    disc = B*B - 4*A*C\n    if disc >= 0:\n        sd = sqrt(disc)\n        for t in sorted([(-B - sd)/(2*A), (-B + sd)/(2*A)]):\n            if t > eps:\n                y = Oy + t*Dy\n                z = Oz + t*Dz\n                if y*y + z*z >= 0.49:\n                    candidates.append(t)\n    # Cylinder intersection\n    A = Dy*Dy + Dz*Dz\n    B = 2 * (Oy*Dy + Oz*Dz)\n    C = Oy*Oy + Oz*Oz - 0.49\n    disc = B*B - 4*A*C\n    if A != 0 and disc >= 0:\n        sd = sqrt(disc)\n        for t in sorted([(-B - sd)/(2*A), (-B + sd)/(2*A)]):\n            if t > eps:\n                x = Ox + t*Dx\n                y = Oy + t*Dy\n                z = Oz + t*Dz\n                if x*x + y*y + z*z <= 1:\n                    candidates.append(t)\n    if not candidates:\n        return -1.0\n    candidates.sort()\n    for t in candidates:\n        px, py, pz = Ox + t*Dx, Oy + t*Dy, Oz + t*Dz\n        p0x, p0y, p0z = Ox + (t-eps)*Dx, Oy + (t-eps)*Dy, Oz + (t-eps)*Dz\n        if not is_inside(p0x, p0y, p0z) and is_inside(px, py, pz):\n            return t\n    return -1.0",
        "```python\ndef intersect_sphere_cylinder_hole(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    best_t = float('inf')\n    # Sphere intersection (radius=1)\n    a_s = dx*dx + dy*dy + dz*dz\n    b_s = 2*(ox*dx + oy*dy + oz*dz)\n    c_s = ox*ox + oy*oy + oz*oz - 1.0\n    disc_s = b_s*b_s - 4*a_s*c_s\n    if disc_s >= 0:\n        sqrt_s = disc_s**0.5\n        for t in sorted([(-b_s - sqrt_s)/(2*a_s), (-b_s + sqrt_s)/(2*a_s)]):\n            if t > 0:\n                px, py, pz = ox + t*dx, oy + t*dy, oz + t*dz\n                if py*py + pz*pz >= 0.7*0.7:\n                    best_t = t\n                    break\n    # Cylinder intersection (axis=x, radius=0.7)\n    a_c = dy*dy + dz*dz\n    if a_c > 1e-8:\n        b_c = 2*(oy*dy + oz*dz)\n        c_c = oy*oy + oz*oz - 0.7*0.7\n        disc_c = b_c*b_c - 4*a_c*c_c\n        if disc_c >= 0:\n            sqrt_c = disc_c**0.5\n            for t in sorted([(-b_c - sqrt_c)/(2*a_c), (-b_c + sqrt_c)/(2*a_c)]):\n                if 0 < t < best_t:\n                    px, py, pz = ox + t*dx, oy + t*dy, oz + t*dz\n                    if px*px + py*py + pz*pz <= 1.0:\n                        best_t = t\n                        break\n    return best_t if best_t < float('inf') else -1.0\n```",
        "def intersect_sphere_cylinder_hole(O, D):\n    import math\n    ox, oy, oz = O\n    dx, dy, dz = D\n    eps = 1e-6\n    ts = []\n    # Sphere intersection\n    a = dx*dx + dy*dy + dz*dz\n    b = 2*(ox*dx + oy*dy + oz*dz)\n    c = ox*ox + oy*oy + oz*oz - 1.0\n    disc = b*b - 4*a*c\n    if disc >= 0:\n        sd = math.sqrt(disc)\n        for t in [(-b - sd)/(2*a), (-b + sd)/(2*a)]:\n            if t > eps:\n                y = oy + dy*t; z = oz + dz*t\n                if y*y + z*z >= 0.49 - eps:\n                    ts.append(t)\n    # Cylinder intersection\n    a_c = dy*dy + dz*dz\n    if a_c > eps:\n        b_c = 2*(oy*dy + oz*dz)\n        c_c = oy*oy + oz*oz - 0.49\n        disc_c = b_c*b_c - 4*a_c*c_c\n        if disc_c >= 0:\n            sd_c = math.sqrt(disc_c)\n            for t in [(-b_c - sd_c)/(2*a_c), (-b_c + sd_c)/(2*a_c)]:\n                if t > eps:\n                    x = ox + dx*t; y = oy + dy*t; z = oz + dz*t\n                    if x*x + y*y + z*z <= 1.0 + eps:\n                        ts.append(t)\n    return min(ts) if ts else -1.0",
        "```python\ndef intersect_sphere_cyl_hole(O, D):\n    import math\n    eps = 1e-6\n    Ox, Oy, Oz = O\n    Dx, Dy, Dz = D\n    ts = []\n    # Sphere intersection\n    a = Dx*Dx + Dy*Dy + Dz*Dz\n    b = 2*(Ox*Dx + Oy*Dy + Oz*Dz)\n    c = Ox*Ox + Oy*Oy + Oz*Oz - 1\n    disc = b*b - 4*a*c\n    if disc >= 0:\n        sd = math.sqrt(disc)\n        t1 = (-b - sd) / (2*a)\n        t2 = (-b + sd) / (2*a)\n        for t in sorted((t1, t2)):\n            if t >= eps:\n                py = Oy + Dy*t\n                pz = Oz + Dz*t\n                if py*py + pz*pz >= 0.49 - eps:\n                    ts.append(t)\n                    break\n    # Cylinder intersection\n    a_c = Dy*Dy + Dz*Dz\n    b_c = 2*(Oy*Dy + Oz*Dz)\n    c_c = Oy*Oy + Oz*Oz - 0.49\n    disc_c = b_c*b_c - 4*a_c*c_c\n    if a_c > eps and disc_c >= 0:\n        sd_c = math.sqrt(disc_c)\n        tc1 = (-b_c - sd_c) / (2*a_c)\n        tc2 = (-b_c + sd_c) / (2*a_c)\n        for t in sorted((tc1, tc2)):\n            if t >= eps:\n                px = Ox + Dx*t\n                py = Oy + Dy*t\n                pz = Oz + Dz*t\n                if px*px + py*py + pz*pz <= 1 + eps:\n                    ts.append(t)\n                    break\n    return min(ts) if ts else -1\n```",
        "def intersect_sphere_with_cylinder_hole(O, D):\n    ox, oy, oz = O\n    dx, dy, dz = D\n    eps = 1e-6\n    ts = []\n    # Sphere intersection\n    a = dx*dx + dy*dy + dz*dz\n    b = 2*(ox*dx + oy*dy + oz*dz)\n    c = ox*ox + oy*oy + oz*oz - 1\n    disc = b*b - 4*a*c\n    if disc >= 0:\n        sqrt_disc = disc**0.5\n        t1 = (-b - sqrt_disc)/(2*a)\n        t2 = (-b + sqrt_disc)/(2*a)\n        for t in sorted((t1, t2)):\n            if t >= eps:\n                py = oy + t*dy\n                pz = oz + t*dz\n                if py*py + pz*pz >= 0.7*0.7 - eps:\n                    ts.append(t)\n                    break\n    # Cylinder intersection (infinite along x)\n    A = dy*dy + dz*dz\n    if A > eps:\n        B = 2*(oy*dy + oz*dz)\n        C = oy*oy + oz*oz - 0.7*0.7\n        disc_c = B*B - 4*A*C\n        if disc_c >= 0:\n            sqrt_dc = disc_c**0.5\n            tc1 = (-B - sqrt_dc)/(2*A)\n            tc2 = (-B + sqrt_dc)/(2*A)\n            for t in sorted((tc1, tc2)):\n                if t >= eps:\n                    px = ox + t*dx\n                    py = oy + t*dy\n                    pz = oz + t*dz\n                    if px*px + py*py + pz*pz <= 1 + eps:\n                        ts.append(t)\n                        break\n    if not ts:\n        return -1.0\n    return min(ts)"
    ]
]
############### 0.0 ###############
Ray­-Sphere Intersection (Programming Exercise)

Background  
In ray tracing, checking whether a ray hits a sphere is one of the simplest – yet most fundamental – object‐intersection tests.  Algebraically, you solve  
  ‖O + tD – C‖² = r²  
for t, where  
• O = ray origin  
• D = normalized ray direction  
• C = sphere center  
• r = sphere radius  

Your task is to implement this test, find the nearest positive intersection t (if any), and compute the hit point and surface normal.

Problem Statement  
Write a function in C++ (or pseudocode with comparable detail) with signature

bool intersectSphere(  
 const Ray&    ray,      // ray.origin = O, ray.dir = D (normalized)  
 const Sphere& sph,      // sph.center = C, sph.radius = r  
 float         t_min,    // minimum valid t (e.g. 0.001f to avoid self‐intersection)  
 float         t_max,    // maximum valid t (e.g. +∞)  
 HitRecord&    rec       // out‐parameter: stores t, hit point, normal  
);

where  

struct Ray {  
 Vec3 origin;   // O  
 Vec3 dir;      // D (assume ‖D‖ = 1)  
};  

struct Sphere {  
 Vec3 center;  // C  
 float radius; // r > 0  
};  

struct HitRecord {  
 float t;      // distance along the ray  
 Vec3  p;      // hit point = O + tD  
 Vec3  normal; // unit normal at p = (p – C)/r  
};

The function should:  
1. Compute the coefficients a, b, c of the quadratic  
  a = dot(D, D)  
  b = 2·dot(D, O–C)  
  c = dot(O–C, O–C) – r²  
2. Compute the discriminant Δ = b² – 4ac.  
3. If Δ < 0, return false (no real roots → no intersection).  
4. Otherwise compute the two roots  
  t₁ = (–b – √Δ) / (2a)  
  t₂ = (–b + √Δ) / (2a)  
5. Choose the smallest t in [t_min, t_max]. If neither t₁ nor t₂ is in the range, return false.  
6. Fill rec.t = t, rec.p = O + tD, rec.normal = (rec.p – C)/r, then return true.

Requirements  
• Your code must handle the case where the ray “starts” inside the sphere (one positive root only).  
• Do not assume a = 1 (i.e. you may normalize D externally or include a in your formula).  
• Avoid “shadow acne” by rejecting t < t_min.  

Test Cases  
Using the sphere  
 C = (0, 0, –5), r = 1  

and these rays:  
1. Ray A: O = (0, 0, 0), D = normalize(0, 0, –1)  
   – Expected: hits at t ≈ 4.0,  
     p ≈ (0, 0, –4), normal ≈ (0, 0, 1).  

2. Ray B: O = (2, 0, 0), D = normalize(–1, 0, –1)  
   – Expected: misses (return false).  

3. Ray C: O = (0, 0, –5), D = normalize(1, 0, 0)  
   – Ray origin is on the sphere’s surface → two roots, one zero, one positive.  
     With t_min = 0.001 your code should pick the positive root  
     (t ≈ 2.0, p ≈ (2, 0, –5), normal ≈ (1, 0, 0)).  

Submission  
• Provide the full implementation of intersectSphere.  
• Show the computed t, hit point, and normal for each test case.  
• Briefly explain how you handle the discriminant and the t_min/t_max range.

############### 0.1 ###############
Ray-Sphere Intersection (30 points)  
In this problem you will derive and implement the classic ray–sphere intersection test.  You are given the following types and conventions:  

• A ray is defined by  
 – origin O (Vec3)  
 – direction D (Vec3), assumed normalized (|D|=1)  

• A sphere is defined by  
 – center C (Vec3)  
 – radius r (float)  

Your task is divided into three parts:

1. Derivation (5 points)  
   a) Write the parametric equation of the ray:  
      R(t) = O + t·D,  t ≥ 0  
   b) State the implicit equation of the sphere:  
      |P – C|² = r²  
   c) Substitute R(t) for P, expand the dot products, and show that the intersection parameter t satisfies a quadratic equation  
      a t² + b t + c = 0.  
   d) Clearly define a, b and c in terms of O, D and C.

2. Implementation (15 points)  
   Implement in C++ (or your language of choice) the function  
     bool intersectSphere(  
       const Vec3& O,           // ray origin  
       const Vec3& D,           // ray direction (unit-length)  
       const Vec3& C,           // sphere center  
       float        r,           // sphere radius  
       float&       tHit,       // output: distance along ray to hit  
       Vec3&        hitPoint,   // output: point of intersection  
       Vec3&        normal      // output: surface normal at hitPoint  
     );  

   Requirements:  
   • Compute the discriminant Δ = b² – 4ac.  
   • If Δ < 0, return false (no real roots ⇒ no intersection).  
   • Otherwise compute the two roots t₁, t₂ = (–b ± √Δ)/(2a).  
   • Discard any t ≤ ε (use ε = 1e-4) because we only want intersections “in front” of the ray.  
   • Of the remaining roots, pick the smaller t, assign it to tHit, and compute:  
       hitPoint = O + tHit·D  
       normal   = normalize(hitPoint – C)  
   • Return true if you found a valid tHit, false otherwise.

3. Test Case (10 points)  
   Apply your function to the following concrete inputs and show all intermediate values (L = O – C, a, b, c, Δ, roots, chosen tHit, hitPoint, normal):  

   O = (0, 0, 0)  
   D = normalize( (0.1, 0.2, 1.0) )  
   C = (0, 0, 5)  
   r = 1  

   a) Does the ray intersect the sphere?  
   b) If yes, what numeric values do you get for tHit, hitPoint and normal?

Notes:  
– Vec3 supports basic vector operations (addition, subtraction, dot product, scalar multiply, length, normalization).  
– Be careful to test both quadratic roots and reject any that lie behind the ray origin (t ≤ ε).  
– Show your derivation clearly in part 1 and your code in part 2.

############### 0.2 ###############
Ray–Sphere Intersection  
=======================

In this exercise you will implement a function that tests a ray against a single sphere in 3D space.  If the ray hits the sphere, your function should return the nearest intersection distance t (along the ray) together with the hit point and surface normal; if there is no hit, it should report “no intersection.”  

1. Data Structures  
   Define the following types in your favorite language (C++/Java/C#/Python pseudocode, etc.):  
   
   • Vec3 — a 3D vector or point, supporting addition, subtraction, dot product, scalar multiply, and normalization.  
   • Ray  — has  
       – origin: Vec3  
       – direction: Vec3  (assumed to be unit length)  
   • Sphere — has  
       – center: Vec3  
       – radius: float  
   • Intersection — has  
       – hit: bool  
       – t: float           (distance along ray; valid only if hit == true)  
       – position: Vec3     (point of intersection)  
       – normal: Vec3       (unit surface normal at the hit point)  

2. Function Signature  
   Implement:  
     Intersection intersectSphere(Ray ray, Sphere sphere)  

3. Mathematical Background  
   The ray is P(t) = ray.origin + t · ray.direction, t ≥ 0.  
   The sphere is ‖P – sphere.center‖ = sphere.radius.  
   Substitute P(t) into the sphere equation to get a quadratic in t:  
     Let L = ray.origin – sphere.center.  
     a = dot(ray.direction, ray.direction)  
     b = 2 · dot(ray.direction, L)  
     c = dot(L, L) – sphere.radius²  
   Solve a t² + b t + c = 0 by computing the discriminant Δ = b² – 4ac.  

4. Requirements  
   – If Δ < 0, there is no real intersection: return hit = false.  
   – Otherwise compute the two roots t₁, t₂ = (–b ± √Δ) / (2a).  
   – Discard any t < 0 (behind the ray).  
   – If both t₁, t₂ < 0: return hit = false.  
   – Otherwise pick t = min(positive roots).  
   – Compute position = ray.origin + t · ray.direction.  
   – Compute normal = normalize(position – sphere.center).  
   – Return hit = true, with t, position, normal.  

5. Testing  
   Verify your code with these two cases:

   Case A  
     Sphere center = (0, 0, 5), radius = 1  
     Ray origin  = (0, 0, 0), direction = normalize(0, 0, 1)  
     Expected: hit = true  
               t ≈ 4.0  
               position = (0, 0, 4)  
               normal = (0, 0, –1)  

   Case B  
     Sphere center = (2, 0, 5), radius = 1  
     Ray origin  = (0, 0, 0), direction = normalize(0, 0, 1)  
     Expected: hit = false  

Deliver your complete source code for intersectSphere plus a brief report showing the numeric results for the two test cases above.

############### 0.3 ###############
Ray–Sphere Intersection (Programming Exercise)

Background  
A ray in 3D is parameterized as  
 P(t) = O + t D, t ≥ 0  
where  
• O is the ray origin (a 3D point),  
• D is the ray direction (a normalized 3D vector),  
• t is the ray parameter.  

A sphere is uniquely defined by its center C = (Cx,Cy,Cz) and its radius r > 0.  A point X = (x,y,z) lies on the sphere’s surface if  
 ||X – C||² = r².  

---

Problem Statement  
1) Derive the quadratic equation in t whose solutions give intersection(s) of the ray P(t) with the sphere.  
2) Implement a function that tests whether the ray intersects the sphere and, if so, returns the nearest positive t.  
3) Test your implementation on the sample inputs below.  

---

1) Mathematical Derivation  
Substitute P(t) into the sphere equation:  
 || (O + t D) – C ||² = r²  
Expand to obtain at² + b t + c = 0, where  
 a = D · D  
 b = 2 D · (O – C)  
 c = (O – C) · (O – C) – r²  

Write out a, b, c and show that the discriminant Δ = b² – 4ac determines:  
• Δ < 0 → no intersection  
• Δ = 0 → one (tangent) intersection  
• Δ > 0 → two intersections; choose the smaller positive root  

---

2) Implementation  
In your chosen language (C, C++, Java or Python), implement:

bool   intersect_sphere(  
 Vector3 O,              // ray origin  
 Vector3 D,              // ray direction (unit length)  
 Vector3 C,              // sphere center  
 float   r,              // sphere radius  
 float   t_min,          // minimum t to consider (e.g. 0.001)  
 float   t_max,          // maximum t to consider  
 float& t_hit            // output: nearest t, if any  
);

Function behavior:  
• Compute a, b, c as above.  
• Compute Δ = b² – 4ac. If Δ < 0, return false.  
• Otherwise compute t₁ = (–b – √Δ)/(2a), t₂ = (–b + √Δ)/(2a).  
• If t₁ ∈ [t_min, t_max], set t_hit = t₁ and return true.  
• Else if t₂ ∈ [t_min, t_max], set t_hit = t₂ and return true.  
• Else return false.  

You may assume a = 1 if D is normalized; otherwise use a = D·D.

---

3) Sample Tests  
Use the sphere center C = (1, 2, 3), radius r = 1.5, and the following rays:

a) O = (0,0,0), D = normalize((1,2,3) – (0,0,0))  
   Expected: ray points directly at sphere center, so two intersections.  
   Nearest t ≈ distance(O,C) – r = √14 – 1.5 ≈ 3.7417 – 1.5 = 2.2417  

b) O = (0,0,0), D = normalize((1,2,3) – (0,0,1.5))  
   Expected: ray misses sphere → false  

c) O = (1, 3.5, 3), D = (0, -1, 0)  
   Expected: ray starts above sphere, points down through it → t_hit =  (3.5 – (2 + 1.5)) = 0.0 (tangent at top) or small positive value if you use t_min=0.001  

Show the output t_hit (or “no hit”) for each case.

---

Deliverables  
• A clear, written derivation of the quadratic.  
• Source code for intersect_sphere with comments.  
• A short report of your sample-test results.  

Grading Criteria  
• Correct derivation of a, b, c, Δ.  
• Correct implementation handling all cases (no hit, tangent, two hits).  
• Proper use of t_min/t_max to avoid self‐intersection artifacts.  
• Sample tests match expected values.

############### 0.4 ###############
Ray–Sphere Intersection (Programming Exercise)

Background  
In ray tracing, detecting where (and if) a ray intersects a sphere is one of the fundamental steps in rendering.  Mathematically, a ray is defined as  
   R(t) = O + t·D,   t ≥ 0  
where O is the ray origin, D is the (normalized) direction vector, and t is the distance along the ray.  A sphere is defined by its center C and radius r.  Your task is to write code that, given a ray and a sphere, determines whether they intersect, and if so computes the intersection distance and surface normal.

Problem Statement  
Implement the following two member‐functions for a Sphere class in C++ (or your language of choice):

1.  bool intersect(const Ray& ray, float& out_t)  
    – returns true if the ray intersects the sphere at some t > 0.  
    – out_t shall be set to the smallest positive intersection distance.

2.  Vec3 normalAt(const Vec3& point) const  
    – returns the unit surface normal at the given point on the sphere.

Specifications & Requirements  
1.  Ray and Vec3 definitions (you may adapt as needed):  
    ```cpp
    struct Vec3 {
        float x, y, z;
        // Constructors, addition, subtraction, dot(), multiply by scalar, length(), normalize(), etc.
    };

    struct Ray {
        Vec3 origin;      // O
        Vec3 direction;   // D (assumed normalized)
    };
    ```

2.  Sphere class skeleton:
    ```cpp
    class Sphere {
    public:
        Vec3 center;    // C
        float radius;   // r

        // Returns true if there is an intersection at t > 0.
        // out_t must hold the nearest positive t.
        bool intersect(const Ray& ray, float& out_t) const;

        // Given a point on the sphere surface, return the outward unit normal.
        Vec3 normalAt(const Vec3& point) const;
    };
    ```

3.  Intersection math  
   Substitute R(t) into the sphere equation ‖R(t)−C‖² = r², leading to a quadratic in t:  
       A t² + B t + C = 0  
   where  
     A = D·D  
     B = 2 D·(O − C)  
     C = (O − C)·(O − C) − r²  
   Solve for t using the discriminant. Choose the smallest positive root. If no root is > 0, return false.

4.  Surface normal  
   At point P on the sphere, the outward normal is  
       N = (P − C) / r  
   and must be unit‐length.

5.  Edge cases  
   – Discriminant < 0 ⇒ no intersection.  
   – Discriminant == 0 ⇒ one (tangent) intersection; accept t if > 0.  
   – Both roots ≤ 0 ⇒ the sphere is “behind” the ray; return false.

Sample Test Cases  
Use the unit sphere centered at (0,0,0): radius = 1.

1. Ray(origin=(0,0,−5), direction=(0,0,1))  
   Expected: intersect = true, out_t = 4.0  
   Intersection point = (0,0,−1), normal = (0,0,−1)

2. Ray(origin=(2,0,−5), direction=(0,0,1))  
   Expected: intersect = false

3. Ray(origin=(0,1,−5), direction=(0,0,1))  
   Expected: intersect = true, out_t = 5.0 (tangent), normal = (0,1,0)

Deliverables  
– Complete implementations of Sphere::intersect and Sphere::normalAt.  
– A brief explanation (2–3 sentences) of how you handle the quadratic roots and choose the correct t.  
– A short main() or test harness that runs the sample test cases and prints results.

Evaluation Criteria  
– Correctness of intersection logic (handles all roots, edge cases).  
– Correct normal calculation.  
– Code clarity and proper use of vector operations.  
– Handling of floating‐point comparisons (e.g. discriminant ≥ 0).

############### 0.5 ###############
Ray–Sphere Intersection (Programming Exercise)

Background  
In ray tracing, a ray is usually parameterized as  
    P(t) = O + t·D,  
where  
   O is the ray origin (a 3D point),  
   D is the (normalized) ray direction (a 3D vector),  
   t ≥ 0 is the ray parameter.  

A sphere of center C and radius r consists of all points X satisfying  
  |X – C|² = r².  

By substituting P(t) for X, the ray–sphere intersection reduces to solving a quadratic in t.  

----  
Exercise  
1. Define these data structures in C++ (or your language of choice):  
   struct Vec3  
   {  
     float x, y, z;  
     // … plus constructors and operators for +, –, *, dot( ), length( ) …  
   };  

   struct Ray  
   {  
     Vec3 origin;       // O  
     Vec3 direction;    // D (should be normalized)  
   };  

   struct HitRecord  
   {  
     Vec3 p;            // point of intersection  
     Vec3 normal;       // surface normal at p (unit length, pointing outward)  
     float t;           // ray parameter at intersection  
   };  

   struct Sphere  
   {  
     Vec3 center;       // C  
     float radius;      // r > 0  
   };  

2. Implement the following function:  
   
   // Returns true if ray r hits sphere s between tMin and tMax.  
   // If there is a hit, fill rec with the nearest intersection (smallest valid t).  
   bool hitSphere(  
     const Sphere& s,  
     const Ray& r,  
     float tMin,         // lower bound on t (e.g. 0.001f to avoid “shadow acne”)  
     float tMax,         // upper bound on t (e.g. +∞)  
     HitRecord& rec      // output: intersection data  
   );  

   Your implementation should:  
   • Substitute P(t) into |P(t) – C|² = r² to get a quadratic a t² + b t + c = 0  
     (where a = dot(D, D), b = 2·dot(oc, D), c = dot(oc, oc) – r², and oc = O – C).  
   • Compute the discriminant Δ = b² – 4ac.  
   • If Δ < 0, return false (no real roots ⇒ no hit).  
   • Otherwise solve for the two roots t₁, t₂ = (–b ± √Δ) / (2a).  
   • Check the smaller root first; if it lies in [tMin, tMax], accept it.  
     Otherwise check the larger root.  
   • If neither root is in [tMin, tMax], return false.  
   • On a hit, set rec.t = the chosen t, rec.p = P(t), and  
     rec.normal = (rec.p – C) / r  (this will be unit length).  
   • Return true on a hit, false otherwise.  

3. (Optional) Test your code with this specific sphere and rays:  
   Sphere s{ Vec3{0, 0, –5}, 1.0f };  
   Ray   r1{ Vec3{0, 0, 0}, normalize(Vec3{0, 0, –1}) };  
   Ray   r2{ Vec3{0, 2, 0}, normalize(Vec3{0, 0, –1}) };  

   a) For r1 you should detect a hit at t = 4.0, point p = (0,0,–4), normal = (0,0,1).  
   b) For r2 you should detect no hit (the ray misses the sphere).  

Deliverables  
• Your source code with the completed hitSphere( ) function.  
• A brief explanation (one paragraph) of how you derive the quadratic and choose the correct root.  
• Sample console output (or unit-test results) for the two test rays above.  

Grading rubric  
– Correct derivation and implementation of the quadratic solution (40%)  
– Proper handling of tMin/tMax bounds (20%)  
– Accurate computation of intersection point and normal (20%)  
– Quality of explanation and test outputs (20%)

############### 0.6 ###############
Ray–Sphere Intersection Programming Exercise

Background  
You will write a function that tests a ray against a single sphere in 3D.  The ray is defined by an origin point O and a (normalized) direction vector D.  The sphere is defined by its center C and radius r.  The intersection condition is  
    |O + t D – C|² = r²  
which leads to a quadratic in t.  

Data Structures (you may adapt names to your language of choice)  
  • struct Vec3 { float x, y, z; /* implement +, –, dot(), scale(), length(), normalize() */ };  
  • struct Ray  { Vec3 origin; Vec3 direction; /* direction must be unit length */ };  
  • struct Sphere { Vec3 center; float radius; };  
  • struct Intersection {  
      float t;        // parametric distance along ray  
      Vec3  point;    // intersection point = O + t D  
      Vec3  normal;   // unit normal at point  
    };  

Task  
1.  Write a function with this signature (in C++‐style pseudocode):  
    
    bool intersectRaySphere(const Ray &ray,  
                            const Sphere &sphere,  
                            Intersection &outHit)  
    {  
      // returns true if ray hits sphere;  
      // fills outHit.t, outHit.point, outHit.normal for the nearest positive t.  
    }  

2.  Inside your function do the following steps:  
   a.  Compute the vector L = O – C  
   b.  Compute the quadratic coefficients  
        a = D · D       (should be 1 if D is normalized)  
        b = 2 * (D · L)  
        c = (L · L) – r²  
   c.  Compute the discriminant Δ = b² – 4ac.  
      • If Δ < 0, return false (no real roots → no intersection).  
   d.  Compute the two roots  
        t0 = (–b – √Δ) / (2a)  
        t1 = (–b + √Δ) / (2a)  
      • Swap t0 and t1 if t0 > t1.  
   e.  Choose the smallest positive t:  
      • If t0 > 0, tNear = t0;  
      • else if t1 > 0, tNear = t1;  
      • else return false (both intersections are behind the ray origin).  
   f.  Fill outHit.t = tNear.  
      Compute outHit.point = O + tNear * D.  
      Compute outHit.normal = (outHit.point – C) / r.  // normalized outward normal  
   g.  Return true.  

3.  Test your function with the following cases and report t, point, and normal:  
   Test A  
     Ray origin   O = (0, 0, –5)  
     Ray direction D = (0, 0, 1)  (already normalized)  
     Sphere center C = (0, 0, 0), radius r = 1  
     Expected: two intersections at t = 4 and t = 6 → pick t = 4  
       • Intersection point = (0, 0, –1)  
       • Normal = (0, 0, –1)  

   Test B  
     Ray origin   O = (0, 2, 0)  
     Ray direction D = (0, 1, 0)  
     Sphere center C = (0, 0, 0), radius r = 1  
     Expected: no intersection (ray passes above sphere)  

4.  Answer these questions in comments or a short write-up:  
   a.  Why do we swap t0 and t1 if t0 > t1?  
   b.  What happens in your code if the ray origin lies inside the sphere?  
   c.  Why must D be normalized for a = D·D to equal 1?  

Deliverables  
  • Well-commented source code of intersectRaySphere.  
  • Output values for Test A and Test B.  
  • Brief answers to the conceptual questions.  

Good luck!

############### 0.7 ###############
Ray–Sphere Intersection Exercise
-------------------------------

In this problem you will write code to test a ray against a single sphere in 3D, find the nearest valid intersection (if any), and compute the surface normal at the hit point.

1) Data Structures (you may adapt this to your own vector‐library)

  // A 3D point or vector  
  struct Vec3 {  
    float x, y, z;  
    // … plus operators: +, –, *, dot, length, etc.  
  };

  // A ray: P(t) = origin + t·direction  
  struct Ray {  
    Vec3 origin;       // O  
    Vec3 direction;    // D (should be normalized)  
  };

  // A hit record to store intersection results  
  struct HitRecord {  
    float t;           // ray parameter at hit  
    Vec3 point;        // P = O + t·D  
    Vec3 normal;       // surface normal at P (unit length)  
  };

  // A sphere: |P – center| = radius  
  struct Sphere {  
    Vec3 center;      // C  
    float radius;     // R > 0  
  };


2) Function Signature

Implement the following function:

  // Returns true if the ray hits the sphere between tMin and tMax  
  bool intersectSphere(  
    const Sphere& sphere,  
    const Ray& ray,  
    float tMin,  
    float tMax,  
    HitRecord& rec  
  );

Requirements:

  • Solve for t in ||(O + tD) – C||² = R²:
      a = dot(D, D)
      b = 2·dot(D, O – C)
      c = dot(O – C, O – C) – R²
      discriminant = b² – 4ac  

  • If discriminant < 0 → no real roots → return false.

  • Otherwise compute the two roots  
       t₁ = (–b – √disc) / (2a)  
       t₂ = (–b + √disc) / (2a)  

  • Choose the smallest t in [tMin, tMax]. If neither root lies in that range, return false.

  • Otherwise fill rec.t = t, rec.point = O + tD,  
      rec.normal = (rec.point – C) / R  
      and return true.

  • Be careful with floating‐point precision (e.g. use tMin > 0 to avoid self‐hit).

3) Example Test Case

  Sphere sphere{ Vec3{0,0,-5}, 1.0f };  
  Ray    ray{ Vec3{0,0,0}, normalize(Vec3{0,0,-1}) };  
  HitRecord rec;  
  bool hit = intersectSphere(sphere, ray, 0.001f, FLT_MAX, rec);

  Expected result:
    hit == true  
    rec.t ≈ 4.0  
    rec.point ≈ (0,0,-4)  
    rec.normal ≈ (0,0,1)

4) What to Submit

  – Your source code implementing intersectSphere(...)  
  – A brief comment (2–4 lines) explaining how you derived the quadratic formula  
  – Output of at least two additional test rays (hit/miss, t, point, normal)

Good luck!

############### 0.8 ###############
Ray‐Sphere Intersection (Programming Exercise)

In this exercise you will write a function that tests a ray against a single sphere, finds the nearest intersection (if any), and records the hit point and surface normal.

------------------------------------------------------------------------
Data Structures (in C++-style pseudocode)

struct Vec3 {
  float x, y, z;
  // — assume you have vector addition, subtraction, dot(), scalar mul/div, length(), unit_vector(), etc.
};

struct Ray {
  Vec3 origin;      // O
  Vec3 direction;   // D (assume D is normalized)
  Vec3 at(float t) const { return origin + direction * t; }
};

struct Sphere {
  Vec3 center;      // C
  float radius;     // R > 0
};

struct HitRecord {
  Vec3  point;      // hit point P = O + tD
  Vec3  normal;     // unit outward normal at P, i.e. (P − C)/R
  float t;          // ray parameter
};

------------------------------------------------------------------------
Task

Implement the function

  bool intersect_ray_sphere(
      const Ray&    ray,
      const Sphere& sphere,
      float         t_min,
      float         t_max,
      HitRecord&    rec
  );

Requirements:
 1. Solve the intersection by substituting P(t) = O + t·D into
       |P(t) − C|² = R²
    which yields a quadratic in t.  
 2. Compute the coefficients
       a, b, c  and the discriminant Δ = b² − 4ac.  
 3. If Δ < 0: no real roots → return false.  
 4. Otherwise compute the two roots
       t1 = (−b − √Δ) / (2a)
       t2 = (−b + √Δ) / (2a)
    and pick the smallest t in [t_min, t_max].  
 5. If neither root lies in [t_min, t_max], return false.  
 6. Otherwise fill rec:
      rec.t      = t_chosen;
      rec.point  = ray.at(t_chosen);
      rec.normal = (rec.point − sphere.center) / sphere.radius;
    Then return true.

------------------------------------------------------------------------
Questions

(a) Derivation  
   Starting from |O + tD − C|² = R², show how to obtain  
     a = D·D  
     b = 2·D·(O − C)  
     c = (O − C)·(O − C) − R²  
   and the quadratic Δ = b² − 4ac.

(b) Implementation  
   Write complete C++ code for `intersect_ray_sphere` (using the data structures above).  
   Be careful to:
    • Normalize D before calling (or assert it’s normalized).  
    • Use the smaller root first, then fall back to the larger.  
    • Compare each t against [t_min, t_max].

(c) Example Test  
   Sphere: center C = (0, 0, −5), R = 1  
   Ray:    origin O = (0, 0, 0), direction D = (0, 0, −1)  
   t_min = 0.001, t_max = 1000  

  1. Compute a, b, c, Δ.  
  2. Find the valid root t_hit.  
  3. Compute P = O + t_hit·D.  
  4. Compute the normal at P.  

Show all intermediate steps and final numerical values.

############### 0.9 ###############
Ray–Sphere Intersection (Programming Exercise)

Objective  
Write a function that tests a 3D ray against a single sphere. If they intersect, your function should return the distance \(t\) along the ray to the first hit point (the smallest positive \(t\)) and compute the hit point and its surface normal.

Setup and Data Structures  
You may assume the following C-style (or equivalent in your language of choice) definitions:

```c
// 3‐component vector
typedef struct {
    float x, y, z;
} Vec3;

// Ray: origin O and (normalized) direction D
typedef struct {
    Vec3 O;
    Vec3 D;  // must be unit‐length
} Ray;

// Sphere: center C and radius r
typedef struct {
    Vec3 C;
    float r;
} Sphere;
```

Function Signature  
Implement this function:

```c
// Returns 1 if the ray intersects the sphere at some t > 0.
// - On success, *out_t is set to the smallest positive t,
//   *out_P to the hit point, and *out_N to the unit normal at P.
// - On failure (miss or no positive root), returns 0.
int intersect_sphere(
    const Ray* ray,
    const Sphere* sphere,
    float* out_t,
    Vec3* out_P,
    Vec3* out_N
);
```

Details and Hints  
1.  Expand the geometric equation for the ray  
       P(t) = O + t·D  
    and the sphere  
       |P – C|² = r²  
    to form a quadratic in t:  
       (D·D)·t² + 2·(O–C)·D·t + (O–C)·(O–C) – r² = 0.  
    Since D is normalized, D·D = 1.

2.  Compute  
       L = O – C  
       b = 2·(D·L)  
       c = L·L – r²  
    then the discriminant  
       disc = b² – 4·c.  

3.  If disc < 0 → no real solutions → return 0.  
    Otherwise compute the two roots:  
       t0 = (–b – sqrt(disc)) / 2  
       t1 = (–b + sqrt(disc)) / 2  

4.  We want the smallest positive root:  
    - If t0 > ε (e.g. ε = 1e-4), use t = t0.  
    - Else if t1 > ε, use t = t1.  
    - Else no valid intersection → return 0.

5.  Once you have t:  
    P = O + t·D  
    N = normalize(P – C)  

6.  Fill *out_t, *out_P, *out_N and return 1.

Testing / Sample Case  
Use this sphere and ray to test your implementation:

Sphere: center = (0, 0, 5), radius = 1  
Ray:    origin = (0, 0, 0), direction = (0, 0, 1)  

Expected result:  
– The ray intersects at t = 4.  
– Hit point P = (0, 0, 4).  
– Normal N = (0, 0, –1).

Deliverables  
• Your complete implementation of `intersect_sphere`.  
• A short main() or test harness that calls it with the sample case and prints:  
    – “Hit” or “Miss”  
    – t, P, and N when there is a hit.

############### 1.0 ###############
Programming Assignment: Ray–Axis-Aligned Cube Intersection

Objective  
Implement a function that tests a ray against an axis-aligned cube, returns whether they intersect in a given t-interval, and (if so) computes the nearest hit time t, hit point, and surface normal.

Definitions  
1. Ray  
   struct Ray {  
     Vector3 origin;       // Ray origin  
     Vector3 direction;    // Normalized direction vector  
   };  

2. Axis-Aligned Cube  
   struct Cube {  
     Vector3 min;          // Minimum corner (xmin, ymin, zmin)  
     Vector3 max;          // Maximum corner (xmax, ymax, zmax)  
   };  
   The cube’s faces are perpendicular to the x, y, z axes.  

3. HitRecord  
   struct HitRecord {  
     float t;              // Ray parameter at intersection  
     Vector3 point;        // Intersection point = origin + t·direction  
     Vector3 normal;       // Outward normal of the face hit  
   };  

Function Specification  
Implement this function:

bool intersectCube(  
  const Ray& ray,  
  const Cube& cube,  
  float tMin,            // minimum allowed t (e.g. 0.001f)  
  float tMax,            // maximum allowed t (e.g. FLT_MAX)  
  HitRecord& rec         // on success, fill with nearest hit info  
);

– Return true if the ray intersects the cube with some t in [tMin, tMax].  
– If true, rec.t must be the smallest qualifying t, rec.point = ray.origin + rec.t·ray.direction, and rec.normal must be the outward normal of the face at the hit point.  
– If false, rec is left unmodified (or may be zeroed).

Requirements  

1. Use the “slab method”:  
   – For each axis (x, y, z), compute t0_axis = (cube.min_axis – origin_axis) / dir_axis and t1_axis = (cube.max_axis – origin_axis) / dir_axis.  
   – Swap so t0_axis ≤ t1_axis.  
   – Let t_enter = max(t0_x, t0_y, t0_z), t_exit = min(t1_x, t1_y, t1_z).  
   – If t_enter > t_exit OR t_exit < tMin OR t_enter > tMax, there is no hit. Otherwise the ray hits at t_hit = t_enter (provided t_enter ≥ tMin).  

2. Compute the normal corresponding to the face where t_enter came from:  
   – If t_enter == t0_x, normal = (–1, 0, 0)  
   – Else if t_enter == t1_x, normal = (+1, 0, 0)  
   – Else if t_enter == t0_y, normal = (0, –1, 0)  
   – Etc.  

3. Edge cases:  
   – Ray origin inside the cube (all three t0 < 0): you should still return the first exit intersection, i.e. t_hit = t_exit, and the corresponding normal.  
   – Parallel rays (dir_axis == 0): if origin_axis is outside [min_axis, max_axis], there is no hit; otherwise ignore that axis in slab tests (t0_axis = –∞, t1_axis = +∞).

Example Test Cases  
Let cube = { min = (–1, –1, –1), max = (+1, +1, +1) }.

1. Ray origin (0, 0, –5), direction normalized (0, 0, 1), tMin=0, tMax=10  
   Expected hit:  
     rec.t = 4.0  
     rec.point = (0, 0, –1)  
     rec.normal = (0, 0, –1)  

2. Ray origin (0, 2, 0), direction normalized (0, –1, 0), tMin=0, tMax=10  
   Expected hit:  
     rec.t = 1.0  
     rec.point = (0, 1, 0)  
     rec.normal = (0, 1, 0)  

3. Ray origin (0, 0, 0), direction normalized (1, 1, 1)/√3, tMin=0, tMax=10  
   Origin is inside the cube, first exit is through the +x face:  
     rec.t = (1 – 0)/ (1/√3) = √3 ≈1.732  
     rec.point ≈ (1, 1.732, 1.732)/√3 → (1, 1, 1) clipped to face  
     rec.normal = (1, 0, 0)  

Deliverable  
Submit your intersectCube implementation in C++ (or your language of choice), together with a short main() or unit tests demonstrating it passes the above cases. Ensure your code is robust against rays parallel to axes and origins inside the cube. Technical correctness and clarity will be graded.

############### 1.1 ###############
Ray–Cube Intersection (Axis-Aligned Cube)  
=======================================

In this exercise you will write a function that tests a ray against an axis-aligned cube and, if there is an intersection, returns the distance along the ray to the first hit point and the surface normal at that point.

Object Description  
------------------  
The cube is axis-aligned and centered at the origin. Its side length is 2, so its faces lie on the planes  
 x = –1 and x = +1  
 y = –1 and y = +1  
 z = –1 and z = +1  

Ray Description  
---------------  
A ray is given by  
 R(t) = O + t·D, t ≥ 0  
where  
 O = (O_x, O_y, O_z) is the origin of the ray, and  
 D = (D_x, D_y, D_z) is the (normalized) direction vector.

Function Signature (C-style pseudocode)  
----------------------------------------  
bool intersectCube(  
 vec3 O,            // ray origin  
 vec3 D,            // ray direction (should be normalized)  
 out float tHit,    // distance to the first intersection (if any)  
 out vec3 N         // surface normal at the intersection point  
);

Behavior  
--------  
1. Compute the range of t for which the ray is inside each pair of planes, using the “slab” method:  

   For the x-slab (x = –1 to +1), solve for t_xmin and t_xmax such that O_x + t·D_x = –1 and +1.  
   Similarly compute (t_ymin, t_ymax) and (t_zmin, t_zmax).

2. Let t_enter = max(min(t_xmin, t_xmax), min(t_ymin, t_ymax), min(t_zmin, t_zmax))  
   and  t_exit  = min(max(t_xmin, t_xmax), max(t_ymin, t_ymax), max(t_zmin, t_zmax)).

3. If t_enter > t_exit or t_exit < 0, there is no intersection. Return false.

4. Otherwise the ray hits the cube at t = t_enter (provided t_enter ≥ 0).  
   Set tHit = t_enter.

5. Determine which slab produced t_enter:
   – If t_enter == min(t_xmin, t_xmax), the intersection is on one of the x-faces: normal is (±1, 0, 0).  
   – Else if t_enter == min(t_ymin, t_ymax), normal is (0, ±1, 0).  
   – Else normal is (0, 0, ±1).  
   The sign (±) corresponds to whether you hit the “min” plane (–1) or the “max” plane (+1).

6. Return true.

Requirements  
------------  
• Handle rays parallel to any axis (i.e. D_x, D_y or D_z = 0) without division by zero.  
• Perform comparisons with an epsilon (e.g. 1e-6) if you like, to deal with floating-point imprecision.  
• Assume D is normalized; you do not need to renormalize.  

Example Usage  
-------------  
Given O = (0, 0, –3), D = (0, 0, 1):  
  t_xmin = (–1 – 0)/0  → parallel to x-slabs → treat as “always inside” if O_x ∈ [–1,1].  
  t_zmin = (–1 – (–3))/1 = 2,  t_zmax = (+1 – (–3))/1 = 4.  
  t_enter = max(–∞, –∞, 2) = 2,  t_exit = min(+∞, +∞, 4) = 4.  
Intersection at tHit = 2, hit point P = (0,0,–1), normal N = (0,0,–1).

Deliverables  
------------  
• The source code of intersectCube(…).  
• A brief explanation (comments or separate write-up) of how you handle parallel rays and choose the correct normal.

############### 1.2 ###############
Ray–Axis‐Aligned Cube Intersection  
==================================  

In this exercise you will implement a routine to test a ray against an axis‐aligned cube in 3D.  Your code should compute the nearest positive intersection distance t, the intersection point, and the outward surface normal at that point.

Definitions  
-----------  
• A ray is given by  
  – origin: O = (Ox, Oy, Oz)  
  – direction: D = (Dx, Dy, Dz), assumed normalized.  

• An axis‐aligned cube is uniquely specified by  
  – center: C = (Cx, Cy, Cz)  
  – side length: L > 0  

  Its faces lie on the planes:  
     x = Cx ± L/2, y = Cy ± L/2, z = Cz ± L/2  

Function Signature (C++-style)  
------------------------------  
```cpp
struct Vec3 { float x, y, z; /* plus usual operators */ };
struct HitInfo {
    float t;      // distance along the ray
    Vec3  P;      // intersection point
    Vec3  N;      // surface normal at P
};

/// Returns true if the ray hits the cube at some t > 0, and fills hit.
bool intersectCube(
    const Vec3& O,       // ray origin
    const Vec3& D,       // ray direction (normalized)
    const Vec3& C,       // cube center
    float        L,      // cube side length
    HitInfo&     hit     // out: hit information
);
```

Your implementation must:  
1. Use the “slab” method on the x, y, z axes to find entry and exit t‐values.  
2. Correctly handle rays that start outside the cube (standard case) and rays that start inside the cube (in which case the “exit” intersection is the only positive t).  
3. Return the smallest positive t at which the ray intersects a face.  
4. Compute the intersection point P = O + t D.  
5. Compute the outward normal N at P (one of ±X, ±Y or ±Z unit vectors).  

Hints & Requirements  
--------------------  
• For each axis i ∈ {x,y,z}, compute  
    t1 = (Ci – L/2 – Oi) / Di  
    t2 = (Ci + L/2 – Oi) / Di  
  then let  
    tMin_i = min(t1, t2), tMax_i = max(t1, t2).  

• The overall entry time is tEnter = max(tMin_x, tMin_y, tMin_z).  
  The overall exit time is  tExit  = min(tMax_x, tMax_y, tMax_z).  

• A hit occurs if and only if tEnter ≤ tExit and tExit > 0.  
  • If tEnter > 0, use t = tEnter.  
  • Otherwise (ray starts inside), use t = tExit (provided tExit > 0).  

• To pick the face for the normal: determine which axis i gave the largest tMin_i (if t = tEnter) or which gave the smallest tMax_i (if t = tExit), and choose the corresponding ± axis direction.  

Sample Test Case  
----------------  
Cube: center C = (0, 0, 0), L = 2  
Ray:  O = (0, 0, –5),  D = (0, 0, 1)  

Expected: Ray first meets the z = –1 face.  
 tEnter = (–1 – (–5)) / 1 = 4,  so  
  hit.t = 4  
  hit.P = (0, 0, –1)  
  hit.N = ( 0, 0, –1)  

Deliverables  
------------  
1. The source code for `intersectCube`.  
2. A brief explanation (1–2 sentences) of how you compute tEnter/tExit and choose the normal.  
3. Output of your code on at least three different rays (one outside hitting, one missing, one starting inside).

############### 1.3 ###############
Ray‐Object Intersection Exercise: Axis-Aligned Cube (Slab Method)  
----------------------------------------------------------------  

Problem statement  
-----------------  
Implement a function that tests the intersection of a 3D ray with an axis-aligned cube. The cube is uniquely defined by its minimum corner at (–1,–1,–1) and maximum corner at (+1,+1,+1) in world coordinates (i.e. side length 2, centered at the origin).  

Your task is to:  
 1. Compute whether the ray hits the cube.  
 2. If it does, return the nearest positive ray parameter t>0.  
 3. Compute the surface normal at the intersection point.  

Requirements  
------------  
• Ray is given by  
  – origin O = (Ox, Oy, Oz)  
  – direction D = (Dx, Dy, Dz), normalized.  

• Cube bounds:  
  – min = (–1,–1,–1)  
  – max = (+1,+1,+1)  

• The intersection function signature (in C++-style pseudocode)  

    struct Vec3 { float x,y,z; };  
    struct Ray  { Vec3 origin, direction; };  

    // Returns true if intersection occurs
    // Out parameters: t (smallest positive distance), N (unit normal at hit)
    bool intersectCube(const Ray& ray, float& t, Vec3& N);  

• If the ray origin is inside the cube, you should still find the “exit” intersection (largest t > 0).  

Hints  
-----  
– Use the slab method: for each axis i ∈ {x,y,z},  
    t1_i = (min_i – O_i) / D_i  
    t2_i = (max_i – O_i) / D_i  
  then compute t_min = max( min(t1_x,t2_x),  min(t1_y,t2_y),  min(t1_z,t2_z) )  
            t_max = min( max(t1_x,t2_x),  max(t1_y,t2_y),  max(t1_z,t2_z) ).  
– Intersection occurs if t_min ≤ t_max and t_max > 0.  
– If O is outside the cube, t = t_min; if inside, t = t_max.  
– To find the normal N, determine which slab gave the final t:  
    If t == t1_x or t2_x ⇒ N = ±(1,0,0), etc.  

Test cases  
----------  
1) Ray origin O=(0, 0, –5), D=(0, 0, 1)  
   Expected: t=4, intersection at (0,0,–1), N=(0,0,–1)  

2) O=(2, 0.5, 0), D=(–1, 0, 0)  
   Expected: t=1, intersection at (1,0.5,0), N=(1,0,0)  

3) O=(0.5, 0, 0), D=(1, 1, 0).normalized()  
   Expected: ray starts inside; it exits through the +y face at t≈(1–0)/Dy ≈ (1)/0.7071 ≈1.4142, intersection at (1.5,1,0), N=(0,1,0)  

Deliverables  
------------  
• Well-commented C++-style code for intersectCube() implementing the slab method.  
• A brief explanation (2–3 sentences) of how you choose t and compute the normal.  
• Output of the three test cases above.

############### 1.4 ###############
Programming Exercise: Ray–Axis-Aligned Cube Intersection

Description  
You will implement a ray–object intersection routine for an axis-aligned cube (i.e. an axis-aligned bounding box). Your function must determine whether a given ray intersects the cube, and if so, return the nearest intersection point, its surface normal, and the travel distance t along the ray.

Cube Specification  
– The cube is axis-aligned in world space.  
– It is centered at the origin (0,0,0).  
– It has side length 2, so its extents along each axis are:  
  x ∈ [–1, +1]  
  y ∈ [–1, +1]  
  z ∈ [–1, +1]

Ray Specification  
A ray is defined by  
 origin:  ro = (ox, oy, oz)  
 direction: rd = (dx, dy, dz) (assume normalized)  
The parametric equation is P(t) = ro + t·rd, t ≥ 0.

HitRecord Structure (in C++-style pseudocode)  
struct HitRecord {  
 float t;              // distance along the ray to the hit point  
 Vec3 point;           // world-space hit coordinate  
 Vec3 normal;          // unit surface normal at the hit point  
};

Function Signature (pseudocode)  
bool intersectCube(  
 const Ray& ray,      // contains origin ro and direction rd  
 float tMin,          // minimum t to consider (e.g. 0.001)  
 float tMax,          // maximum t to consider (e.g. +infinity)  
 HitRecord& rec       // output hit record, filled only if intersection occurs  
);

Requirements  
1. Use the slab method:  
 – For each axis (x, y, z), compute the intersection interval [t0, t1] of the ray with the two planes of that axis.  
 – Maintain a running interval [tNear, tFar] that is the intersection over all three axes.  
 – If at any point tNear > tFar, there is no intersection.  
2. Handle rays parallel to slab planes correctly. If rd.axis == 0, then if ro.axis is outside the slab range [–1, +1], return false.  
3. After computing [tNear, tFar]:  
 – If tNear > tMax or tFar < tMin, return false (intersection is outside the valid t-range).  
 – Otherwise let tHit = (tNear ≥ tMin ? tNear : tFar). If tHit < tMin or tHit > tMax, return false.  
4. On success (return true), fill rec with:  
 – rec.t = tHit  
 – rec.point = ro + tHit·rd  
 – rec.normal = the outward normal of the face hit  
  To find the normal, check which axis produced tNear (or tHit) and whether you hit the “min” or “max” plane of that axis:  
   If tHit equals the intersection with x = –1 then normal = (–1,0,0)  
   If with x = +1 then normal = (+1,0,0)  
   (similarly for y and z)

Deliverables  
1. A fully-commented implementation of intersectCube().  
2. A brief explanation (in comments or separate doc) of how you compute t0/t1 for each slab and how you extract the normal.  
3. A few test cases with known results, for example:  
 – ray origin (0,0,–5), direction (0,0,1) → hit at t=4 (entrance), normal (0,0,–1)  
 – ray origin (2,0,0), direction (–1,0,0) → hit at t=1 (entrance), normal (1,0,0)  
 – ray origin (0,2,0), direction (0,1,0) → no hit  

Optional Extension  
Allow the cube to be translated and uniformly scaled. In that case, you will first transform the ray into cube’s object space before applying the same slab method.

############### 1.5 ###############
Ray–Cube Intersection  
====================

Background  
----------  
In ray tracing, detecting whether and where a ray intersects a cube (an axis-aligned bounding box) is a fundamental building block.  In this exercise you will implement a function that tests a ray against an axis-aligned cube, computes the entry and exit distances t along the ray (if any), and returns the surface normal at the entry point.

Problem Statement  
-----------------  
We have an axis-aligned cube defined by its center C = (Cx, Cy, Cz) and a side-length L > 0.  Thus the cube’s faces lie at  
  x ∈ [Cx – L/2,  Cx + L/2],  
  y ∈ [Cy – L/2,  Cy + L/2],  
  z ∈ [Cz – L/2,  Cz + L/2].  

A ray is given by  
  R(t) = O + t D,   t ≥ 0,  
where O = (Ox, Oy, Oz) is the origin and D = (Dx, Dy, Dz) is a normalized direction vector.

You must write a function with the following signature in C++ (or your language of choice):

    struct Ray {
      Vec3   O;    // origin
      Vec3   D;    // normalized direction
    };

    struct Hit {
      bool    hit;      // true if intersects
      float   t0, t1;   // entry and exit distances along the ray
      Vec3    N;        // surface normal at entry point
    };

    // Computes ray–cube intersection. Returns entry (t0) and exit (t1) and
    // the face normal at the entry point. If no intersection, hit=false.
    Hit intersectCube(const Ray& ray,
                     const Vec3& cubeCenter,
                     float      cubeSideLength);

Requirements  
------------  
1. Use the “slab method” to compute intersection intervals along x, y and z.  
2. Determine the maximum of the three “t-entry” values (tx_min, ty_min, tz_min) and the minimum of the three “t-exit” values (tx_max, ty_max, tz_max).  
3. If t_entry ≤ t_exit and t_exit ≥ 0, there is an intersection.  
4. The ray enters the cube at t0 = max(t_entry, 0) (or simply t0 = t_entry if you assume rays start outside).  
5. Return t1 = t_exit.  
6. Compute the outward normal at the entry point by figuring out which slab (x, y or z) gave t_entry.  If tx_min is largest, the normal is ±(1,0,0), with the sign determined by the sign of Dx.  Analogous for y and z slabs.

Hints  
-----  
• Be careful with division by zero when Dx, Dy or Dz is zero—handle the parallel-slab case by checking if the ray origin’s coordinate is within the slab.  
• Ensure you swap t_min and t_max for each axis if D is negative.  
• Normalize D before calling your function (or assert it is normalized).  

Testing  
-------  
Validate your code with at least these four test rays against the cube centered at (0,0,0) with side length 2:

1. Ray: O = (−5, 0, 0),  D = (1,  0,  0)  
   Expect: hit=true, t0=4, t1=6, normal=(−1,0,0)  

2. Ray: O = (0, 3, 0),  D = (0, −1, 0)  
   Expect: hit=true, t0=1, t1=5, normal=(0,1,0)  

3. Ray: O = (0, 0, 5),  D = (0,  0, −1)  
   Expect: hit=true, t0=3, t1=7, normal=(0,0,1)  

4. Ray: O = ( 2, 2, 2),  D = (1,  1,  1).normalized()  
   Expect: hit=false  

Deliverables  
------------  
• Source code implementing `intersectCube`.  
• A short write-up (1–2 paragraphs) explaining how you handle parallel rays and choose the correct face normal.  
• Output logs showing the four test cases and their results.

############### 1.6 ###############
Ray–Cube Intersection (Axis-Aligned Cube)  
========================================  

In this exercise you will implement a ray-axis-aligned-cube intersection test using the “slab” method. Your function should tell whether a given ray intersects the cube, and if so return:  
 1. the parametric distance t to the nearest intersection point along the ray (t > 0),  
 2. the 3D position of that point, and  
 3. the outward surface normal at that point.  

— Problem Statement —  

You are given:  
 • A ray R represented by  
     Origin O = (Ox, Oy, Oz)  
     Direction D = (Dx, Dy, Dz)  (assume D is normalized)  
   so that any point on the ray is R(t) = O + t·D, t ≥ 0.  

 • An axis-aligned cube C defined by  
     Center Cc = (Cx, Cy, Cz)  
     Side length L > 0  

   The cube’s faces lie on the planes  
     x = Cx ± L/2,  
     y = Cy ± L/2,  
     z = Cz ± L/2.  

Write a function with signature (in pseudocode):  
  bool intersectCube(Ray R, Cube C, out float tHit,  
                     out Vec3 hitPos, out Vec3 hitNormal)  

such that:  
 • If the ray does not hit the cube (for any t ≥ 0), return false.  
 • Otherwise:  
    – tHit = the smallest t ≥ 0 at which R(t) lies on the cube surface.  
    – hitPos = O + tHit·D  
    – hitNormal = the outward pointing unit normal at hitPos (one of ±X, ±Y or ±Z).  
    – Return true.  

Requirements / Hints  
-------------------  
1. Slab‐Method Overview:  
   For each axis i ∈ {x,y,z}:  
     • Compute tmin_i = (min_i – O_i) / D_i  
       and  tmax_i = (max_i – O_i) / D_i,  
       where min_i = Ci – L/2, max_i = Ci + L/2.  
     • If D_i < 0, swap tmin_i and tmax_i (so that tmin_i ≤ tmax_i).  
   Then let:  
     t_enter = max( tmin_x, tmin_y, tmin_z )  
     t_exit  = min( tmax_x, tmax_y, tmax_z )  
   The ray intersects the cube iff t_enter ≤ t_exit and t_exit ≥ 0.  
   Use tHit = t_enter (if t_enter ≥ 0), otherwise tHit = t_exit (if ray starts inside).  

2. Handling Parallel Rays:  
   If D_i = 0 then the ray is parallel to the planes orthogonal to axis i.  
   – If O_i < min_i or O_i > max_i, the ray misses the cube entirely—return false.  
   – Otherwise treat tmin_i = –∞, tmax_i = +∞ for that axis.  

3. Computing the Normal:  
   The face that the ray hits corresponds to the axis i for which t_enter == tmin_i (the “winning” slab).  
   – If i = x and D_x > 0, normal = (–1, 0, 0)  (you entered through the x = Cx – L/2 face)  
   – If i = x and D_x < 0, normal = (+1, 0, 0)  (entered through x = Cx + L/2)  
   – Similarly for y and z faces.  

4. Edge Cases to Consider:  
   • Ray origin starts inside the cube (all O_i in [min_i, max_i]). Then t_enter < 0 but t_exit > 0: you should return the exit point (tHit = t_exit) and its normal.  
   • Ray exactly grazes an edge or corner: t_enter may equal t_exit; treat this as a valid intersection.  

Deliverables  
------------  
 • Well-commented source code for intersectCube.  
 • A short write-up (1–2 paragraphs) explaining how you handle:  
     – Parallel rays (D_i = 0 cases)  
     – Rays starting inside the cube  
     – Determination of hitNormal  

Optional Bonus  
--------------  
• Extend your code to support arbitrarily oriented (rotated) cubes by applying the inverse cube transform to the ray before intersection.

############### 1.7 ###############
Ray-Cube Intersection Exercise

In this problem you will implement the ray–cube intersection test for an **axis-aligned** cube (i.e. its faces are perpendicular to the coordinate axes). You will use the “slab” method to find the entry and exit distances (t-values) along the ray, and from that determine whether the ray hits the cube, at what distance, and with which surface normal.

---

1. Cube Definition  
   • Center: C = (Cx, Cy, Cz)  
   • Side length: S  
   • Because the cube is axis-aligned, its faces lie at  
     Cx ± S/2, Cy ± S/2, Cz ± S/2.  

2. Ray Definition  
   A ray is given by  
     O = (Ox, Oy, Oz)       — origin  
     D = (Dx, Dy, Dz)       — **normalized** direction  
   The ray’s points are P(t) = O + t D, t ≥ 0.

3. Function Signature (in C++-style pseudocode)  
   bool intersectCube(  
     const Vec3& O,  
     const Vec3& D,  
     const Vec3& C,  
     float       S,  
     float&      tHit,       // OUT: parametric distance of first hit ≥ tMin  
     Vec3&       hitNormal,  // OUT: outward normal at P(tHit)  
     float       tMin = 0.0f // ignore hits with t < tMin  
   );

   – Return true if the ray intersects the cube for some t ≥ tMin;  
     in that case set tHit to the smallest valid t and set hitNormal.  
   – Return false if there is no intersection at t ≥ tMin.

4. Algorithm Outline (Slab Method)

   For each axis i ∈ {x,y,z}:  
     • Compute the two slab intersection t’s:  
         ti0 = (Ci – S/2 – Oi) / Di  
         ti1 = (Ci + S/2 – Oi) / Di  
       If Di == 0, the ray is parallel to that axis;  
       then if Oi < Ci – S/2 or Oi > Ci + S/2 → no intersection.  
       Otherwise the ray lies inside that slab for all t.  
     • Swap ti0 and ti1 if ti0 > ti1 (so ti0 is entry, ti1 is exit).

   Let tEnter = max(tx0, ty0, tz0),  
       tExit  = min(tx1, ty1, tz1).

   If tEnter > tExit or tExit < tMin → no intersection.  
   Otherwise the ray hits the cube at tHit = (tEnter ≥ tMin ? tEnter : tExit).

   To compute the normal at P(tHit):
     • Determine which slab gave tHit:  
       if tHit == tx0, normal = (−sign(Dx),0,0)  
       else if tHit == tx1, normal = ( +sign(Dx),0,0)  
       else if tHit == ty0, normal = (0,−sign(Dy),0)  
       … and so on for y1, z0, z1.  

   Here sign(Di) is +1 if Di>0, –1 if Di<0.

5. Implementation Tasks

   a) Write `intersectCube` following the outline above.  
   b) Make sure to handle parallel rays (Di==0) robustly.  
   c) Test your function on the cases below.

6. Test Cases

   1) Cube centered at (0,0,0), S=2.  
      Ray: O=(0,0,−5), D=(0,0,1)  
      Expected: hit at tHit=4.0  
        P=(0,0,−1), normal=(0,0,−1)

   2) Same cube.  
      Ray: O=(0,0,−5), D=(1,0,0)  
      Expected: no intersection

   3) Same cube.  
      Ray: O=(0.5,0.5,0.5), D=(0,1,0)  
      Expected: origin is inside → first valid t is exit:  
        yt such that 0.5 + t·1 = +1  ⇒ tHit = 0.5  
        P=(0.5,1,0.5), normal=(0,1,0)

   4) Cube centered at (1,2,−3), S=4.  
      Ray: O=(1,2,0), D=(0,0,−1)  
      Expected:  
        The cube’s front face is at z = Cz + S/2 = −3 +2 = −1  
        So tHit = (−1 − 0)/(−1) = 1.0  
        P=(1,2,−1), normal=(0,0,1)

Once your implementation passes these tests, you will have a working axis-aligned ray–cube intersection routine suitable for a basic ray tracer.

############### 1.8 ###############
Ray–Cube Intersection (Axis‐Aligned)  
------------------------------------  

In this exercise you will write a function that tests a ray against an axis‐aligned cube (a simple bounding box) and, if there is a hit, returns the hit‐point, the surface normal at that point, and the parameter t along the ray. We assume the cube is defined by its minimum and maximum corner points in world space.

1. Data Structures  
   You may assume the following C++‐style definitions (or equivalent in your language of choice):  

     struct Vec3 {
       float x, y, z;
       Vec3 operator+(const Vec3& v) const;
       Vec3 operator-(const Vec3& v) const;
       Vec3 operator*(float s)    const;
       Vec3 operator/(float s)    const;
       // ... dot, min, max, etc., as needed
     };

     struct Ray {
       Vec3 origin;
       Vec3 direction;    // assumed normalized
     };

     struct HitRecord {
       float t;           // ray parameter at intersection
       Vec3 point;        // hit point in world space
       Vec3 normal;       // outward‐facing surface normal
     };

     struct AABB {
       Vec3 min;          // (x_min, y_min, z_min)
       Vec3 max;          // (x_max, y_max, z_max)
     };

2. Problem Statement  
   Implement the function  
   
     bool intersectCube(const Ray& ray,
                        const AABB& box,
                        float t_min,          // minimum valid t
                        float t_max,          // maximum valid t
                        HitRecord& rec);

   The function should return true if the ray intersects the cube within the interval [t_min, t_max]. If there is an intersection, it should:  
     a. Write the smaller valid t into rec.t (that is, the first time the ray enters the cube).  
     b. Compute rec.point = ray.origin + rec.t * ray.direction.  
     c. Compute rec.normal as the outward‐facing normal at that point.  

3. Hints / Requirements  
   • Use the “slab” method: for each axis (x, y, z) compute the t‐values where the ray intersects the planes  
     ray.origin.{axis} + t · ray.direction.{axis} = box.min.{axis}  
     and  
     ray.origin.{axis} + t · ray.direction.{axis} = box.max.{axis}.  
   • Let t0_axis = (box.min.{axis} – ray.origin.{axis}) / ray.direction.{axis}  
     and t1_axis = (box.max.{axis} – ray.origin.{axis}) / ray.direction.{axis}.  
   • Swap t0_axis and t1_axis if t0_axis > t1_axis.  
   • Maintain a running t_enter = max(t0_x, t0_y, t0_z) and t_exit = min(t1_x, t1_y, t1_z).  
   • If t_enter > t_exit or t_exit < 0, there is no hit.  
   • Clamp t_enter to [t_min, t_max]. If t_enter outside that range, reject.  
   • To find the normal: identify which axis produced the maximum t0_axis (i.e. which slab was entered last).  
     If it was the x‐slab, normal = ±(1,0,0), sign chosen by the sign of ray.direction.x; similarly for y and z.  

4. What to Submit  
   • Your implementation of intersectCube(…) in code.  
   • A brief explanation (2–3 sentences) of how you determine the correct normal.  
   • Two test cases (ray origin, ray direction, t_min, t_max) with expected output (hit/no‐hit, t, point, normal).

5. Example cubes and rays for sanity checking (you don’t need to submit these):  
   – Cube: min=(–1,–1,–1), max=(1,1,1)  
   – Ray A: origin=(0,0,–5), direction=(0,0,1), t_min=0.001, t_max=100  
     * Expected: hit at t=4, point=(0,0,–1), normal=(0,0,–1)  
   – Ray B: origin=(2,0,0), direction=(–1,0,0), t_min=0.001, t_max=100  
     * Expected: hit at t=1, point=(1,0,0), normal=(1,0,0)  
   – Ray C: origin=(2,2,2), direction=(1,1,1), t_min=0.001, t_max=100  
     * Expected: no hit  

Use clear, well‐commented code and ensure your normal calculation is robust even when the ray grazes an edge or corner. Good luck!

############### 1.9 ###############
Ray–Cube Intersection (Axis‐Aligned)  
===================================

In this exercise you will implement a function to test intersection between a ray and an axis‐aligned cube (an AABB that happens to be a cube), compute the nearest hit distance t, and return the surface normal at the hit point.  

Object Description  
------------------  
• The cube is axis‐aligned, centered at point C = (Cx,Cy,Cz) in world space.  
• It has side length s, so its extents along each axis run from  
 xmin = Cx – s/2  
 xmax = Cx + s/2  
 (and similarly for y and z).  

Ray Description  
---------------  
• A ray is given by  
 O = (Ox,Oy,Oz)   (origin)  
 D = (Dx,Dy,Dz)   (direction, not necessarily normalized)  
• The ray’s parametric equation is P(t) = O + t·D, with t ≥ 0.  

You must handle:  
 • Rays parallel to one or more cube faces.  
 • Rays that start inside the cube (in which case tnear < 0 < tfar).  
 • Choosing the nearest intersection with t ≥ 0.  

Function Signature (in C++‐like pseudocode)  
---------------------------------------------  
bool intersectCube(  
    const Vec3 &O,           // Ray origin  
    const Vec3 &D,           // Ray direction  
    const Vec3 &C,           // Cube center  
    float       s,           // Cube side length  
    float      &tHit,        // [out] nearest t ≥ 0, if hit  
    Vec3       &hitNormal    // [out] unit normal at P(tHit)  
);  

Return value:  
 • true  if the ray hits the cube at some t ≥ 0.  
 • false otherwise.  

On a hit, you must set:  
 • tHit = the smallest non‐negative t at which the ray intersects the cube.  
 • hitNormal = the outward‐facing normal of the face that is hit at tHit.  

Hints / Requirements  
--------------------  
1.  Use the “slab method”: for each axis i ∈ {x,y,z}, compute  
     t1i = (mini – Oi) / Di  
     t2i = (maxi – Oi) / Di  
    then let  
     tmin_i = min(t1i, t2i)  
     tmax_i = max(t1i, t2i)  
2.  Compute  
     t_enter = max( tmin_x, tmin_y, tmin_z )  
     t_exit  = min( tmax_x, tmax_y, tmax_z )  
    If t_enter > t_exit or t_exit < 0, there is no intersection.  
3.  If t_enter ≥ 0, that is the entry hit; else (ray starts inside) use t_exit as the hit time.  
4.  To determine the face normal, compare t_enter (or t_exit, if entry < 0) to the three candidate t’s. The axis whose slab produced that t gives the normal direction ±ei.  
5.  Be careful with Di = 0 (parallel to that axis). If the ray origin Oi is outside [mini,maxi], there is no hit.  

Example Test Case  
-----------------  
Cube: center C = (0,0,0), s = 2  
⟹ xmin=–1, xmax=+1 (and similarly for y,z)  

1) Ray from (10,0,0) in direction (–1,0,0):  
   t1x = (1 – 10)/(–1)=9,  t2x = (–1 – 10)/(–1)=11  
   tmin_x=9, tmax_x=11  
   For y,z: Dy=Dz=0, Oy=Oz=0 are inside [–1,1] so slabs impose no restrictions.  
   t_enter=9, t_exit=11, both ≥0 ⇒ hit at tHit=9  
   hitPoint = (1,0,0), normal = (+1,0,0)  

2) Ray from (0,0,0) inside cube, direction (0,1,0):  
   tmin_y = (–1 – 0)/1 = –1,  tmax_y = (1 – 0)/1 = 1  
   t_enter = max(–1, –∞, –∞) = –1  
   t_exit  = min(+∞, +1, +∞) = +1  
   t_enter<0 so the first visible hit is at t_exit=1  
   hitPoint = (0,1,0), normal = (0,+1,0)  

Deliverables  
------------  
• Your implementation of intersectCube(…) in C, C++ or Java.  
• A brief explanation (1–2 paragraphs) of how you handle parallel rays and interior‐start rays.  
• Output from at least three distinct test rays, showing O, D, and your computed tHit & hitNormal.

############### 2.0 ###############
Programming Assignment: Ray–Square Intersection

Overview  
You will write a function that tests the intersection of a ray with an axis‐aligned square in 3D space.  If the ray hits the square, your function must return the parameter t along the ray, the hit point, and the surface normal; otherwise it should report “no hit.”

Scene and Data Structures  
1. Ray  
   • origin:  Vec3 o  
   • direction: Vec3 d  (normalized)  
2. Square  
   • center:   Vec3 C  
   • sideLength: float L  (L > 0)  
   • normal:   Vec3 N      (unit length)  
   • uAxis:    Vec3 U      (unit, perpendicular to N)  
   • vAxis:    Vec3 V      (unit, perpendicular to both N and U, so V = N × U)  

The square lies in the plane P: { X | (X−C)·N = 0 } and extends L/2 in both +U and −U, and L/2 in both +V and −V directions.

Function Signature (C++‐style pseudocode)  
```
struct Ray {
    Vec3 o;    // origin
    Vec3 d;    // direction, assumed normalized
};

struct HitRecord {
    float t;         // ray parameter at hit
    Vec3  point;     // hit point in space
    Vec3  normal;    // surface normal at hit
    bool  hit;       // did we hit?
};

struct Square {
    Vec3  C;         // center
    Vec3  N;         // normal (unit)
    Vec3  U;         // first axis in plane (unit, orthogonal to N)
    Vec3  V;         // second axis in plane (unit, orthogonal to N and U)
    float L;         // side length
};

// Returns a HitRecord with hit==true if ray hits the finite square, false otherwise.
HitRecord intersectSquare(const Ray& ray, const Square& sq);
```

Requirements  
1. Compute the intersection t_plane of the ray with the infinite plane containing the square:  
   t_plane = ((C − o)·N) / (d·N)  
   • If denominator (d·N) is zero (or very close), report no hit.  
   • If t_plane ≤ 0, the square is “behind” the ray origin; report no hit.

2. Compute the hit point P = o + t_plane * d.

3. Express P in the square’s local (U,V) coordinates relative to C:  
   • u_coord = (P − C) · U  
   • v_coord = (P − C) · V  

4. Check bounds:  
   • If |u_coord| > L/2 or |v_coord| > L/2, the hit point lies outside the square; report no hit.  

5. Otherwise, fill HitRecord:  
   • t = t_plane  
   • point = P  
   • normal = N   (make sure it faces against the ray direction: if (d·N) > 0 then normal = −N)  
   • hit = true  

6. Return the HitRecord.

Exercise Tasks  
a) Implement intersectSquare exactly as described above.  
b) Write at least two unit tests:  
   • Ray striking at the center of the square.  
   • Ray grazing just outside an edge (should report no hit).  
c) (Optional) Extend your code to compute 2D texture coordinates (s, t) in [0,1]×[0,1], where  
   s = (u_coord + L/2) / L  
   t = (v_coord + L/2) / L  

Submission  
• Source file(s) containing your implementation and tests.  
• A brief explanation (comments or separate text) showing how you handle edge cases (parallel ray, grazing hits).  

Grading Criteria  
• Correctness of intersection logic (plane solve + bounds check).  
• Handling of degenerate/edge cases.  
• Code clarity, comments, and test coverage.

############### 2.1 ###############
Ray–Square Intersection (Programming Exercise)

Objective  
Implement a function that tests a ray against a single, finite square in 3D. If the ray hits the square, your code should compute the hit distance along the ray, the 3D hit point, and the surface normal at that point.

Square Definition  
A square S is specified by:  
 • Center point C ∈ ℝ³  
 • Unit normal vector N ∈ ℝ³ (|N| = 1)  
 • Side length L > 0  
Because the square lies in the plane (N·X = N·C), its edges span two orthonormal directions U and V in that plane:  
 1. Choose any vector A not parallel to N (e.g. A = (1,0,0) or (0,1,0)).  
 2. U = normalize(A – (A·N) N)  
 3. V = N × U  

Thus the four corners of S are  
  C ± (L/2) U ± (L/2) V  

Ray Definition  
A ray R is given by  
 R(t) = O + t D, t ≥ 0  
where O ∈ ℝ³ is the origin and D ∈ ℝ³ is a unit‐length direction.

Your Task  
1. Derive an expression for the parameter t at which R intersects the plane of the square.  
2. Determine whether the intersection point P = R(t) lies within the square’s boundaries.  
3. Implement the following C++‐style function:

```cpp
struct Vec3 { float x, y, z; /* + vector ops */ };
struct Ray  { Vec3 O, D;         /* origin, unit direction */ };
struct Square {
  Vec3 C;     // center
  Vec3 N;     // unit normal
  float L;    // side length
};

struct Intersection {
  bool hit;      // true if intersection occurs
  float t;       // ray parameter
  Vec3  P;       // hit point
  Vec3  Nhit;    // surface normal
};

// Returns true and fills 'isect' if ray hits square, otherwise returns false.
bool intersectSquare(const Ray& ray, const Square& sq, Intersection& isect);
```

Requirements  
• Reject rays parallel to the square’s plane.  
• Only report intersections with t > 0.  
• If the ray hits outside the square’s side‐length boundaries, report no hit.  
• on a hit, set isect.hit = true, isect.t = t, isect.P = O + t D, isect.Nhit = ±N (pointing against D).  

Hints  
• Solve for t: N·(O + t D – C) = 0 ⇒ t = N·(C – O) / (N·D).  
• Compute local coordinates u = U·(P – C), v = V·(P – C).  
  Then |u| ≤ L/2 and |v| ≤ L/2 means P is inside the square.  
• Choose U by projecting a non‐collinear axis onto the plane.  

Sample Data (for testing)  
Square: C = (0,0,5), N = (0,0,-1), L = 2  
Ray:    O = (1, 1, 0), D = normalize(0,0,1)  
Expected intersection:  
 t = 5, P = (1,1,5), inside the square, Nhit = (0,0,1)  

Deliverables  
• A short derivation showing your intersection formula.  
• Well‐commented C++ code for intersectSquare(…).

############### 2.2 ###############
Ray‐Square Intersection (Axis‐Aligned Square in 3D)

In this exercise you will write a routine to test a 3D ray against an axis‐aligned square that lies in a plane z = z₀.  The square is centered at (cₓ, c_y, z₀), has side length L, and its edges are parallel to the X– and Y–axes.

1. Data Structures & Function Signature  
   You may assume the following structs have already been defined:

     struct Vec3 {
       float x, y, z;
       // … vector arithmetic, dot(), etc.
     };

     struct Ray {
       Vec3 o;    // origin
       Vec3 d;    // direction (guaranteed to be normalized)
     };

   Write a function with this signature:

     bool intersectSquare(
       const Ray&    ray,
       float         z0,         // z‐coordinate of the square’s plane
       const Vec3&   center,     // (cₓ, c_y, z0)
       float         sideLength, // L
       float         tMin,       // minimum valid t
       float         tMax,       // maximum valid t
       float&        tHit,       // output: ray parameter at intersection
       Vec3&         hitP,       // output: world‐space intersection point
       Vec3&         hitN        // output: surface normal at hitP
     );

   Your function returns true if the ray intersects the finite square within [tMin, tMax], filling in tHit, hitP, and hitN.  Otherwise it returns false.

2. Intersection Algorithm
   • Step 1: Plane intersection  
     Solve for t in the plane equation z0 = o.z + t·d.z  
     If d.z is zero (ray is parallel to the plane), there is no intersection.

   • Step 2: Check t‐range  
     If t < tMin or t > tMax, reject.

   • Step 3: Compute hit point  
     hitP = ray.o + t·ray.d

   • Step 4: Square bounds test  
     Let half = 0.5f * sideLength.  
     If |hitP.x – center.x| > half or |hitP.y – center.y| > half, reject.

   • Step 5: Compute normal  
     The square’s geometric normal is (0, 0, +1).  If the ray is coming from below (ray.d.z > 0), flip it to (0,0,−1) so that hitN always opposes the incoming ray.

3. What You Must Deliver
   • Complete C++ code for interpolateSquare(), as specified above.  
   • Brief comments showing each of the five steps.  
   • No external libraries—just basic Vec3 arithmetic.

Example behavior:
  Given a ray with origin (0,0,5) pointing down (0,0,−1), square at z₀=0, center=(0,0,0), L=2:
    – Plane intersection: t = (0 − 5)/(−1) = 5
    – hitP = (0,0,0)
    – Bounds: |0−0|≤1, |0−0|≤1 → inside
    – hitN = (0,0,1)
    – Returns true with tHit=5

Corner cases to handle:
  • Ray parallel to the plane (d.z == 0).  
  • Intersection outside [tMin, tMax].  
  • hitP outside the square’s X–Y limits.  
  • Back‐facing ray: ensure normal is flipped if needed.

Good luck!

############### 2.3 ###############
Ray-Square Intersection  
-----------------------

In this exercise you will implement a ray-object intersection test for an axis-aligned square.  The square lies in the plane z = 0, is centered at the origin, has side length 2, and its outward normal points toward +z.  Concretely:

• Corners of the square are at  
   (–1, –1,  0),  
   ( +1, –1,  0),  
   ( +1, +1,  0),  
   (–1, +1,  0).  
• The face normal is N = (0, 0, 1).  

You must write a function with this signature (in C++‐style pseudocode):

    // Returns true if ray hits the square.
    // On hit, sets:
    //   tHit = ray parameter at intersection (t > 0),
    //   u    = local x‐coordinate mapped [–1..+1] → [0..1],
    //   v    = local y‐coordinate mapped [–1..+1] → [0..1].
    bool intersectSquare(
        const Ray& ray,
        float&      tHit,
        float&      u,
        float&      v
    );

where

    struct Ray {
        Vec3 origin;     // ray origin
        Vec3 direction;  // assumed normalized
    };

Your function must:

1.  Compute intersection with the plane z = 0:
      • If ray.direction.z is 0, the ray is parallel → no hit.
      • Otherwise, solve t = –(ray.origin.z) / ray.direction.z.
2.  Accept the intersection only if t > ε (e.g. 1e–4).
3.  Compute the 3D intersection point:
      P = ray.origin + t * ray.direction.
4.  Check whether P.x and P.y both lie between –1 and +1.  
    If not, it misses the square.
5.  If it hits, compute local (u, v) in [0,1] by remapping:
      u = (P.x + 1) * 0.5  
      v = (P.y + 1) * 0.5  
6.  Return true if all tests pass; otherwise false.

---

Example test cases:

1) Ray origin = (0, 0, –5), direction = (0, 0, +1)  
   → tHit = 5,  P = (0,0,0) → u = 0.5, v = 0.5, return true  

2) Ray origin = (2, 2, –5), direction = (0, 0, +1)  
   → t = 5 gives P = (2,2,0) outside square → return false  

3) Ray origin = (0.5, 0.7, –1), direction = (0, 0, +1)  
   → t = 1 gives P = (0.5,0.7,0) inside → u = 0.75, v = 0.85 → return true  

---

Deliverables:

• Complete implementation of `intersectSquare`.  
• Brief comments or explanation of each step.

############### 2.4 ###############
Ray–Square Intersection Exercise

In this problem you will implement and test a ray–square intersection routine.  The square may be arbitrarily positioned and oriented in 3D space.  Your task is to derive the intersection test, code it, and verify it on sample data.

----------------------------------------------------------------
Problem Statement
----------------------------------------------------------------

We represent a square by the following data:
  • Center point C = (Cx, Cy, Cz).  
  • Two orthonormal edge–direction vectors U and V (both unit length, U·V = 0).  
  • Side length L > 0.  

The square’s four corners are at  
  C ± (L/2) U ± (L/2) V  

Its surface normal is  
  N = normalize(U × V)  

We represent a ray by  
  • Origin O = (Ox, Oy, Oz).  
  • Direction D = (Dx, Dy, Dz), assumed normalized (|D| = 1).  

Write a function (in pseudocode or your favorite language) with signature:

    bool intersectSquare(Ray ray, Square square,
                         out float t,
                         out Point  P,
                         out Vector Nout)

that returns true if the ray intersects the square at a distance t > ε (e.g. ε = 1e–4) along the ray, and false otherwise.  On success it also returns the intersection parameter t, the point P = O + t D, and the surface normal Nout (choose the outward‐facing normal).

Part A: Derive the Intersection Test

1.  Plane Intersection  
    •  Compute denom = D · N.  
    •  If |denom| < ε, the ray is parallel to the square’s plane → no hit.  
    •  Compute t = ((C – O) · N) / denom.  
    •  If t ≤ ε, the intersection is behind the ray origin → no hit.

2.  Check Square Bounds  
    •  Compute P = O + t D.  
    •  Express the vector from the center to P in the U–V basis:  
       w = P – C  
       uProj = w · U  
       vProj = w · V  
    •  If |uProj| ≤ L/2 and |vProj| ≤ L/2, P lies inside the square → hit.  
      Otherwise → no hit.

3.  Determine Surface Normal  
    •  If denom < 0, the ray hits the front face → Nout = +N.  
    •  If denom > 0, it hits the back face  → Nout = –N.  
       (This ensures Nout·D ≤ 0 for correct lighting.)

Part B: Pseudocode Template

    function intersectSquare(ray, square,
                             out t, out P, out Nout) -> bool:
        O = ray.origin
        D = ray.direction
        C = square.center
        U = square.U        // unit vector
        V = square.V        // unit vector
        L = square.sideLength

        // 1. Compute square normal
        N = normalize(cross(U, V))

        // 2. Ray–plane intersection
        denom = dot(D, N)
        if abs(denom) < 1e-6:
            return false               // parallel, no hit
        t_temp = dot(C - O, N) / denom
        if t_temp <= 1e-4:
            return false               // behind origin or too close

        // 3. Compute hit point
        P_temp = O + t_temp * D

        // 4. Check within square boundaries
        w = P_temp - C
        uProj = dot(w, U)
        vProj = dot(w, V)
        half = L * 0.5
        if abs(uProj) > half or abs(vProj) > half:
            return false               // outside square

        // 5. Valid intersection
        t = t_temp
        P = P_temp
        if denom < 0:
            Nout = N
        else:
            Nout = -N
        return true

Part C: Test Cases

1.  Axis‐Aligned Square  
    •  C = (0, 0, 5), U = (1, 0, 0), V = (0, 1, 0), L = 2  
    •  Ray origin O = (0, 0, 0), direction D = (0, 0, 1)  
    Expected hit at t = 5, P = (0, 0, 5)

2.  Rotated Square  
    •  C = (0, 0, 5), U = normalize((1, 1, 0)), V = normalize((–1, 1, 0)), L = 2  
    •  Ray origin O = (0, 0, 0), direction D = (0, 0, 1)  
    Expected hit at t = 5, P = (0, 0, 5)

3.  Miss Case  
    •  Same square as in (1)  
    •  Ray origin O = (2, 2, 0), direction D = (0, 0, 1)  
    Expected: no intersection (ray projects outside the square).

For full credit, include commentary on each step, handle the parallel‐ray case robustly, and verify your routine with the above test cases.

############### 2.5 ###############
Ray–Square Intersection  
  
In this exercise you will implement a ray‐square intersection test in 3D.  A square is defined by one of its corners, two edge vectors, and a unit normal.  You must detect whether a ray hits the square (within given t_min, t_max), compute the intersection point, normal, and the local (u,v) coordinates on the square.  
  
Square definition  
– p0: Vec3 — the position of one corner of the square  
– edge1: Vec3 — vector from p0 along one edge (its length equals the side length)  
– edge2: Vec3 — vector from p0 along the adjacent edge (same length)  
– normal: Vec3 (unit) — the square’s outward normal; assume edge1 × edge2 is aligned with normal  
  
Ray definition  
– origin: Vec3 — ray origin  
– direction: Vec3 (unit) — ray direction  
  
HitRecord (to be filled on hit)  
– t: float — ray‐parameter at intersection  
– point: Vec3 — intersection point = origin + t·direction  
– normal: Vec3 — surface normal at intersection (same as square.normal)  
– u, v: float — local barycentric coords on the square, where 0 ≤ u ≤ 1 and 0 ≤ v ≤ 1  
  
Function signature (C++‐style)  
bool intersectSquare(  
    const Ray& ray,  
    float t_min,  
    float t_max,  
    const Square& sq,  
    HitRecord& rec  
);  
  
Requirements  
1. Compute denom = dot(ray.direction, sq.normal).  
   – If |denom| < ε (e.g. 1e–6), ray is parallel to the square’s plane → return false.  
2. Solve for t_plane = dot(sq.p0 – ray.origin, sq.normal) / denom.  
   – If t_plane < t_min or t_plane > t_max → return false.  
3. Compute intersection point P = ray.origin + t_plane·ray.direction.  
4. Express P in the (edge1, edge2) basis:  
     vector v = P – sq.p0  
     u = dot(v, sq.edge1) / dot(sq.edge1, sq.edge1)  
     v_coord = dot(v, sq.edge2) / dot(sq.edge2, sq.edge2)  
   – If u < 0 or u > 1 or v_coord < 0 or v_coord > 1 → P is outside the square → return false.  
5. At this point you have a valid hit. Fill rec with:  
   rec.t = t_plane  
   rec.point = P  
   rec.normal = sq.normal  (optionally flip normal if you want two‐sided or backface culling)  
   rec.u = u  
   rec.v = v_coord  
   return true.  
  
Hints  
• Make sure edge1 and edge2 are orthogonal and of equal length—this guarantees a perfect square.  
• You may choose to treat the square as two‐sided (accept both signs of denom) or one‐sided (only denom < 0 for “front‐face” hits).  
• Use a small epsilon when testing denom against zero to avoid numerical issues.  
  
Example  
Square sq;  
sq.p0     = Vec3(1, 1, 5);  
sq.edge1  = Vec3(2, 0, 0);  // runs from (1,1,5) to (3,1,5)  
sq.edge2  = Vec3(0, 2, 0);  // runs from (1,1,5) to (1,3,5)  
sq.normal = Vec3(0, 0, 1);  
  
Ray ray;  
ray.origin    = Vec3(2, 2, 0);  
ray.direction = Vec3(0, 0, 1);  
  
Calling intersectSquare(ray, 0.001f, INFINITY, sq, rec) should return true with  
rec.t     = 5.0  
rec.point = Vec3(2, 2, 5)  
rec.normal= Vec3(0, 0, 1)  
rec.u     = 0.5  ( halfway along edge1 )  
rec.v     = 0.5  ( halfway along edge2 )  
  
Deliverable  
Provide well‐commented C++ (or language of your choice) code for intersectSquare(…), strictly following the steps above. Make sure your function compiles, handles parallel rays, and correctly rejects points outside the square.

############### 2.6 ###############
Ray‐Square Intersection Programming Exercise

Background  
You are writing a simple ray tracer that already handles ray–plane intersections. Your next task is to extend it to intersect rays with a finite square patch.  

Object Description  
– Square center C = (0, 0, 5) in world space  
– Side length s = 2  
– The square lies in the plane z = 5, with its edges parallel to the x- and y-axes  
– Its four corners are at  
  V₀ = (−1, −1, 5)  
  V₁ = ( 1, −1, 5)  
  V₂ = ( 1,  1, 5)  
  V₃ = (−1,  1, 5)  

Ray Definition  
A ray is given in parametric form:  
  R(t) = O + t·D,  
where  
  O = (Oₓ, Oᵧ, O_z) is the ray origin,  
  D = (Dₓ, Dᵧ, D_z) is the ray direction (assume normalized),  
  t ≥ 0 is the ray parameter.  

Part 1: Plane Intersection  
a) Derive the formula for t at which R(t) intersects the infinite plane z = 5.  
   – Recall that the plane equation is z = 5.  
   – Under what condition on D_z is there no intersection?  

Part 2: Square‐Bounds Check  
Once you have computed t_plane, the intersection point is P = O + t_plane·D. You must now test whether P falls within the square’s x–y bounds:  
  −1 ≤ Pₓ ≤ +1  
  −1 ≤ Pᵧ ≤ +1  
If both hold and t_plane ≥ 0, the ray actually hits the square.  

Part 3: Implementation  
Write a function (in C++-style pseudocode) with this signature:  
  bool intersectSquare(  
    const Vec3& O,         // ray origin  
    const Vec3& D,         // ray direction (normalized)  
    float&    tHit,        // output: smallest positive t of intersection  
    Vec3&     hitNormal    // output: surface normal at hit point  
  );  

Your function should:  
1) Compute t_plane for the plane z = 5.  
2) If D_z is too small (‖D_z‖ < ε), return false.  
3) Compute the point P = O + t_plane·D.  
4) Check the x, y bounds. If inside, set:  
    tHit = t_plane;  
    hitNormal = (0, 0, ±1)  // choose +1 if you want the “front” face normal  
    return true;  
5) Otherwise return false.  

Part 4: Test Cases  
Implement at least these two tests to verify correctness:  
1) Ray O = (0.5, 0.5, 0), D = normalize(0, 0, 1)  
   – Expected: hit at P = (0.5, 0.5, 5), tHit = 5, hitNormal = (0,0,1)  
2) Ray O = (2, 0, 0), D = normalize(0, 0, 1)  
   – Expected: no hit (x=2 is outside [−1,1])  

Optional Extension  
• Compute (u,v) texture coordinates on the square, mapping x∈[−1,1]→u∈[0,1] and y∈[−1,1]→v∈[0,1].  
• Generalize to an arbitrarily oriented square defined by center C, normal N, side length s, and one edge direction.

############### 2.7 ###############
Ray–Square Intersection (Programming Exercise)

In this exercise you will write a function to test and, if it exists, compute the intersection between a 3D ray and a square.  The square may lie in any orientation in space.

1. Definitions  

   • Ray  
     – Origin: O (vec3)  
     – Direction: D (vec3), assumed normalized  

   • Square  
     – Center: C (vec3)  
     – Normal: N (vec3), unit length, perpendicular to the square’s face  
     – Side-direction: U (vec3), unit length, lies in the plane of the square  
       (you may assume U⋅N = 0)  
     – Side length: L (float)  
     – Second in-plane axis: V = N × U  (automatically unit length if N and U are unit and orthogonal)  

2. Intersection Test  

   A ray intersects the infinite plane of the square at  
     t = ( (C – O) ⋅ N )  
         ---------------  
         ( D ⋅ N )  
   provided that D⋅N ≠ 0.  
   • If D⋅N is zero (or very close to zero), the ray is parallel to the plane → no hit.  
   • If t < 0, the intersection lies “behind” the ray’s origin → no hit.  

   Otherwise compute the point of intersection  
     P = O + t * D  

   To decide if P is inside the square, express P–C in the square’s local (U,V) frame:  
     w = P – C  
     uCoord = w ⋅ U  
     vCoord = w ⋅ V  

   P lies inside the square exactly when  
     |uCoord| ≤ L/2   and   |vCoord| ≤ L/2  

3. What to Implement  

   Write a function (in C, C++, Java, or pseudocode) with this signature:  
     bool intersectSquare(  
       Ray    ray,       // { vec3 O, vec3 D }  
       Square sq,        // { vec3 C, vec3 N, vec3 U, float L }  
       out float &tHit,  // distance along ray, if hit  
       out vec3  &P,     // intersection point, if hit  
       out float &uCoord,// local U-coordinate, if hit  
       out float &vCoord // local V-coordinate, if hit  
     );  

   The function should:  
     1. Compute denom = D ⋅ N.  
     2. If |denom| < ε, return false.  
     3. Compute tHit = ((C – O) ⋅ N) / denom.  
     4. If tHit < 0, return false.  
     5. Compute P = O + tHit * D.  
     6. Compute w = P – C; uCoord = w ⋅ U; vCoord = w ⋅ V.  
     7. If |uCoord| ≤ L/2 and |vCoord| ≤ L/2, return true; else return false.  

4. Extensions (optional)  

   • Return normalized UV coordinates in [0,1]² by mapping uCoord,vCoord from [–L/2, L/2] → [0,1].  
   • Handle back-face culling by rejecting hits where denom > 0.  
   • Add tolerance ε when testing |uCoord| ≤ L/2±ε.  

5. Deliverables  

   • Well-commented source or pseudocode of intersectSquare.  
   • Explanation of each step (plane intersection vs. in-square test).  
   • (Optional) A few test cases showing rays that:  
     – Miss by being parallel to the plane  
     – Miss by hitting outside the square’s bounds  
     – Hit exactly on an edge or corner  
     – Hit square face front/back  

Good luck!

############### 2.8 ###############
Ray–Square Intersection (Programming Exercise)

In this exercise you will implement the function that tests a ray against a single square in 3D space.  The square is finite (has a well‐defined side length), lies in an arbitrary plane, and is uniquely described by:

 •  center C  (a point in ℝ³)  
 •  unit normal N  (a nonzero vector in ℝ³, ‖N‖=1)  
 •  unit “axis” U  (a vector in ℝ³, ‖U‖=1, U⋅N = 0)  
 •  side length L  (a positive real)  

From these you may compute the square’s second in‐plane axis V = N × U (which is also unit length and perpendicular to both N and U).  The four corners of the square lie at  
   C ± (L/2)·U ± (L/2)·V  

We represent a ray by  
   Ray { Vector3 origin O; Vector3 dir D; float tMin, tMax; }  
where D is assumed normalized (‖D‖=1) and a hit at ray‐parameter t is valid only if tMin ≤ t ≤ tMax.

Your task is to write:

    bool intersectSquare(const Square& sq,
                         const Ray& ray,
                         Intersection& isect);

where Intersection holds at least  
  •  float t;                // ray‐parameter of intersection  
  •  Vector3 p;              // intersection point  
  •  Vector3 n;              // surface normal (unit)  
  •  float u, v;             // local 2D coordinates (optional)  

Return true if and only if the ray hits the (finite) square between tMin and tMax; fill isect with the correct t, p, n, and (optionally) u,v coordinates in [0,1] across the square.

------------------------------------------------------------------------
Part A.  Mathematical Derivation

1.  Compute denominator:  
       denom = D ⋅ N  
    If denom is very small (|denom| < ε), the ray is parallel to the square’s plane ⇒ no intersection.

2.  Compute parameter t at which the ray’s point O + t·D lies in the plane of the square:  
       t = ((C – O) ⋅ N) / denom  
    If t < ray.tMin or t > ray.tMax, reject (intersection is out of range).

3.  Compute the candidate intersection point:  
       P = O + t·D

4.  Express P in the square’s local (U,V) basis:  
       Dlocal = P – C  
       uL = Dlocal ⋅ U  
       vL = Dlocal ⋅ V  

   The ray hits the *finite* square if and only if  
       |uL| ≤ L/2   and   |vL| ≤ L/2  

5.  If hit succeeds, set  
       isect.t = t  
       isect.p = P  
       isect.n = N    (if denom > 0 you may want to flip to −N so that n always faces against D)  
       isect.u = (uL / L) + 0.5  
       isect.v = (vL / L) + 0.5  

Part B.  Implementation

Below is a suggested C++‐style skeleton.  You may adapt names or types to your own codebase:

    struct Vector3 { float x,y,z;
        // ... constructors, dot, cross, operator+, operator*, normalize, etc.
    };

    struct Ray {
        Vector3 origin;
        Vector3 dir;   // assume normalized
        float tMin, tMax;
    };

    struct Square {
        Vector3 center;   // C
        Vector3 normal;   // N, unit length
        Vector3 axisU;    // U, unit length and perpendicular to normal
        float   side;     // L, > 0
    };

    struct Intersection {
        float   t;
        Vector3 p;
        Vector3 n;
        float   u, v;     // in [0,1], optional
    };

    bool intersectSquare(const Square& sq,
                         const Ray& ray,
                         Intersection& isect)
    {
        // 1. Plane intersection test
        float denom = dot(ray.dir, sq.normal);
        if (fabs(denom) < 1e-6f) 
            return false;  // Ray is parallel to the plane

        // 2. Compute t
        float t = dot(sq.center - ray.origin, sq.normal) / denom;
        if (t < ray.tMin || t > ray.tMax)
            return false;

        // 3. Compute intersection point P
        Vector3 P = ray.origin + ray.dir * t;

        // 4. Compute local coordinates in U/V
        Vector3 axisV = cross(sq.normal, sq.axisU);  // V = N × U
        float uL = dot(P - sq.center, sq.axisU);
        float vL = dot(P - sq.center, axisV);

        // 5. Test bounds against half‐side
        float h = sq.side * 0.5f;
        if (uL < -h || uL > +h || vL < -h || vL > +h)
            return false;

        // 6. Fill intersection record
        isect.t = t;
        isect.p = P;
        // Ensure normal faces against the ray’s direction
        isect.n = (denom < 0.0f ? sq.normal : -sq.normal);
        // Map to [0,1]
        isect.u = (uL / sq.side) + 0.5f;
        isect.v = (vL / sq.side) + 0.5f;

        return true;
    }

------------------------------------------------------------------------
What to hand in
 •  A short write‐up showing your derivation of steps 1–5.  
 •  Well‐commented source code for your `intersectSquare(…)`.  
 •  A few rendered test images or console output showing:  
      – A ray hitting the center of the square (u=v=0.5)  
      – A ray grazing each of the four edges.  
      – A ray just missing the square.  

Grading will emphasize correctness of the math, robustness to parallel rays, and proper handling of the square’s finite extent.

############### 2.9 ###############
Ray-Square Intersection (Programming Exercise)

Background  
In a basic ray tracer you must detect when and where a ray hits various primitives.  In this exercise you will implement intersection against a *square* in 3D space.  A square is like a finite, planar quad with four equal sides.

Square Representation  
We define a square by the following parameters:  
 • center C (Vector3)  
 • two perpendicular, unit‐length edge‐directions u and v (Vector3), so that u·v = 0 and |u|=|v|=1  
 • side length s (float > 0)  

The four corners of the square lie at  
   C ± (s/2)·u ± (s/2)·v  

The square’s surface normal is  
   n = u × v  
(you may assume u×v is already normalized because u and v are orthonormal).

Ray Representation  
A ray R is given by  
   R(t) = O + t·D,   t ≥ 0  
where O is the ray origin (Vector3) and D is a normalized direction (Vector3).

Task  
Write a function with this signature (you may adjust types to match your codebase):

  bool intersectSquare(
      const Ray&    ray,
      const Square& square,
      float&        tHit,      // output: distance along ray
      Vector3&      hitNormal  // output: surface normal at hit
  );

The function should return true if and only if the ray intersects the square at some t > 0.  On success it must set:

 • tHit   = the smallest positive t at which the ray hits the square’s plane  
 • hitNormal = n (the square’s outward normal—choose the sign so that hitNormal·D < 0)

If there is no intersection (miss or parallel), return false.

Outline / Hints  
1. Compute denom = D·n.  
   • If |denom| < ε (e.g. 1e-6), the ray is parallel to the square’s plane → return false.  

2. Compute tPlane = ( (C – O) · n ) / denom.  
   • If tPlane ≤ 0 → the intersection is behind or at the origin → return false.  

3. Compute the plane‐intersection point  
      P = O + tPlane·D  

4. In the square’s local (u,v) basis, express the vector from the center to P:  
      w = P – C  
      α = w·u  
      β = w·v  

5. Check bounds:  
   • If |α| ≤ s/2 and |β| ≤ s/2 → the point lies inside the square →  
        set tHit = tPlane;  
        set hitNormal = (denom < 0 ?  n : −n);  
        return true;  
   • Otherwise → return false.

Deliverables  
 • Your implementation of intersectSquare(…) in the language of your choice, based strictly on the outline above.  
 • Brief comments explaining each major step (plane intersection, bound checks).  

Evaluation Criteria  
 • Correctness: ray versus square plane, t > 0, bound checks.  
 • Robustness: handles parallel rays, edge cases.  
 • Code clarity: well‐named variables and comments.

############### 3.0 ###############
Ray–Cylinder Intersection (Programming Exercise)

Background  
You will extend your ray tracer with support for finite, closed cylinders. A cylinder in our scene is defined by:

 •  A central axis aligned with the world-space y-axis.  
 •  A radius R > 0.  
 •  A vertical extent from y = y₀ (bottom cap) up to y = y₁ (top cap), with y₁ > y₀.  
 •  Two circular end caps (planes) at y = y₀ and y = y₁.  

A ray is defined as  
    P(t) = O + t·D,  
where O is the ray origin, D is a normalized direction vector, and t ≥ 0.

Your task  
1.  Derive the equations needed to compute intersections of the ray P(t) with:  
    a.  The infinite cylindrical “tube” (i.e. ignoring caps).  
    b.  The two planar caps.  

2.  Implement a function that, given a ray and a cylinder, returns the nearest positive intersection (if any). For that intersection you must also compute the correct surface normal:

    •  On the curved side the normal is (x, 0, z) normalized.  
    •  On the caps it is (0, ±1, 0) depending on bottom or top.

Function signature (in C++-style pseudocode)

    struct Ray { Vec3 O, D; };         // D is normalized
    struct Hit { float t; Vec3 P, N; /* t: parameter, P: point, N: normal */ };
    struct Cylinder {
      float radius;    // R
      float yMin, yMax; // y₀, y₁  (yMax > yMin)
    };

    // Returns true if the ray hits the finite, closed cylinder.
    // On hit, fills 'out' with the nearest positive t, hit point, and normal.
    bool intersectCylinder(const Ray& ray,
                           const Cylinder& cyl,
                           Hit& out);

Requirements

 • Only consider t > 0 (ignore t ≤ 0).  
 • If the ray intersects both side and cap surfaces, report the hit with the smallest positive t.  
 • If the ray is parallel to a cap plane, it must not count as an intersection with that cap.  
 • Use an ε (epsilon) of 1e–6 when comparing floating‐point values to zero.  

Hints

 • For the side surface:  
     – Project the problem to the x–z plane.  
     – Solve a quadratic at² + bt + c = 0 where  
         a = Dx² + Dz²  
         b = 2(Ox·Dx + Oz·Dz)  
         c = Ox² + Oz² – R²  
     – Check each root t>ε in ascending order, then compute Py = Oy + t·Dy; accept it only if yMin ≤ Py ≤ yMax.  

 • For the caps at y = yMin or yMax:  
     – Solve t such that Oy + t·Dy = yCap ⇒ t = (yCap – Oy)/Dy, provided |Dy|>ε.  
     – Compute Px = Ox + t·Dx, Pz = Oz + t·Dz and accept only if Px² + Pz² ≤ R².  

Deliverables

 • A short derivation of your intersection equations.  
 • The implemented function intersectCylinder.  

Test cases (suggested)

 1.  Ray from (0,0,–5) toward (0,0,1): should hit the bottom cap at t≈5.  
 2.  Ray from (R+1, (yMin+yMax)/2, 0) toward (−1,0,0): should hit the side.  
 3.  Ray from (0,yMax+1,0) straight down: should hit the top cap.  

Be sure your code handles all edge‐cases correctly (no negative or NaN ts).

############### 3.1 ###############
Ray–Cylinder Intersection (Including End Caps)

Background  
In this exercise you will implement a routine that tests a ray against a finite cylinder (with flat circular end caps).  The cylinder is defined by a center point C, a unit‐length axis direction A, a radius R, and a total height H.  Its lateral surface runs between the two end‐cap centers  
  C₁ = C – (H/2)·A  
  C₂ = C + (H/2)·A  
Each end cap is the disk of radius R lying in the plane whose normal is A at C₁ or C₂.

Ray  
A ray is given by  
  O = ray origin (vector)  
  D = ray direction (unit vector)  
The ray’s parametric form is P(t) = O + t·D, with t ≥ 0.

Your Task  
Write a function (or equivalent pseudocode) that computes the nearest intersection of P(t) with this finite capped cylinder.  If there is a hit, return:  
• t_hit = the smallest t > 0 at which P(t) lies on the cylinder’s lateral surface or on one of its end caps  
• P_hit = O + t_hit·D (the 3D position)  
• N_hit = the outward‐pointing normal at P_hit  

If the ray misses both the lateral surface and the caps, return “no intersection.”

Requirements  
1.  Derive and solve the quadratic equation for intersection with the infinite cylinder’s lateral surface.  Recall that a point X lies on the infinite cylinder of axis A through C if  
  ‖(X – C) – [(X – C)·A] A‖² = R².  
2.  From the two roots t₁, t₂ of that quadratic, choose the smallest t > 0 for which P(t) lies between the planes of the end caps.  Equivalently, if y = (P(t) – C)·A, require –H/2 ≤ y ≤ H/2.
3.  If neither t₁ nor t₂ yields a valid lateral hit, test intersection with the two end caps:  
 a.  For each end‐cap plane (at C₁ and C₂), solve t_plane from (O + tD – Cᵢ)·A = 0.  
 b.  Check t_plane > 0 and whether ‖(O + t_plane·D – Cᵢ) – [(O + t_plane·D – Cᵢ)·A]A‖ ≤ R.
4.  Among all valid t’s (lateral and both caps), pick the smallest and compute P_hit and N_hit.  
 • If the hit is on the lateral surface, the normal is  
  N_hit = normalize( (P_hit – C) – [(P_hit – C)·A] A ).  
 • If the hit is on an end cap at Cᵢ, the normal is ±A: use +A for the “top” cap at C₂, –A for the “bottom” cap at C₁.

Deliverables  
• Clear derivation of the cylinder‐surface quadratic (coefficients a, b, c).  
• Code or pseudocode for your `intersectRayCylinder` function, showing how you:  
 – compute and test t₁, t₂ for the infinite cylinder,  
 – check y = (P(t)–C)·A for height bounds,  
 – test both caps,  
 – choose the nearest valid intersection and compute the correct normal.  
• A brief explanation (1–2 sentences) of how you handle the case when the ray origin starts inside the cylinder volume.

Assumptions  
 • All vectors are in 3D and operations such as dot(), subtract(), length(), normalize() are available.  
 • D and A are already unit‐length; you need not renormalize them in your routine.  
 • Floating‐point epsilon issues can be ignored (you need not add small bias terms).

Grading Criteria  
 • Correct quadratic setup and solution for the lateral surface.  
 • Proper height‐range check for lateral intersections.  
 • Correct end‐cap intersection logic and radius check.  
 • Accurate selection of the nearest positive t and corresponding normal.  
 • Code clarity and comments explaining each step.

############### 3.2 ###############
Ray–Cylinder Intersection (Finite, Capped)  
==========================================

In this exercise you will implement ray‐intersection against a finite, straight cylinder (including its two circular end‐caps).  The cylinder is defined uniquely by:  
  • Base center point C (3D vector)  
  • Axis direction unit‐vector D (|D|=1), pointing from the base toward the top  
  • Height H > 0  
  • Radius R > 0  

A ray is  
  R(t) = O + t·V,  
where O is the ray origin, V is a normalized direction (|V|=1), and t ≥ 0.

Your task: write a function  
  bool hitCylinder(  
    const Ray&       ray,        // { origin O, direction V }  
    const Cylinder&  cyl,        // { C, D, H, R }  
    float            t_min,      // minimum t to consider  
    float            t_max,      // maximum t to consider  
    HitRecord&       rec         // on hit: t, point P, normal N  
  );  

that returns true if the ray hits the finite cylinder (lateral surface or caps) in [t_min, t_max], and fills rec with the nearest hit.  Otherwise return false.

Detailed steps / hints
----------------------

1. Intersection with the infinite lateral surface  
   Let w = O – C.  Decompose V and w into components perpendicular to the axis D:  
     V⊥ = V – (V·D) D  
     w⊥ = w – (w·D) D  
   The ray hits the infinite cylinder of radius R when  
     |w⊥ + t V⊥|² = R².  
   Expand to a quadratic in t:  
     a = V⊥·V⊥  
     b = 2 (V⊥·w⊥)  
     c = w⊥·w⊥ – R²  
     → a t² + b t + c = 0.  
   Solve for real roots t₁, t₂; reject if a ≈ 0 (ray parallel to axis) or discriminant < 0.  
   For each root tᵢ in [t_min, t_max], compute Pᵢ = O + tᵢ V and project onto the axis:  
     y = (Pᵢ – C)·D.  
   Accept this hit only if 0 ≤ y ≤ H.

2. Intersection with the end caps  
   The two cap planes are:  
     Plane 1: passing through C, normal = –D  
     Plane 2: passing through C + H·D, normal = +D  
   For each plane with point P₀ and normal Ncap (±D):  
     denom = V·Ncap;  
     if |denom| < ε skip (ray parallel to cap).  
     t = (P₀ – O)·Ncap / denom.  
     if t ∉ [t_min, t_max] skip.  
     Compute P = O + t·V;  
     if |(P – P₀) – [(P – P₀)·Ncap] Ncap| ≤ R, it lies inside the circular cap—accept this hit.

3. Choose the nearest valid hit  
   Among all candidate t’s from step 1 and 2, pick the smallest t ≥ t_min.  If none, return false.  
   Otherwise fill rec:  
     rec.t      = t_best  
     rec.P      = O + t_best·V  
     rec.normal = (if lateral‐surface hit)  
                      normalize( (rec.P – C) – [((rec.P – C)·D)·D] )  
                    else (cap hit)  
                      ±D  (the cap’s normal, choose +D for top cap, –D for bottom)  
   Return true.

What to hand in
---------------  
• Your complete implementation of hitCylinder(…) in your favorite language (C++/Java/Python).  
• A brief derivation of the quadratic coefficients for the lateral‐surface test.  
• A few test cases (rays that hit the side, hit only the top cap, miss entirely, graze exactly at y=0 or y=H).  
• (Optional) UV parameterization of the cylinder surface for texturing.

Grading criteria
----------------  
• Correctness of intersection logic (lateral vs. caps).  
• Handling of edge‐cases (ray parallel to axis, grazing hits on boundary).  
• Proper normal calculation and correct t‐value ordering.  
• Code clarity and comments.

############### 3.3 ###############
Ray–Object Intersection: Finite, Closed Cylinder

Background  
A right circular cylinder of radius R = 1.0 and finite height H = 2.0 is centered at the world‐space origin and aligned with the y–axis.  Its lateral surface runs from y = −1.0 up to y = +1.0.  The cylinder is closed: it has two flat caps in the planes y = −1.0 and y = +1.0.

Ray  
A ray is given by  
  R(t) = O + t D,   t ≥ 0  
where O = (Ox, Oy, Oz) is the ray origin and D = (Dx, Dy, Dz) is a unit‐length direction vector.

Task  
1.  Derive the mathematical tests for intersections of R(t) with  
 a.  the lateral (curved) surface of the cylinder  
 b.  the top and bottom caps (planes y = +1, y = −1)  
2.  Implement a function in C++ (or pseudocode) with signature  
   
  struct Ray { Vec3 origin; Vec3 direction; };  
  struct HitRecord {  
   float t;       // ray parameter  
   Vec3  p;       // intersection point  
   Vec3  normal;  // surface normal at p  
  };  

  bool hitCylinder(  
   const Ray& ray,  
   float t_min,       // e.g. 0.001  
   float t_max,       // e.g. +∞  
   HitRecord& rec  
  );  

   that computes the nearest valid intersection in the interval [t_min, t_max] and, if one exists, fills in rec.t, rec.p and rec.normal, then returns true.  If there is no intersection in [t_min, t_max], it returns false.

Requirements & Hints  
A.  Lateral Surface  
 1.  The cylinder’s lateral surface satisfies x² + z² = R² for −1 ≤ y ≤ +1.  
 2.  Substitute x = Ox + t Dx,  z = Oz + t Dz into x² + z² = 1, giving a quadratic  
   a t² + b t + c = 0  
  where  
   a = Dx² + Dz²  
   b = 2(Ox Dx + Oz Dz)  
   c = Ox² + Oz² − 1  
 3.  Solve for real roots t₁, t₂.  For each positive root t in [t_min, t_max], compute y = Oy + t Dy.  If −1 ≤ y ≤ +1, that t is a valid hit.  

B.  End‐Cap Surfaces  
 1.  Each cap is a disk in the plane y = y_cap (y_cap = +1 or −1).  
 2.  Solve t = (y_cap − Oy)/Dy (provided Dy ≠ 0).  
 3.  Compute x = Ox + t Dx, z = Oz + t Dz.  If x² + z² ≤ 1 and t in [t_min, t_max], it is a valid hit.  

C.  Choosing the Nearest Hit  
 1.  Collect all valid t’s from lateral surface and caps.  
 2.  Pick the smallest t ≥ t_min.  

D.  Surface Normals  
 •  On the lateral surface at p = (px, py, pz), normal = normalize((px, 0, pz)).  
 •  On the top cap (y = +1), normal = (0, +1, 0).  
 •  On the bottom cap (y = −1), normal = (0, −1, 0).  

Deliverables  
1.  A clear derivation of the lateral‐surface quadratic and the cap‐plane intersections.  
2.  A complete implementation of hitCylinder(…) that:  
 – Computes and tests ALL candidate t’s  
 – Determines the nearest valid hit in [t_min, t_max]  
 – Fills in rec.t, rec.p, rec.normal correctly  
 – Returns true if hit found, false otherwise  

Evaluation Criteria  
• Mathematical correctness of the derivation  
• Code correctness, clarity, and handling of edge cases (e.g. ray parallel to caps)  
• Proper bounding of y for the curved surface and radius for the caps  
• Correct normal computation for shading downstream

############### 3.4 ###############
Programming Exercise: Ray–Cylinder Intersection

Description  
You must implement a function that tests a ray against a finite right‐circular cylinder (including its two flat end caps).  If the ray hits the cylinder, you should return the nearest hit point, the surface normal at that point, and the ray parameter t; otherwise you return “no hit.”

Object and Ray Definitions  
1. Cylinder  
   • base center C (3D point)  
   • unit‐length axis direction A (3D vector)  
   • radius r > 0  
   • height h > 0  
   – Top cap center = C + A * h  
2. Ray  
   • origin O (3D point)  
   • unit‐length direction D (3D vector)  

Intersection Record  
struct Intersection {  
  float t;      // ray parameter  
  Vec3  P;      // hit point = O + t*D  
  Vec3  N;      // unit normal at P  
};  

Function Signature  
bool intersectCylinder(  
  const Ray& ray,  
  const Cylinder& cyl,  
  Intersection& outHit  
);  

Requirements  
1. Side‐wall intersection  
   a. Define Q = O – C  
   b. Remove the component along the axis:  
      V = D – dot(D,A)*A  
      W = Q – dot(Q,A)*A  
   c. Build quadratic A2·t² + B2·t + C2 = 0:  
      A2 = dot(V,V)  
      B2 = 2·dot(V,W)  
      C2 = dot(W,W) – r*r  
   d. Solve for real roots t; for each t>0 compute P = O + t·D and check  
      proj = dot(P–C, A) ∈ [0, h]  
   e. Valid side‐hits yield normal N = normalize((P–C) – proj·A)  

2. End‐cap intersections (k=0 for bottom, k=h for top)  
   For each cap center Cp = C + A*k:  
     denom = dot(D, A)  
     if (denom ≠ 0):  
       tcap = dot(Cp – O, A) / denom  
       if (tcap > 0):  
         P = O + tcap·D  
         if (|P – Cp| ≤ r):  
           cap‐hit is valid with normal N = (denom>0 ? –A : +A)  

3. Choose the smallest positive t among all valid hits.  
   • Fill outHit.t = tmin  
   • outHit.P = O + tmin·D  
   • outHit.N = corresponding normal  

Deliverables  
1. A one‐page derivation of the quadratic formula for the cylinder’s side and the formula for the caps.  
2. A commented C++ (or Java/C#/pseudo-C++) implementation of intersectCylinder as specified above.  
3. Brief explanation of how you handle edge cases (ray parallel to axis, ray starts inside the cylinder, etc.).

############### 3.5 ###############
Ray–Cylinder Intersection (Programming Exercise)

Background  
We represent rays and simple scene‐primitives in C++, using these helper classes (you may adapt them to your own code style):

```cpp
// 3D vector
struct Vec3 {
    float x, y, z;
    Vec3() : x(0), y(0), z(0) {}
    Vec3(float xx, float yy, float zz): x(xx), y(yy), z(zz) {}
    Vec3 operator+(const Vec3& v) const;
    Vec3 operator-(const Vec3& v) const;
    Vec3 operator*(float t) const;
    Vec3 operator/(float t) const;
    float dot(const Vec3& v) const;
    Vec3 normalized() const;
    // … (other utility methods as needed)
};

// Ray: P(t) = origin + t·direction
struct Ray {
    Vec3 origin;
    Vec3 direction;
    Ray(const Vec3& o, const Vec3& d): origin(o), direction(d) {}
    Vec3 at(float t) const { return origin + direction * t; }
};

// Record to store hit‐point info
struct HitRecord {
    float t;         // ray parameter
    Vec3  p;         // hit point
    Vec3  normal;    // surface normal at hit
    // … (material pointer, etc, if you use one)
};

// Abstract base for hittable objects
class Hittable {
public:
    virtual bool intersect(const Ray& r,
                           float t_min, float t_max,
                           HitRecord& rec) const = 0;
};
```

Exercise  
Implement the method

```cpp
class Cylinder : public Hittable {
public:
    float y0, y1;    // minimum and maximum y of the cylinder
    float radius;    // cylinder radius
    // (you may add a pointer to material, if desired)

    Cylinder(float bottom, float top, float r)
      : y0(bottom), y1(top), radius(r) {}

    // Return true if ray hits the finite, closed cylinder
    // (including its top and bottom caps). If it hits, fill rec.
    virtual bool intersect(const Ray& r,
                           float t_min, float t_max,
                           HitRecord& rec) const override;
};
```

Your task is to fill in `Cylinder::intersect` so that:

1. You detect intersection with the **side surface** of the finite cylinder defined by  
   x² + z² = radius²,  y ∈ [y0, y1].

2. You detect intersection with the **end caps** (the disks in the planes y = y0 and y = y1), each of radius = radius.

3. Among all valid intersections t, you choose the smallest t in the interval [t_min, t_max].

4. If a hit is found, you store in `rec`:
   • `rec.t` = the ray parameter t of the hit  
   • `rec.p` = point of intersection = r.at(t)  
   • `rec.normal` = outward normal of the surface at that point  
     – For the side: (x, 0, z) normalized  
     – For the bottom cap (y=y0): (0, –1, 0)  
     – For the top cap (y=y1): (0, +1, 0)

Outline of the solution steps  
1. **Side intersection**  
   • Solve for t in the quadratic equation  
     (rx + t·dx)² + (rz + t·dz)² = radius²  
     i.e.  
     A t² + B t + C = 0  
     with  
        A = dx² + dz²  
        B = 2 (ox·dx + oz·dz)  
        C = ox² + oz² – radius²  
     where (ox, oz) = (r.origin.x, r.origin.z), (dx, dz) = (r.direction.x, r.direction.z).  
   • Compute discriminant. If ≤0, no real root → no hit on infinite cylinder.  
   • Otherwise compute the two roots t0 < t1. For each t ∈ {t0, t1}:  
     – Check if t ∈ [t_min, t_max]  
     – Compute y = r.origin.y + t·r.direction.y; if y0 ≤ y ≤ y1, it hits the side.  
     – Keep the smallest valid t.

2. **Cap intersections**  
   For each cap at y = y_cap (y0 or y1):  
   • Solve t = (y_cap – origin.y) / direction.y.  
   • Check t ∈ [t_min, t_max].  
   • Compute p = r.at(t). If (p.x)² + (p.z)² ≤ radius², it's inside the disk → candidate hit.  
   • Compare t to your current best t and keep the smaller one.

3. **Fill HitRecord**  
   After you’ve tested both the side and the two caps, if you have found any valid hit t_hit:  
   • rec.t = t_hit  
   • rec.p = r.at(t_hit)  
   • rec.normal = (determine based on which surface was hit)  

Requirements  
• Your code must handle the case when the ray is parallel to the cylinder’s axis (dx²+dz²=0 or direction.y=0).  
• Make sure to update t_max or track your closest t carefully so you always return the nearest intersection.  
• Do not produce “false” hits very close to t=0 (you may enforce t > t_min + ε if you wish).  
• The normals must point outward consistently.

Deliverables  
• The fully implemented `Cylinder::intersect` method, tested against rays that:  
  – miss entirely,  
  – hit only the side,  
  – hit only one cap,  
  – graze the rim,  
  – originate inside the cylinder.  
• (Optional) A few unit tests showing correctness in each scenario.

Good luck!

############### 3.6 ###############
Ray‐Cylinder Intersection (Finite, Closed Cylinder)  

Background  
We have a finite (capped) cylinder whose central axis is aligned with the world‐space y–axis.  The cylinder is defined by:  
 • radius r > 0  
 • minimum y‐value yMin  
 • maximum y‐value yMax, with yMax > yMin  

Thus the cylinder’s side surface consists of all points (x,y,z) satisfying  
 x² + z² = r²    and    yMin ≤ y ≤ yMax  
and its top and bottom caps lie in the planes y = yMax and y = yMin (disk of radius r).

We shoot a ray  
 Ray:  O + tD,  t ≥ 0  
where O = (Ox,Oy,Oz) is the ray origin and D = (Dx,Dy,Dz) is a normalized direction vector.

Task  
Implement in C++ (or your language of choice) a function  

 bool intersectCylinder(  
  const Ray&     ray,     // ray origin O and normalized direction D  
  const Cylinder& cyl,     // cylinder.r, cyl.yMin, cyl.yMax  
  float&         tHit,     // output: ray parameter at hit  
  Vec3&          hitNormal // output: surface normal at hit point  
 );

that returns true if the ray intersects the cylinder (side or caps) at some t > ε (e.g. ε = 1e–4), and false otherwise.  On success, tHit must be set to the smallest positive intersection t and hitNormal to the outward unit normal at the hit point.

Requirements  

1. Side‐Surface Intersection  
   • Solve the quadratic in t for intersections with the infinite cylinder x² + z² = r²:  
     A = Dx² + Dz²  
     B = 2(Ox·Dx + Oz·Dz)  
     C = Ox² + Oz² – r²  
     Δ = B² – 4AC  
     If Δ < 0, no side intersection; otherwise compute the two roots t₀ ≤ t₁.  
   • For each root tᵢ > ε (in ascending order), compute yᵢ = Oy + tᵢ·Dy.  
     If yMin ≤ yᵢ ≤ yMax, accept this as the hit:  
       hitPoint = O + tᵢ·D  
       hitNormal = normalize( (hitPoint.x, 0, hitPoint.z) )  
       tHit = tᵢ; return true.  

2. Cap Intersections  
   • If no valid side‐hit was found, intersect the ray with the planes y = yMin and y = yMax:  
     tCap = (yPlane – Oy) / Dy,  provided Dy ≠ 0.  
   • For each cap (bottom then top), if tCap > ε:  
       Px = Ox + tCap·Dx  
       Pz = Oz + tCap·Dz  
       if Px² + Pz² ≤ r², accept:  
         hitPoint = (Px, yPlane, Pz)  
         hitNormal = (0, –1, 0) for y = yMin, or (0, +1, 0) for y = yMax  
         tHit = tCap; return true.  

3. If neither side nor cap yields a valid t > ε, return false.

Deliverables  
 • Complete source code for intersectCylinder() (and any helper functions).  
 • Brief comments explaining each major step.  
 • A short test (e.g. one ray intersecting the side and one intersecting a cap) with printed tHit and hitNormal to demonstrate correctness.  

You may assume Vec3 supports basic operations (+, –, ·, length, normalize) and that Ray and Cylinder structs are already defined as follows:  

struct Vec3 { float x,y,z; /* … */ };  
struct Ray  { Vec3 O, D; /* D is normalized */ };  
struct Cylinder {  
  float r;     // radius  
  float yMin;  // bottom cap at y = yMin  
  float yMax;  // top cap at y = yMax  
};  

Good luck!  Be sure to handle edge cases (ray parallel to caps, discriminant ≈ 0, etc.) and pick the minimal positive t.

############### 3.7 ###############
Ray‐Cylinder Intersection (Finite, Closed Cylinder)

In this problem you will implement ray‐intersection against a finite, closed cylinder of radius R and height H, whose central axis is aligned with the world‐space y‐axis and whose center sits at the origin (0,0,0).  The cylinder therefore extends from y = –H/2 to y = +H/2 and includes both circular end‐caps.

1. Data Structures  
   Assume you have:  
   • struct Ray {  
       Vec3 origin;      // ray origin  
       Vec3 direction;   // normalized ray direction  
     };  
   • struct HitRecord {  
       float t;          // ray parameter at hit  
       Vec3 p;           // hit point  
       Vec3 normal;      // surface normal at hit  
       bool frontFace;   // true if ray and normal face each other  
     };  

   And a helper that sets the face orientation for shading:  
     void setFaceNormal(const Ray &r, const Vec3 &outwardNormal, HitRecord &rec) {  
       rec.frontFace = dot(r.direction, outwardNormal) < 0;  
       rec.normal = rec.frontFace ? outwardNormal : -outwardNormal;  
     }  

2. Cylinder Parameters  
   Let R = 1.0 (radius)  
       H = 2.0 (height)  
   Thus y ∈ [–1, +1].

3. Function Signature  
   Implement this function:  
     bool intersectCylinder(  
         const Ray &ray,         // input ray  
         float tMin,             // minimum valid t  
         float tMax,             // maximum valid t  
         HitRecord &rec          // output hit record  
     );  
   Return true if there is any hit in [tMin, tMax], filling rec with the nearest hit.

4. What to Compute  
   a) Side surface: solve for t in  
       (ox + t·dx)² + (oz + t·dz)² = R²  
     where (ox,oy,oz)=ray.origin and (dx,dy,dz)=ray.direction.  
     - Check each real root t for tMin ≤ t ≤ tMax.  
     - Compute hit point p and verify its y‐coordinate is in [–1, +1].  
     - If valid, record tSide, pSide, and normalSide = normalize((px, 0, pz)).  

   b) End caps: two disks in planes y = +1 and y = –1.  
     For each cap at y = yc ∈ {+1, –1}:  
       tCap = (yc – oy) / dy  
     Check tMin ≤ tCap ≤ tMax.  
     Compute p = ray.origin + tCap·ray.direction, then check x² + z² ≤ R².  
     If valid, normalCap = Vec3(0, sign(yc), 0).

5. Algorithm  
   1. Compute the smallest valid t among side hits and cap hits.  
   2. Fill rec.t, rec.p, and call setFaceNormal(ray, chosenOutwardNormal, rec).  
   3. Return true if any hit found, otherwise false.

6. Example Test Cases  
   (a) Ray from (0, 0, –5) in direction (0, 0, +1):  
       • Side intersections at t=4 and t=6; pick t=4.  
       • Hit point p=(0,0,–1), normal=(0,0,–1).  

   (b) Ray from (0, 2, 0) in direction (0, –1, 0):  
       • No side hit (dx=dz=0).  
       • Cap hit at y=+1: t=(1–2)/(–1)=1.  
       • Hit point p=(0,1,0), normal=(0,+1,0).  

   (c) Ray from (2, 0, 0) in direction (–1, 0, 0):  
       • Side intersections at t=1 (enter) and t=3 (exit), both y=0 ∈ [–1,+1].  
       • Pick t=1, p=(1,0,0), normal=(+1,0,0).

Your task is to implement intersectCylinder() following the above specification. Be sure to handle the case where the ray is parallel to the cylinder axis (dy ≈ 0) correctly so you don’t divide by zero in your cap‐tests or misreport side‐hits.

############### 3.8 ###############
Ray–Cylinder Intersection (Finite Cylinder with End Caps)

In this exercise you will write a function that computes the first intersection (if any) between a ray and a finite right circular cylinder whose axis is aligned with the world-space y-axis.  Your routine should also compute the outward-pointing surface normal at the hit point.

------------------------------------------------------------
Cylinder Description
------------------------------------------------------------
• Axis: parallel to the y-axis  
• Radius: R (a positive scalar)  
• Height: extends from y = yMin to y = yMax (with yMax > yMin)  
• Side surface plus flat circular end caps at y = yMin and y = yMax  

Mathematically, a point P = (x, y, z) lies on the cylinder’s side if  
   x² + z² = R²   and   yMin ≤ y ≤ yMax.  
Points on the caps satisfy  
   x² + z² ≤ R²   and   y = yMin  (bottom cap)  
   x² + z² ≤ R²   and   y = yMax  (top    cap)

------------------------------------------------------------
Ray Representation
------------------------------------------------------------
A ray is given by  
   R(t) = O + t·D,   t ≥ 0,  
where O = ray origin (Vec3), D = normalized ray direction (Vec3).

Your function signature (in C++-style pseudocode) might look like:

  bool intersectCylinder(
      const Vec3& O,           // ray origin
      const Vec3& D,           // ray direction (unit length)
      float      R,            // cylinder radius
      float      yMin,         // minimum y
      float      yMax,         // maximum y
      float      tMin,         // lower bound on t (e.g. 0.001f)
      float      tMax,         // upper bound on t (e.g. +∞)
      float&     tHit,         // output: ray parameter at intersection
      Vec3&      hitNormal     // output: surface normal at hit
  );

Return true if an intersection is found with t in [tMin, tMax]; set tHit to the smallest such t and hitNormal to the corresponding outward normal. Return false otherwise.

------------------------------------------------------------
Part A: Side‐Surface Intersection
------------------------------------------------------------
1.  Restrict attention to the infinite cylinder x² + z² = R².  Substitute  
        x = Ox + t·Dx,   z = Oz + t·Dz  
    into x² + z² = R² to get a quadratic in t:
        a·t² + b·t + c = 0,
    where  
        a = Dx² + Dz²  
        b = 2·(Ox·Dx + Oz·Dz)  
        c = Ox² + Oz² – R².  
2.  Compute the two roots t0, t1 of this quadratic (if they exist and are real).  
3.  For each root in ascending order, check:
     • Is t in [tMin, tMax]?  
     • Does the corresponding y = Oy + t·Dy satisfy yMin ≤ y ≤ yMax?  
   If so, record this t and compute the normal on the side:  
       N = normalize( (Ox + t·Dx, 0, Oz + t·Dz) )  
   and return true.

------------------------------------------------------------
Part B: End‐Cap Intersections
------------------------------------------------------------
If neither side intersection is valid, test the flat caps:
 For each cap at y = yCap (yMin and yMax):
   1.  Solve for t in Oy + t·Dy = yCap  ⇒  t = (yCap − Oy) / Dy.
   2.  Check t ∈ [tMin, tMax].  
   3.  Let X = Ox + t·Dx, Z = Oz + t·Dz.  If X² + Z² ≤ R² then the ray hits the cap.
   4.  The cap’s normal is (0, −1, 0) for the bottom cap (yCap = yMin) and (0, +1, 0) for the top cap (yCap = yMax).

Return the smallest valid t among side and cap intersections.

------------------------------------------------------------
Part C: Test Cases
------------------------------------------------------------
Implement your function and verify it against these examples (assume R = 1, yMin = 0, yMax = 2, tMin = 0.001, tMax = +∞):

1) Ray origin O = (0, 1, –5), D = (0, 0, 1)  
   • Should hit the side at t = 4.0.  
   • Hit point = (0, 1, –1), normal = (0, 0, –1).

2) Ray origin O = (0, 3, 0), D = (0, –1, 0)  
   • Should hit the top cap at t = 1.0.  
   • Hit point = (0, 2, 0), normal = (0, +1, 0).

3) Ray origin O = (2, 1, 0), D = (–1, 0, 0)  
   • Should graze the side at t = 1.0.  
   • Hit point = (1, 1, 0), normal = (1, 0, 0).

4) Ray origin O = (0, –1, 0), D = (0, –1, 0)  
   • Points away from cylinder (no intersection) ⇒ return false.

------------------------------------------------------------
Submission
------------------------------------------------------------
• Provide well-commented code for intersectCylinder(…)  
• Show algebra for the quadratic in Part A  
• Print out the results of the four test cases above (tHit and hitNormal).  
• Discuss any edge cases you handle (e.g. rays parallel to the cylinder axis).

Good luck!

############### 3.9 ###############
Programming Exercise: Ray–Cylinder Intersection (Finite, Closed Cylinder)

Objective  
Implement a function that computes the intersection between a ray and a finite, closed cylinder (i.e. including its curved side and its two flat end‐caps). Your function should return the smallest positive ray‐parameter t at which the ray hits the cylinder, and the surface normal at the hit point.

Scene Description  
• Cylinder  
  – Centered at the world origin.  
  – Axis runs along the y-axis from y = –1 to y = +1 (height = 2).  
  – Radius r = 1.  
  – The cylinder is “closed,” so it has two circular end‐caps at y = –1 and y = +1.

• Ray  
  – Origin: O = (Ox, Oy, Oz)  
  – Direction: D = (Dx, Dy, Dz), assumed normalized.  
  – Parametric form: R(t) = O + t·D, for t ≥ 0.

Function Signature (C++-style pseudocode)  
```cpp
struct Vec3 { float x, y, z; /* … plus vector ops … */ };

struct Ray {
  Vec3 origin;    // O
  Vec3 direction; // D (normalized)
};

// Returns true if the ray hits the cylinder (side or caps).
// On hit, tHit is set to the smallest t > epsilon, and outNormal
// is set to the unit surface normal at R(tHit).
bool intersectCylinder(
    const Ray& ray,
    float& tHit,
    Vec3& outNormal);
```

Requirements  
1. Use epsilon = 1e–4 to discard hits too close to the ray origin.  
2. Return only the smallest positive t > epsilon where the ray actually intersects the cylinder (side or caps).  
3. Compute and return the correct outward‐pointing normal at the hit point.  
4. If there is no intersection, return false.

Hints / Suggested Approach  
1. Intersect with the infinite cylinder (side surface):  
   a. In the x–z plane, the cylinder’s equation is x² + z² = r².  
   b. Substitute the ray: (Ox + t·Dx)² + (Oz + t·Dz)² = r² → a·t² + b·t + c = 0,  
      where  
         a = Dx² + Dz²  
         b = 2·(Ox·Dx + Oz·Dz)  
         c = Ox² + Oz² – r²  
   c. Solve the quadratic. For each real root ti > epsilon, compute yi = Oy + ti·Dy;  
      accept ti only if yi ∈ [–1, +1].

2. Intersect with the two caps (y = –1 and y = +1):  
   a. For each cap plane y = yc (yc = ±1), solve Oy + t·Dy = yc → t = (yc – Oy)/Dy (if Dy ≠ 0).  
   b. For each t > epsilon, compute Xi = Ox + t·Dx, Zi = Oz + t·Dz;  
      accept t only if Xi² + Zi² ≤ r².

3. Among all accepted t’s (from side and caps), pick the smallest positive t.  
4. Compute the normal:  
   – If the hit is on the side, N = normalize((Px, 0, Pz)), where P = O + t·D.  
   – If the hit is on the top cap (y = +1), N = (0, +1, 0).  
   – If the hit is on the bottom cap (y = –1), N = (0, –1, 0).

Deliverables  
• Complete source code of intersectCylinder(…) in C++ (or equivalent).  
• Brief comments explaining each step.  
• A short test demonstrating a ray that hits the side and a ray that hits a cap.

############### 4.0 ###############
Ray‐Sphere Intersection with Two Spheres  
=====================================

In this exercise you will write a small “ray tracer” that tests a single ray against two spheres, picks the nearest hit (if any), and returns a color (one sphere red, the other green, background black).  You must:

  1. Define simple structs for Ray, Sphere and Color.  
  2. Implement an intersection routine for one sphere.  
  3. Call it twice (once per sphere) to find the nearest intersection.  
  4. Return the sphere’s color or background black if there is no hit.  

—  
Part A. Data Types  
-----------------  
In your favorite language (C/C++/Java/C#/Python…), define:

  • struct Vec3  
      • float x, y, z  
      • Methods or functions for addition, subtraction, dot-product, scalar multiply, length, normalization.  

  • struct Ray  
      • Vec3 origin  
      • Vec3 direction    // assume direction is always normalized  

  • struct Color  
      • int r, g, b       // each in [0…255]  

  • struct Sphere  
      • Vec3 center  
      • float radius  
      • Color surfaceColor  

—  
Part B. Ray‐Sphere Intersection  
--------------------------------  
Implement a function with this signature (or your language’s equivalent):

    // Returns true if ray hits sphere at some positive t.
    // On return, tNear holds the smallest positive root of the intersection.
    bool intersectRaySphere(Ray ray, Sphere sphere, float &tNear)

Use the standard derivation:

  1. Let L = ray.origin − sphere.center.  
  2. Solve  (ray.direction ⋅ ray.direction)·t²  +  2·(ray.direction ⋅ L)·t  +  (L⋅L − radius²)  = 0  
     – since direction is normalized, (ray.direction⋅ray.direction)=1.  
  3. Compute discriminant Δ = b² − 4ac.  If Δ < 0 return false.  
  4. Compute roots t0 = (−b − sqrt(Δ)) / 2a, t1 = (−b + sqrt(Δ)) / 2a.  
  5. Discard any t ≤ 0.  Let tNear = min{positive roots}.  If none positive, return false.  

Return true if you found a positive tNear.

—  
Part C. Ray‐Tracing Two Spheres  
--------------------------------  
Write a function

    Color traceSingleRay(Ray ray, Sphere sphere1, Sphere sphere2)

that:

  1. Calls intersectRaySphere(ray, sphere1, t1).  
  2. Calls intersectRaySphere(ray, sphere2, t2).  
  3. If neither hit, return Color{0,0,0} (background).  
  4. Otherwise pick the smaller positive t and return the corresponding sphere’s surfaceColor.  

—  
Part D. Setup and Test Cases  
----------------------------  
In your main program:

  1. Define Sphere A: center = (0, 0, −5), radius = 1.0, color = (255, 0, 0)   // red  
  2. Define Sphere B: center = (2, 0, −6), radius = 1.5, color = (0, 255, 0) // green  
  3. Set camera (ray origin) at O = (0, 0, 0).  

Normalize ray directions before tracing.  For each of these test rays, print the Color returned by traceSingleRay:

  • Ray 1: direction D1 = normalize( (  0.0,   0.0, −1.0) )  
    – Expected: hits Sphere A first → Color(255, 0, 0)  

  • Ray 2: direction D2 = normalize( (  0.4,   0.0, −1.0) )  
    – Expected: misses Sphere A, hits Sphere B → Color(0, 255, 0)  

  • Ray 3: direction D3 = normalize( ( −0.5,  0.5, −1.0) )  
    – Expected: misses both → Color(0, 0, 0)  

—  
Deliverables  
------------  
  • Source code including Vec3, Ray, Sphere, Color definitions.  
  • Implementation of intersectRaySphere and traceSingleRay.  
  • Output for the three test rays, demonstrating correct sphere selection.  

Be sure your descriptions (sphere names, centers, radii, colors) are used exactly and unambiguously in your code.

############### 4.1 ###############
Ray‐Sphere Intersection with Two Spheres  
———————————————————  
In this exercise you will write code to test a ray against two distinct spheres and pick the nearest hit (if any).  You are given simple `Vector`, `Ray` and `Sphere` types in C++; fill in the missing intersection logic and then use it to shade a tiny scene of two spheres.  

Scene Description  
---------------  
Sphere A  
• Center: ( 0.0,  0.0, –5.0)  
• Radius: 1.0  
• Color: Red (1.0, 0.0, 0.0)  

Sphere B  
• Center: ( 2.0,  0.0, –6.0)  
• Radius: 1.5  
• Color: Green (0.0, 1.0, 0.0)  

Background color: (0.2, 0.7, 0.8)  

You may assume all vectors are in world space, right‐handed, and the camera is at the origin (0,0,0).  

Code Skeleton  
-------------  
```cpp
#include <cmath>
#include <limits>
#include <array>
using std::array;
const float  EPSILON = 1e-4f;
const float  INF     = std::numeric_limits<float>::infinity();

struct Vector {
    float x, y, z;
    Vector()                      : x(0),   y(0),   z(0)   {}
    Vector(float X, float Y, float Z): x(X), y(Y), z(Z) {}
    Vector operator+(const Vector& v) const { return Vector(x+v.x, y+v.y, z+v.z); }
    Vector operator-(const Vector& v) const { return Vector(x-v.x, y-v.y, z-v.z); }
    Vector operator*(float s) const         { return Vector(x*s,   y*s,   z*s  ); }
};

inline float dot(const Vector& a, const Vector& b) {
    return a.x*b.x + a.y*b.y + a.z*b.z;
}

inline Vector normalize(const Vector& v) {
    float len = std::sqrt(dot(v,v));
    return Vector(v.x/len, v.y/len, v.z/len);
}

struct Ray {
    Vector origin;
    Vector dir;   // assumed normalized
};

struct Sphere {
    Vector center;
    float   radius;
    Vector  color;   // RGB in [0,1]
};

// Returns true if ray intersects sphere.  
// On hit, tNear is set to the smaller positive t (parameter along ray).
bool intersect_sphere(const Ray& ray, const Sphere& sphere, float& tNear)
{
    // TODO: implement ray‐sphere intersection
    // Solve ‖O + t D – C‖^2 = R^2 for t
    return false;
}

// Trace a ray into the scene of two spheres.
// If it hits one or both spheres, return the color of the nearest sphere.
// Otherwise return the background color.
Vector trace(const Ray& ray, const array<Sphere,2>& scene)
{
    float tClosest = INF;
    const Sphere* hitSphere = nullptr;

    for (const Sphere& s : scene)
    {
        float t = INF;
        if (intersect_sphere(ray, s, t))
        {
            if (t < tClosest)
            {
                tClosest   = t;
                hitSphere  = &s;
            }
        }
    }

    if (!hitSphere)
        return Vector(0.2f, 0.7f, 0.8f);  // background

    // simple diffuse shading with a single directional light
    Vector hitPos  = ray.origin + ray.dir * tClosest;
    Vector normal  = normalize(hitPos - hitSphere->center);
    Vector lightDir= normalize(Vector(-1, -1, -1));
    float  diff    = std::max(0.0f, dot(normal, -lightDir));
    return hitSphere->color * diff;
}

// You may add any helper functions you need below.
```

Your Tasks  
----------  
1.  Implement `intersect_sphere(...)` so that it returns `true` if the ray hits the sphere in front of the origin (t>EPSILON), storing the nearest positive t‐value in `tNear`.  
2.  In `trace(...)`, complete any additional code you need to return the sphere’s color modulated by simple Lambertian diffuse (as sketched above).  
3.  Compile and run your code; for each of the following rays, report:  
   • Which sphere was hit (A, B or none)  
   • tNear (distance along the ray)  
   • Intersection point coordinates  
   • Surface normal at the hit point  

   Test rays (all from origin (0,0,0), assume directions are already normalized):  
   a) dir = normalize( Vector( 0.0,  0.0, -1.0) )  
   b) dir = normalize( Vector( 0.4, -0.2, -1.0) )  
   c) dir = normalize( Vector( 2.0,  0.0, -6.0) )  

4.  Explain briefly how you handle the quadratic’s discriminant and how you pick the correct root t.  

Deliverables  
------------  
• Source code with your `intersect_sphere` implementation and any helper functions.  
• A short report (1–2 paragraphs) showing your test‐ray results and your reasoning about root selection.  

Grading will focus on correctness of intersection logic, correct sphere selection, and clarity of your explanation.

############### 4.2 ###############
Ray‐Object Intersection Exercise: Two Spheres

Objective  
Implement ray–sphere intersection in C++ (or your language of choice) and test a simple scene containing exactly two spheres. Your code must correctly find the nearest intersection (if any), compute the hit point and surface normal, and report which sphere was hit.

Scene Description  
• Sphere 1 (“Red Sphere”):  
  – Center C₁ = (0, 0, –5)  
  – Radius r₁ = 1  

• Sphere 2 (“Blue Sphere”):  
  – Center C₂ = (2, 0, –6)  
  – Radius r₂ = 1.5  

Coordinate system is right‐handed. Ray parametric form:  
  R(t) = O + t·D,   t ≥ 0  
where O is the origin point and D is a normalized direction vector.

Data Structures (suggested)  
  struct Vec3 { float x,y,z; /* plus vector ops: +, –, dot, normalize */ };  
  struct Ray  { Vec3 O; Vec3 D; };  
  struct Sphere { Vec3 C; float r; int id; };  
  struct HitRecord {  
    bool hit;    // true if intersection found  
    float t;     // ray parameter of nearest hit  
    Vec3 P;      // hit point = O + t·D  
    Vec3 N;      // surface normal at P  
    int sphereID;// id of sphere hit (1 or 2)  
  };

Assignment

1. Write a function  
   bool intersectSphere(const Ray& ray,  
                        const Sphere& sph,  
                        float tMin, float tMax,  
                        HitRecord& rec)  
   that tests `ray` against `sph`.  
   – Solve (O + t D – C)·(O + t D – C) = r² for t.  
   – Accept the smallest t in [tMin, tMax].  
   – If there is a valid t, fill rec.hit = true, rec.t, rec.P, rec.N, rec.sphereID = sph.id, and return true; otherwise return false.

2. Write a scene‐intersection function  
   HitRecord traceRay(const Ray& ray)  
   that loops over your two spheres, calls intersectSphere for each (using tMin = 0.001 to avoid self‐hits, tMax = ∞), and returns the HitRecord for the nearest hit. If no sphere is hit, return rec.hit = false.

3. In your main program, define:  
   Sphere sceneSpheres[2] = {  
     { Vec3{ 0, 0, -5}, 1.0f, 1 },    // Red sphere, id=1  
     { Vec3{ 2, 0, -6}, 1.5f, 2 }     // Blue sphere, id=2  
   };

4. Test your code with these five rays (all originate at O = (0,0,0)):

   Ray#  Direction (not yet normalized)         Expected sphereID   Approx. hit point P  
   1     (  0,   0,  -1 )                      1                  ( 0,  0, -4)  
   2     (  1,   0,  -2 )                      2                  ( 2,  0, -6)  
   3     ( -1,   0,  -5 )                      none               —  
   4     (  0.5, 0.1, -1 )                     1                  (0.48, 0.1, -4.8)  
   5     (  3,   0,  -6 )                      2                  (2.00, 0.00, -6.00)  

   (Normalize each direction before tracing.)

5. For each test ray, print:  
   – Ray index  
   – hit = true/false  
   – sphereID (if hit)  
   – t value  
   – P and N

Grading Criteria  
• Correct implementation of the quadratic solver for ray–sphere intersections.  
• Proper selection of the nearest positive‐t hit.  
• Accurate computation of P and normalized N = (P–C)/r.  
• Correct outputs for the five test rays.  
• Clear, well‐organized code and brief comments explaining your logic.

############### 4.3 ###############
Exercise: Ray Tracing Two Spheres – Ray-Object Intersection  

Background  
You will write a minimal ray tracer that renders two non-overlapping spheres in a simple scene. Your program must compute ray-sphere intersections, determine which sphere (if any) a ray hits first, and shade the point of intersection with a single directional light using Lambertian reflectance.

Scene Description  
1. Camera  
   - Position: (0, 0, 0)  
   - Image (view) plane: z = –1  
   - Horizontal FOV: implicit from mapping pixel x ∈ [0, width–1] to view-plane x ∈ [–1, +1]  
   - Vertical FOV: implicitly map pixel y ∈ [0, height–1] to view-plane y ∈ [–1, +1]  

2. Objects: two spheres  
   Sphere A  
     • Center: C₁ = (0, 0, –3)  
     • Radius: r₁ = 1  
     • Surface color: (1.0, 0.0, 0.0) (red)  
   Sphere B  
     • Center: C₂ = (1.5, 0, –4)  
     • Radius: r₂ = 1  
     • Surface color: (0.0, 0.0, 1.0) (blue)  

3. Light  
   - Directional light coming from direction L = normalize((1, 1, –1))  
   - Intensity: I = (1.0, 1.0, 1.0)  
   - Ambient term: kₐ = 0.1 (applies equally to all spheres)  
   - Diffuse coefficient: k_d = 0.9  

Task  
Write a program that:  
1. Loops over each pixel (i, j) in an image of width W and height H.  
2. Computes the corresponding ray:  
     Origin: O = (0, 0, 0)  
     Direction: D = normalize(( (2*i/(W–1) – 1), (1 – 2*j/(H–1)), –1 ))  
3. For each sphere, solves the ray-sphere intersection equation:  
     |O + tD – C|² = r²  
   – Form the quadratic at² + bt + c = 0 with:  
     a = D·D  
     b = 2 D·(O – C)  
     c = (O – C)·(O – C) – r²  
   – Compute the discriminant Δ = b² – 4ac  
   – If Δ < 0, no intersection. Otherwise, compute the two roots t₁ < t₂ = (–b ∓ √Δ) / (2a)  
   – Only consider t > 0.  

4. Determine which sphere yields the smallest positive t (closest hit). If neither sphere is hit, set pixel color to background: (0.2, 0.2, 0.2).  

5. If a sphere is hit at point P = O + tD:  
   – Compute the normal N = normalize(P – C_sphere)  
   – Compute the diffuse term: max(0, N·L)  
   – Compute color = kₐ·color_sphere + k_d·(diffuse term)·color_sphere  

6. Write out the final image in plain PPM (P3) format with RGB values in [0,255].

Deliverables  
- Source code implementing the above.  
- A PPM image file (e.g., output.ppm) at resolution 400×200.  
- A brief README describing how to compile and run your program.

Evaluation Criteria  
- Correctness of ray-sphere intersection (correct quadratic setup, discriminant check, root selection).  
- Proper handling of two spheres and selection of the nearest hit.  
- Accurate Lambertian shading with ambient + diffuse terms.  
- Clean, well-commented code and correct PPM output.

Hints  
- Normalize vectors using length = √(x² + y² + z²).  
- Be careful to test both roots t₁ and t₂ and pick the smallest positive.  
- Ensure your pixel-to-viewport mapping covers the full range x,y ∈ [–1,+1] on the view plane.

############### 4.4 ###############
Ray‐Object Intersection with Two Spheres

In this exercise you will write a small ray tracer that renders a scene consisting of exactly two spheres.  Your task is to

  1. derive and implement the ray–sphere intersection test  
  2. shoot primary rays through each pixel of a simple viewport  
  3. determine which sphere (if any) each ray hits first  
  4. color the pixel accordingly  

Scene description
-----------------

Camera  
  • Position C = (0, 0, 0)  
  • View plane (image plane) is a rectangle at z = –1  
  • Viewport size is 2 units high and 2.66 units wide  
  • Output image resolution: 800×600 pixels  
  • For pixel (i, j) with i∈[0..799], j∈[0..599], compute  
      u = (i + 0.5)/800  → x = (u – 0.5)·2.66  
      v = (j + 0.5)/600  → y = (0.5 – v)·2  
      rayOrigin = C  
      rayDirection = normalize( (x, y, –1) – C )  

Spheres  
  1. Sphere A (red)  
     • Center CA = (0,  0, –5)  
     • Radius rA = 1  
     • Color: (1, 0, 0)  
  2. Sphere B (green)  
     • Center CB = (2,  0, –6)  
     • Radius rB = 1.5  
     • Color: (0, 1, 0)  

Background color = (0, 0, 0)

Light for simple shading (bonus, optional)  
  • Directional light L = normalize( (1, 1, -1) )  
  • Ambient = 0.1  

Tasks
-----

1.  Intersection Test (30%)  
    a.  Write down the quadratic equation for intersecting a parametric ray  
          R(t) = rayOrigin + t·rayDirection  
        with a sphere (centered at C, radius r).  
    b.  Show how you solve for t and choose the smallest positive solution.  

2.  Implementation (50%)  
    In your favorite language implement:  
    •  A function  
         bool intersectSphere( Vec3 O, Vec3 D, Vec3 C, float r, out float t )  
       that returns true if the ray (O, D) hits the sphere (C, r), and sets t  
       to the nearest positive intersection distance.  
    •  A main loop over all pixels (i,j):  
       – compute rayOrigin, rayDirection  
       – call intersectSphere for both Sphere A and Sphere B  
       – determine which sphere is hit first (smallest t > 0)  
       – if a hit occurs, set pixel color = sphereColor × dot(N, L) (clamp ≥0),  
         otherwise pixel color = background.  
       – N is the normal at the intersection point:  
            N = normalize( (O + t·D) – C_sphere )  
       – L is the light direction (for flat/Lambertian shading)  

3.  Output (20%)  
    Write your image to a simple PPM file (“P3 800 600 255 …”). Submit:  
      • source code  
      • the resulting PPM image  

Optional Extension (for extra credit)  
--------------------------------------  
• Add a second light source or switch to Blinn–Phong specular shading.  
• Place a plane underneath the spheres for a ground‐shadow effect.  

Grading  
-------  
– Correct derivation of the intersection equation  
– Correct implementation of intersectSphere (robust discriminant test)  
– Rays that miss both spheres must produce the black background  
– Pixels on Sphere A are red (modulated by shading), on Sphere B are green  
– Image dimensions and aspect ratio must match exactly 800×600, viewport 2×2.66  

Notes  
-----  
– All vector operations (dot, normalize, subtract) are standard 3D.  
– If both intersections are valid, choose the smaller positive t.  
– Do not confuse sphere centers: A is at (0,0,–5), B is at (2,0,–6).  

Good luck!

############### 4.5 ###############
Below is a self-contained programming exercise.  You must implement ray–sphere hit tests for two spheres and then determine which (if any) the ray strikes first.  Be careful to keep all object data unique and unambiguous.

---  

**Ray–Two-Spheres Intersection**  

We have:  
  • A ray    R(t) = O + t·D,  t ≥ 0  
    – O = ray origin (Vec3)  
    – D = ray direction (normalized Vec3)  
  • Two spheres  
    1) Sphere A  
       – center CA = (–1,  0, –5)  
       – radius rA = 1.0  
       – material ID mA = 0  
    2) Sphere B  
       – center CB = ( 2,  1, –4)  
       – radius rB = 0.5  
       – material ID mB = 1  

Task 1  
Write a function  
  
  bool hit_sphere(  
    const Vec3 &center,  
    float       radius,  
    const Ray  &ray,  
    float       t_min,  
    float       t_max,  
    HitRecord &out_rec  
  );  
  
– It returns `true` if the ray intersects the sphere at some t in [t_min, t_max].  
– If true, fill `out_rec` with:  
    • t (the nearest valid solution)  
    • point P = ray(t)  
    • normal N = (P – center) / radius  
    • the sphere’s material ID  

Assume  
  struct Vec3 { float x,y,z; /* plus vector ops */ };  
  struct Ray  { Vec3 orig, dir; Vec3 at(float t) const { return orig + t*dir; } };  
  struct HitRecord {float t; Vec3 p, normal; int mat_id;};  

Hint: solving ‖(O + tD) – C‖² = r² yields a quadratic in t.  

Task 2  
Using your `hit_sphere`, write a function  

  bool hit_world(  
    const Ray            &ray,  
    float                  t_min,  
    float                  t_max,  
    const std::vector<Sphere> &world,  
    HitRecord             &closest_rec  
  );  

– `world` is a vector of exactly the two Spheres A and B (struct Sphere bundles center, radius, mat_id).  
– Loop over all spheres, call `hit_sphere` with the current tightest `t_max`, update if you get a closer hit.  
– Return the `HitRecord` for the first (smallest t) valid intersection, or false if none.  

Task 3  
In your `main()`, construct:  
  • Ray with origin O = (0,0,0) and direction D = normalize( (0.5, 0, –1) )  
  • Spheres A and B as above in `world`  

Invoke `hit_world(ray, 0.001f, FLT_MAX, world, rec)`.  
Print out:  
  – “No hit”  
  – or “Hit sphere [A|B], t = …, P = (x,y,z), normal = (nx,ny,nz), mat_id = …”  

**Requirements & Tips**  
1) Be sure your quadratic solver only accepts t in [t_min, t_max].  Often you compute discriminant = b² – 4ac, then two roots (–b ± √disc)/(2a).  Check the smaller root first, then the larger.  
2) Use a small epsilon > 0 (e.g. t_min = 0.001) to avoid “shadow acne” at t = 0.  
3) Normalize your ray direction before use.  
4) The two spheres have different centers & radii—your code should unambiguously report which sphere was hit.  

Once finished, test with the given ray: you should get a single hit on exactly one sphere (A or B), with correct intersection point and normal.

############### 4.6 ###############
Ray-Sphere Intersection Exercise (Two‐Sphere Scene)

Background  
You are to write a tiny ray‐tracer that renders a scene containing exactly two spheres under a single point light.  The camera sits at the origin, looking down the –Z axis; rays are traced through a “viewport” (image plane) at Z=–1.  For each pixel you will:

 1. Generate a ray (origin + direction) through that pixel.  
 2. Test it against both spheres (using the quadratic ray–sphere intersection).  
 3. If it hits one or both, find the nearest hit, compute simple Lambertian shading with a single point light.  
 4. Otherwise output the background color.

Scene Description  
• Camera  
  – Position: O = (0,0,0)  
  – Viewport: a 2×2 square centered at (0,0,–1), spanning X, Y ∈ [–1,+1] at Z=–1  
  – Image resolution: Width = W pixels, Height = H pixels

• Spheres  
  1. Sphere A  
     – Center CA = (0, 0, –5)  
     – Radius rA = 1.0  
     – Surface color cA = (1.0, 0.0, 0.0)   (red)  
  2. Sphere B  
     – Center CB = (2, 0, –6)  
     – Radius rB = 1.5  
     – Surface color cB = (0.0, 0.0, 1.0)   (blue)

• Lighting  
  – Point light position Lp = (5, 5, –5)  
  – Light intensity IL = (1.0, 1.0, 1.0)  
  – Ambient coefficient ka = 0.2  
  – Diffuse coefficient kd = 0.8  
  – No specular term required

• Background color = (0,0,0)

Tasks

1. Derive the ray–sphere intersection test.  
   Let a ray be R(t) = O + t·D, with D normalized.  For a sphere of center C and radius r you must solve  
      ||R(t) – C||² = r²  
   for t ≥ 0.

2. Implement a function  
     float IntersectSphere(Vector3 O, Vector3 D, Sphere S)  
   that returns the smallest positive t at which the ray intersects S, or returns +∞ if there is no intersection.

3. Implement your main trace loop.  For each pixel (i,j):  
   a. Compute the viewport‐space coordinates x, y ∈ [–1,1].  
   b. Set the ray origin to O and direction D = normalize( (x, y, –1) – O ).  
   c. Call IntersectSphere for both Sphere A and Sphere B.  
   d. Find the minimum t > 0; if it is ∞, write background.  
   e. Otherwise compute:  
       P = O + t·D  
       N = normalize(P – Cᵢ)  // surface normal on the hit sphere  
       L = normalize(Lp – P)  
       diffuse = kd * max(0, dot(N, L))  
       color = ka·cᵢ + diffuse·cᵢ  
   f. Clamp color to [0,1] and store into the pixel buffer.

4. Output your final image in a simple format (e.g. PPM) or dump the RGB buffer.

Deliverables  
• A short write‐up showing your derivation of the intersection formula.  
• Well‐commented source code for IntersectSphere and the rendering loop.  
• The rendered  image (100×100 or larger).

Hints  
– Always normalize your ray direction D before solving the quadratic.  
– Be careful to pick the smaller positive root (t₁, t₂).  
– If both roots are negative, the ray hits “behind” the camera—treat as no hit.  
– Use an “infinite” value (e.g. FLT_MAX) when there is no intersection so comparisons remain simple.

############### 4.7 ###############
Ray–Object Intersection: Two Spheres 

In this exercise you will write a small ray tracer that tests intersection against two spheres in 3D space.  You must implement a ray–sphere intersection routine, then test each ray against both spheres and report which (if any) sphere is hit first, together with the hit point.

1. Definitions  
   • A Ray is defined by an origin O = (Ox, Oy, Oz) and a normalized direction D = (Dx, Dy, Dz).  
   • Each Sphere S has a center C = (Cx, Cy, Cz) and a radius r.  

2. Scene setup  
   • Sphere A: center CA = (0, 0, −5), radius rA = 1.0  
   • Sphere B: center CB = (2, 0, −6), radius rB = 1.5  

3. Ray–Sphere Intersection  
   Derive the intersection of a ray  
     P(t) = O + t·D,    t ≥ 0  
   with a sphere (C, r).  The quadratic in t is  
     ‖O + tD − C‖² = r²  
   Expand to at² + bt + c = 0, solve for real roots t.  Keep only those t ≥ 0.  If there are two, take the smaller t.

   You must implement:
     float intersectSphere(Vector3 O, Vector3 D, Vector3 C, float r);
   which returns the smallest non-negative t if the ray hits the sphere, otherwise +∞.

4. Overall algorithm for each input ray:  
   1) Read O, D.  
   2) Normalize D.  
   3) Compute tA = intersectSphere(O, D, CA, rA)  
      Compute tB = intersectSphere(O, D, CB, rB)  
   4) If both tA and tB are +∞, print “None”.  
      Otherwise pick t = min(tA, tB).  
      If t = tA, hit = “A”; else hit = “B”.  
      Compute P = O + t·D.  

5. Input format  
   The first line contains an integer R (1 ≤ R ≤ 1000), the number of rays.  
   Then follow R lines, each with six floats:  
     Ox Oy Oz  Dx Dy Dz  

6. Output format  
   For each ray, output one line:  
     None  
   or  
     Sphere A: Px Py Pz  
   or  
     Sphere B: Px Py Pz  
   where Px, Py, Pz are printed with three decimal places.

7. Example  

Input  
3  
0 0 0   0 0 −1  
0 0 0   2 0 −6  
1 1 0   0 −0.5 −1  

Output  
Sphere A: 0.000 0.000 −4.000  
Sphere B: 2.000 0.000 −6.000  
None  

Explanation of the sample:  
– Ray 1 goes from (0,0,0) straight along −Z and hits Sphere A at t=4 → P=(0,0,−4).  
– Ray 2 aims at (2,0,−6) exactly at the center of Sphere B → t=√((2)²+(0)²+(6)²)−1.5… but here it’s exactly touching at P=(2,0,−6).  
– Ray 3 misses both spheres.

8. What to submit  
• Your source code implementing the above.  
• Make sure your intersectSphere function handles the discriminant < 0 and yields +∞ in that case.  
• Your program must read from stdin and write to stdout in the exact format specified.  
• Include comments explaining your quadratic solution.

Good luck!

############### 4.8 ###############
Here is a self-contained programming exercise on ray–sphere intersection with exactly two spheres.  All object descriptions are unambiguous, and the student is asked only to implement the intersection logic and choose the nearest hit.

---

Exercise: Ray–Sphere Intersection with Two Spheres

Context  
You are writing a minimal ray tracer that shoots primary rays into a scene containing exactly two spheres.  Each sphere has a given center and radius.  Your task is to implement the ray–sphere intersection test, determine which (if any) sphere the ray hits first, and return basic hit information.

Scene Description  
1. Sphere A  
   – Center: ( 0.0,  0.0, –5.0 )  
   – Radius: 1.0  
   – ID: 0  

2. Sphere B  
   – Center: ( 2.0,  0.0, –6.0 )  
   – Radius: 1.5  
   – ID: 1  

Camera & Rays  
– The camera is at the origin (0,0,0).  
– Rays are defined by  
    struct Ray {  
      Vec3 origin;      // starting point in world space  
      Vec3 direction;   // unit vector in world space  
    };  

Desired Output  
Write a function with the signature:

   bool intersectScene(const Ray &ray,
                       float   tMin,
                       float   tMax,
                       HitInfo &hit);

where HitInfo is a struct you define as follows:

   struct HitInfo {
     bool   hit;        // true if we hit one of the spheres
     float  t;          // distance along the ray to the hit point
     Vec3   position;   // world-space coordinates of the hit
     Vec3   normal;     // outward surface normal at the hit point (unit length)
     int    objectId;   // 0 for Sphere A, 1 for Sphere B
   };

Your function should:

1. For each sphere (A then B), solve the quadratic equation  
       dot(D, D) t² + 2·dot(D, O–C) t + dot(O–C, O–C) – R² = 0  
   where  
     – D = ray.direction  
     – O = ray.origin  
     – C = sphere center  
     – R = sphere radius  

2. Find the smaller positive root t that lies in the interval [tMin, tMax].  
3. Among all valid hits, keep the intersection with the smallest t.  
4. If no valid intersections are found, return hit = false.  
5. If there is a hit, fill HitInfo as follows:  
   – hit = true  
   – t = the nearest intersection distance  
   – position = origin + t · direction  
   – normal = normalize(position – C_of_hit_sphere)  
   – objectId = ID of the sphere hit  

Test Rays  
Verify your implementation with these rays (tMin = 0.001, tMax = +∞):

  1. Ray R1: origin = (0,0,0), direction = normalize((0,0,–1))  
     Expected: hits Sphere A at t≈4.0, normal=(0,0,1), objectId=0  

  2. Ray R2: origin = (0,0,0), direction = normalize((2,0,–6))  
     Expected: hits Sphere B at t≈√(4+0+36)–1.5≈(√40–1.5)≈(6.3246–1.5)=4.8246, objectId=1  

  3. Ray R3: origin = (0,0,0), direction = normalize((–1,0,0))  
     Expected: no hit, hit=false  

Deliverables  
– The source code implementing intersectScene.  
– A brief report of the HitInfo results for R1, R2 and R3.  
– Optional: a one-paragraph remark on how you handle the case where the discriminant is exactly zero.

Scoring Criteria  
1. Correct computation of the quadratic discriminant and roots.  
2. Proper selection of the nearest positive t within [tMin, tMax].  
3. Accurate normal computation and objectId assignment.  
4. Clear, commented code structure.

Good luck!

############### 4.9 ###############
Ray‐Sphere Intersection: Two‐Sphere Ray Tracer  
===================================================

In this exercise you will implement the basic ray–sphere intersection test and then use it to decide which of two spheres (if any) a given ray hits first.  You will also compute the hit point, the surface normal there, and assign a simple color per sphere.

----------------------------------------------------------------------
Scene Description
----------------------------------------------------------------------

We have two non–overlapping spheres in our scene:

  1. Sphere A  
     • Center C₁ = ( 0.0,  0.0, –5.0 )  
     • Radius r₁ = 1.0  
     • Color    = (1.0, 0.0, 0.0)  // red  

  2. Sphere B  
     • Center C₂ = ( 2.0,  0.5, –6.0 )  
     • Radius r₂ = 1.5  
     • Color    = (0.0, 1.0, 0.0)  // green  

The camera (ray origin) is at O = (0,0,0).  Rays will be defined by an origin O and a (normalized) direction D.

----------------------------------------------------------------------  
Part 1: Derive the Intersection Test  
----------------------------------------------------------------------

1.  Starting from the ray equation  
     P(t) = O + t D,   t ≥ 0  
    and the sphere equation  
     ‖P – C‖² = r²,  
    derive the quadratic in t:  
     (D·D) t² + 2 D·(O–C) t + (O–C)·(O–C) – r² = 0.  

2.  Show how the discriminant  
     Δ = b² – 4ac  
    determines:  
     • No intersection (Δ < 0)  
     • Two intersections (Δ > 0)  
     • Tangent (Δ = 0)  

----------------------------------------------------------------------  
Part 2: Implement the Sphere‐Intersection Routine  
----------------------------------------------------------------------

In your favorite language implement:

bool intersectSphere(
    Vec3 O, Vec3 D,      // ray: origin, direction (normalized)
    Vec3 C, float r,     // sphere: center, radius
    float &tHit          // output: smallest t ≥ ε if there is a hit
);

• Returns true if the ray hits the sphere at t ≥ ε (e.g. ε = 1e–4), storing the nearest positive t in tHit.  
• Returns false otherwise.

----------------------------------------------------------------------  
Part 3: Trace Against Two Spheres  
----------------------------------------------------------------------

Implement:

Color traceRay(Vec3 O, Vec3 D)
{
    // 1) Test intersection with Sphere A → tA
    // 2) Test intersection with Sphere B → tB
    // 3) Pick the smallest t > ε.  If neither hit, return background color.
    // 4) Compute hit point P = O + t·D
    // 5) Compute normal N = normalize(P – C_sphere)
    // 6) Return the sphere’s color (no further lighting is required).
}

Use background color = (0.0, 0.0, 0.0) (black).

----------------------------------------------------------------------  
Part 4: Test Vectors and Expected Output  
----------------------------------------------------------------------

For each of these three rays, report:

  • Which sphere was hit (A or B), or “none”  
  • The hit‐distance t  
  • The intersection point P  
  • The normal N at P  
  • The returned color

Rays (origin = (0,0,0) always; directions must be normalized before testing):

  1) D₁ = ( 0.0,   0.0, –1.0 )  
  2) D₂ = ( 0.4,   0.0, –1.0 )  
  3) D₃ = ( 0.9,   0.2, –1.2 )

----------------------------------------------------------------------  
Notes & Hints  
----------------------------------------------------------------------

– Always normalize your ray directions.  
– Use a small ε (e.g. 1e–4) to avoid self‐intersection at t≈0.  
– When both tA and tB are valid, pick the smaller positive t.  
– Ensure that your sphere centers and radii are used exactly as stated above.  
– Print your results with at least 4 decimal places for t, P and N.

This exercise will test your understanding of quadratic‐based intersection tests, handling multiple primitives, and choosing the nearest intersection. Good luck!

############### 5.0 ###############
Ray–Disc Intersection (Programming Exercise)

Objective  
Implement a function that tests a 3D ray against a finite disc (a circle in 3D space) and, on a hit, returns the distance along the ray `t`, the hit point, and the disc’s surface normal.

Scene Primitives  
1. Ray  
   - origin: `Vec3 orig`  
   - direction: `Vec3 dir` (assumed normalized)  

2. Disc  
   - center: `Vec3 C`  
   - normal: `Vec3 N` (unit length)  
   - radius: `float R`  

Hit Record  
Define a struct to hold intersection data:  
   struct HitRecord {  
     float t;           // ray parameter  
     Vec3  p;           // hit point  
     Vec3  normal;      // surface normal at hit  
   };

Function Signature  
bool intersectDisc(const Ray& ray, float tMin, float tMax,  
                   const Disc& disc, HitRecord& rec);

Details & Constraints  
1. A ray is `P(t) = orig + t * dir`, t ≥ 0.  
2. The infinite plane of the disc satisfies `(P – C) · N = 0`.  
3. Compute t_plane = `((C – orig) · N) / (dir · N)`.  
   - If `dir · N` is zero (or very close), the ray is parallel → no hit.  
   - Otherwise check `tPlane` within `[tMin, tMax]` and `tPlane ≥ 0`.  
4. Compute hit point `P = orig + t_plane * dir`.  
   - Check if this point lies within the disc radius:  
     `||P – C||₂ ≤ R`.  
   - If yes, record `t = tPlane`, `p = P`, and `normal = N` (or `±N`, see Note).  
5. Return true on hit, false otherwise.

Note on Normal Orientation  
If you wish the normal always to oppose the incoming ray direction, you may flip it:  
   if `(ray.dir · N) > 0` then `rec.normal = -N` else `rec.normal = N`.

Implementation Hints  
- Guard against division by zero when computing `dir · N`.  
- Use a small ε (e.g. 1e-6) to test for parallelism.  
- Ensure `dir` is normalized before calling the intersection routine.

Sample Test Cases  
Let disc D have center C=(0,1,0), normal N=(0,1,0), radius R=1.

1. Ray intersects at center:  
   - orig = (0,2,0), dir = (0,–1,0)  
   - Expected hit: t = 1.0, p = (0,1,0), normal = (0,1,0)

2. Ray misses disc (outside radius):  
   - orig = (2,2,0), dir = (0,–1,0)  
   - Expected: no hit (returns false)

3. Ray parallel to disc plane:  
   - orig = (0,1,0), dir = (1,0,0)  
   - Expected: no hit (returns false)

4. Ray hits edge exactly:  
   - orig = (1,2,0), dir = (0,–1,0)  
   - Expected hit: t = 1.0, p = (1,1,0), normal = (0,1,0)

Deliverable  
– Source code for `intersectDisc(...)`.  
– Brief explanation of each computation step.  
– Results of the sample test cases, printed or logged.

############### 5.1 ###############
Below is a self‐contained programming exercise on ray–disc intersection.  Every piece of data you need is specified; there are no hidden assumptions and no conflicting descriptions.

--------------------------------------------------------------------------------
Exercise: Ray–Disc Intersection

You will write a routine that tests whether a 3D ray hits a flat, circular disc, and if so, returns the hit parameters.

1. Definitions

   • Ray  
     – Origin: O (a 3‐vector)  
     – Direction: D (a unit‐length 3‐vector)

   • Disc  
     – Center point: C (a 3‐vector)  
     – Normal: N (a unit‐length 3‐vector)  
     – Radius: R (a positive scalar)

   • Valid t‐range for the ray: [tMin, tMax].  The ray is parametrized as  
     P(t) = O + t·D; we only care about intersections with tMin ≤ t ≤ tMax.

   • Hit record (on a successful hit) stores:  
     – t (the ray parameter)  
     – P = O + t·D (the intersection point)  
     – N_hit (the outward normal at P)  
     – (u, v) (disc‐local 2D coordinates, each in [0,1])

2. Mathematical Derivation

   a) Plane intersection  
      The disc lies in the plane with normal N through point C.  Solve for t:  
        denom = D·N  
        if |denom| < ε (e.g. 1e−6) → ray is parallel → no hit.  
        t = (C−O)·N / denom  
      Accept this t only if tMin ≤ t ≤ tMax.

   b) Disc bounds check  
      Compute P = O + t·D.  The hit is valid only if the point lies within the radius:  
        if ‖P − C‖² > R² → miss the disc → no hit.

3. UV‐Mapping on the Disc

   To return (u, v) in [0,1] × [0,1], do the following:

   a) Build an orthonormal basis (A, B, N) at C.  
      – Choose any non‐parallel helper H:  
         if |N.x| > |N.y|  
           H = (N.z, 0, −N.x)  
         else  
           H = (0, −N.z, N.y)  
      – A = normalize(H)  
      – B = N × A

   b) Let V = P − C.  Then the 2D coordinates in the disc’s plane are:  
        x = V·A  
        y = V·B  
      Map to u,v in [0,1]:  
        u = (x/R + 1) * 0.5  
        v = (y/R + 1) * 0.5

4. Function Signature (C++-style pseudocode)

  struct HitRecord {
    float t;
    Vec3  P;
    Vec3  N_hit;
    float u, v;
  };

  // Returns true if ray hits the disc; fills out rec.
  bool intersectDisc(
     const Vec3& O, const Vec3& D,
     const Vec3& C, const Vec3& N, float R,
     float tMin, float tMax,
     HitRecord& rec
  ) {
    // --- Your implementation here ---
  }

5. Tasks

   a) Derive and write out in comments each step of the intersection test:  
      – Checking for parallelism  
      – Computing t  
      – Testing bounds on t  
      – Checking radial distance  
   
   b) Implement the code in the body of intersectDisc():  
      – Compute denom = D·N and early exit if parallel.  
      – Compute t and test tMin ≤ t ≤ tMax.  
      – Compute P, then test (P−C)² against R².  
      – Build basis (A,B) and compute (u,v).  
      – Fill rec.t, rec.P, rec.N_hit (always N or −N depending on denom’s sign?), rec.u, rec.v.  
      – Return true on hit, else false.

   c) Explain in a short comment how you choose the sign of rec.N_hit so that it always opposes the incoming ray D (i.e. faces the ray’s origin).

6. Example Values for Testing  

   • O = (0,0,−5), D = (0,0,1)  
   • C = (0,0,0), N = (0,0,1), R = 2  
   • tMin = 0.001, tMax = +∞  

   Expected:  
     – denom = 1 → not parallel  
     – t = 5 → within [tMin,∞)  
     – P = (0,0,0) → inside radius 2  
     – rec.N_hit = (0,0,−1) (since ray comes from negative z)  
     – (u,v) = (0.5,0.5)

Please implement and thoroughly test your function against several rays (grazing, behind the disc, edge hits, parallel rays) to ensure correctness.

############### 5.2 ###############
Below is a self-contained programming problem on ray–disc intersection suitable for an introductory Computer Graphics assignment.  Read it carefully and make sure your implementation matches the disc description exactly.

---

### Ray–Disc Intersection

**Background**  
A disc is the set of points lying in a plane within a circle of given radius.  To test a ray against a disc, you first intersect the ray with the plane of the disc; then you check whether the hit point falls within the disc’s radius.

**Scene Primitives**  
```cpp
// 3D vector with usual operators: +, –, *, dot(,), length(), normalize()
struct Vec3 {
    float x, y, z;
    // … you may assume constructors and operators are available …
};

// A ray: origin O, direction D
struct Ray {
    Vec3 O;       // origin
    Vec3 D;       // normalized direction
};

// A disc: center C, unit normal N, radius r
struct Disc {
    Vec3 C;       // center point of the disc
    Vec3 N;       // unit-length normal vector
    float r;      // radius (> 0)
};

// Hit record, to store intersection details
struct HitRecord {
    float t;      // ray parameter at hit
    Vec3 P;       // intersection point
    Vec3 N;       // surface normal at hit (should match disc.N)
    // (optional) float u, v;   // UV‐coordinates if you wish
};
```

**Task**  
Implement the following function:

```cpp
// Returns true if the ray hits the disc in front of the origin (t > t_min && t < t_max).
// If there is a hit, fill in rec.t, rec.P, and rec.N, then return true;
// otherwise return false.
bool intersect_disc(
    const Ray&    ray,
    const Disc&   disc,
    float         t_min,
    float         t_max,
    HitRecord&    rec
);
```

Your implementation must:

1. **Plane Intersection**  
   Solve for  
     denom = dot(disc.N, ray.D)  
   If |denom| < ε (e.g. 1e-6), the ray is parallel to the disc’s plane → no hit.  
   Otherwise compute  
     t = dot(disc.N, disc.C − ray.O) / denom.  
   If t < t_min or t > t_max, reject → no hit.

2. **Disc‐Radius Test**  
   Let P = ray.O + t * ray.D be the intersection point on the plane.  
   Compute squared distance from P to the disc center:  
     d2 = |P − disc.C|^2.  
   If d2 > disc.r * disc.r, reject → the hit is outside the disc.

3. **Record Hit**  
   If both tests pass:  
   • rec.t = t  
   • rec.P = P  
   • rec.N = (denom < 0) ? disc.N : −disc.N  
     (this orients the normal so it always opposes the incoming ray)  
   • return true.

4. **Otherwise**  
   return false.

**Deliverables**  
• A complete C++ implementation of `intersect_disc`.  
• A short derivation (2–3 lines) of the plane‐intersection formula you used.  
• (Optional) If you wish, assign UV coordinates on the disc via  
   u = (θ / (2π)), v = (|P − C| / r),  
   where θ = atan2((P−C)·U, (P−C)·V), and U, V are orthonormal basis vectors in the disc’s plane.

**Notes**  
- Assume `ray.D` and `disc.N` are already normalized.  
- Use a small epsilon (e.g. 1e-6) to avoid division‐by‐zero when checking denom.  
- Make sure your code never confuses the disc’s radius with its diameter.  

---

Good luck!

############### 5.3 ###############
Ray–Disc Intersection Exercise

Background  
A disc is the set of points in a plane that lie within a given radius of a center. In ray tracing you first intersect the ray with the infinite plane of the disc, then check whether the intersection point falls inside the disc’s circular boundary.

Problem Statement  
Write a function that tests a ray against a single disc. If the ray hits the disc, return detailed intersection information (hit = true, t, position P, surface normal N, and 2D parametric coordinates (u,v)). If there is no hit, return hit = false.

1. Data Structures  
   • Ray  
     – origin: Vec3  
     – direction: Vec3 (normalized)  
   • Disc  
     – center: Vec3         (point on the disc’s plane)  
     – normal: Vec3         (unit-length; defines the plane orientation)  
     – radius: float > 0  
   • Intersection  
     – hit: bool  
     – t: float             (distance along ray: P = origin + t·direction)  
     – P: Vec3              (hit position)  
     – N: Vec3              (surface normal at P)  
     – u, v: float          (parametric coordinates on the disc; see below)  

2. Mathematical Steps  
  a. Solve for intersection with the plane:  
     Let ray(t) = O + tD. We want t such that (O + tD – center)·normal = 0  
     ⇒ t = ((center – O)·normal) / (D·normal)  
     If D·normal ≈ 0, the ray is parallel to the plane → no hit.  
     If t ≤ 0, intersection is behind the ray origin → no hit.  
  b. Compute P = O + tD.  
  c. Test radial bound:  
     If |P – center| > radius → no hit.  
  d. Compute local 2D coordinates (u,v) on the disc:  
     • Choose two orthonormal basis vectors (Uaxis, Vaxis) spanning the plane.  
       For example:  
         if |normal.x| > 0.9 then Uaxis = cross(normal, (0,1,0))  
         else Uaxis = cross(normal, (1,0,0))  
         then normalize Uaxis, and Vaxis = cross(normal, Uaxis).  
     • Set Δ = P – center,  
         u = (Δ · Uaxis) / radius,  
         v = (Δ · Vaxis) / radius.  
       Here (u,v) each run in [–1, +1], and u² + v² ≤ 1 inside the disc.  

3. Function Signature (C++-style pseudocode)  
```cpp
struct Vec3 { float x,y,z; /* … */ };
struct Ray { Vec3 origin, dir; };
struct Disc { Vec3 center, normal; float radius; };
struct Intersection {
    bool hit;
    float t;
    Vec3 P, N;
    float u, v;
};

Intersection intersectDisc(const Ray& ray, const Disc& disc) {
    Intersection isect;
    isect.hit = false;

    // 1. Plane intersection
    float denom = dot(ray.dir, disc.normal);
    if (fabs(denom) < 1e-6f) return isect;   // parallel
    float t = dot(disc.center - ray.origin, disc.normal) / denom;
    if (t <= 0) return isect;                // behind the origin

    // 2. Point on plane
    Vec3 P = ray.origin + ray.dir * t;

    // 3. Radial check
    Vec3 d = P - disc.center;
    float dist2 = dot(d, d);
    if (dist2 > disc.radius * disc.radius) return isect;

    // 4. Compute UV axes
    Vec3 Uaxis;
    if (fabs(disc.normal.x) > 0.9f)
        Uaxis = normalize(cross(disc.normal, Vec3(0,1,0)));
    else
        Uaxis = normalize(cross(disc.normal, Vec3(1,0,0)));
    Vec3 Vaxis = cross(disc.normal, Uaxis);

    // 5. Fill intersection record
    isect.hit = true;
    isect.t   = t;
    isect.P   = P;
    isect.N   = disc.normal;      // facing side
    isect.u   = dot(d, Uaxis) / disc.radius;
    isect.v   = dot(d, Vaxis) / disc.radius;

    return isect;
}
```

4. Test Cases  
Below are four rays against a disc of radius 2, centered at (0,0,0), lying in the plane z=0 with normal (0,0,1).

Case A: Hit at center  
  Ray.origin = (0,0, 5)  
  Ray.dir    = (0,0,-1)  
  Expected: hit=true, t=5, P=(0,0,0), N=(0,0,1), u=0, v=0

Case B: Hit at edge  
  Ray.origin = (2,0, 5)  
  Ray.dir    = (0,0,-1)  
  Expected: hit=true, t=5, P=(2,0,0), u≈1, v=0

Case C: Miss–outside  
  Ray.origin = (3,0, 5)  
  Ray.dir    = (0,0,-1)  
  Expected: hit=false

Case D: Parallel miss  
  Ray.origin = (0,0, 5)  
  Ray.dir    = (1,0,0)  
  Expected: hit=false

5. Submission  
  • Include your intersectDisc implementation in a file named DiscIntersection.cpp (or .py/.java).  
  • Show that all four test cases produce the expected results.  
  • Explain in 2–3 sentences how you chose Uaxis and Vaxis and why your UV mapping covers the disc uniquely.

############### 5.4 ###############
Ray–Disc Intersection Exercise
==============================

In this exercise you will implement ray–disc intersection in a simple ray tracer.  A *disc* is defined as the set of points in a plane (through its center) whose distance to the center is less than or equal to a given radius.

-------------------------------------------------------------------------------
1.  Data structures (C++‐style pseudocode)
-------------------------------------------------------------------------------
struct Vec3 {
    float x, y, z;
    // … assume you have vector addition, subtraction, dot(), cross(),
    //    length(), normalize(), operator*(scalar), etc.
};

struct Ray {
    Vec3 origin;      // O
    Vec3 direction;   // D   (need not be normalized, but you may normalize if you wish)
};

struct Disc {
    Vec3 center;      // C
    Vec3 normal;      // N   (assume this is a unit vector)
    float radius;     // R
};

struct HitRecord {
    float t;          // ray parameter at intersection
    Vec3  p;          // intersection point
    Vec3  n;          // surface normal at p (should be ±N)
    float u, v;       // texture coordinates in [0,1]×[0,1]
};

-------------------------------------------------------------------------------
2.  Function signature
-------------------------------------------------------------------------------
bool intersectDisc(
    const Ray&    ray,
    const Disc&   disc,
    float         tMin,      // minimum valid t (e.g. 0.001)
    float         tMax,      // maximum valid t (e.g. +∞)
    HitRecord&    rec        // output parameter
);

Returns true if the ray intersects the filled disc at some t ∈ [tMin, tMax], filling in rec; otherwise returns false.

-------------------------------------------------------------------------------
3.  Intersection algorithm
-------------------------------------------------------------------------------
1.  Compute denom = dot(ray.direction, disc.normal).  
    If |denom| < ε (e.g. 1e–6), the ray is parallel to the disc’s plane → no hit.

2.  Solve for t:
       t = dot(disc.center – ray.origin, disc.normal) / denom
    If t < tMin or t > tMax, → no hit.

3.  Compute the candidate hit point:
       P = ray.origin + t * ray.direction

4.  Check if P lies within the disc’s radius:
       if length(P – disc.center) > disc.radius → no hit

5.  Otherwise, we have a valid intersection.  Fill in rec:
    a.  rec.t = t  
    b.  rec.p = P  
    c.  rec.n = (denom < 0) ? disc.normal : –disc.normal  
        (so that the normal always opposes the incoming ray)  
    d.  Compute a local basis (uAxis, vAxis) on the disc plane.  For example:
           Vec3 uAxis = normalize( cross( |disc.normal.x|>0.9 ? Vec3(0,1,0) 
                                          : Vec3(1,0,0),
                                          disc.normal ) );
           Vec3 vAxis = cross(disc.normal, uAxis);
    e.  Compute local coordinates in that basis:
           Vec3 d = P – disc.center;
           float x = dot(d, uAxis);
           float y = dot(d, vAxis);
    f.  UV mapping (polar):
           float theta = atan2(y, x);                // in (–π, π]
           if (theta < 0) theta += 2*PI;             // now in [0, 2π)
           rec.u = theta / (2*PI);                   // [0,1)
           rec.v = sqrt(x*x + y*y) / disc.radius;    // [0,1]

-------------------------------------------------------------------------------
4.  Example test cases
-------------------------------------------------------------------------------
Disc: center = (0,0,0), normal = (0,0,1), radius = 2  
tMin = 0.001, tMax = +∞

1) Ray origin = (0,0,5), direction = (0,0,–1)  
   – denom = dot((0,0,–1),(0,0,1)) = –1  
   – t = dot((0,0,0)–(0,0,5),(0,0,1)) / (–1) = (–5)/(–1) = 5  
   – P = (0,0,5) + 5*(0,0,–1) = (0,0,0)  
   – |P – center| = 0 ≤ 2 → hit  
   – θ = atan2(0,0) = 0 → u = 0  
   – v = sqrt(0)/2 = 0  

   Expected: hit at t=5, p=(0,0,0), n=(0,0,1), u=0, v=0

2) Ray origin = (1,1,3), direction = (0,0,–1)  
   – t = (0–3)/(–1) = 3  
   – P = (1,1,0), distance = √2 ≈1.414 ≤2 → hit  
   – x = dot((1,1,0),uAxis=(1,0,0))=1  
     y = dot((1,1,0),vAxis=(0,1,0))=1  
   – θ=atan2(1,1)=π/4 → u≈0.125  
   – v=√2/2≈0.707

3) Ray origin = (3,0,1), direction = (0,0,–1)  
   – t = 1  
   – P = (3,0,0), distance = 3 > 2 → no hit

4) Ray origin = (0,0,−1), direction = (0,0,1)  
   – t = 1, P=(0,0,0) → hit on back face  
   – denom > 0 so rec.n = –disc.normal = (0,0,−1)

-------------------------------------------------------------------------------
5.  What to submit
-------------------------------------------------------------------------------
– The source code for `intersectDisc(...)` (in C++, Java, Rust or your course language).  
– A brief comment on how you pick your local axes for UV mapping.  
– Output of the four test rays above, showing t, hit/no-hit, P, normal, (u,v).  

Good luck!

############### 5.5 ###############
Ray‐Disc Intersection (20 pts)  
In this exercise you will extend your ray tracer to handle intersections with a flat, filled disc in 3D. A disc is specified by  
– center point C ∈ ℝ³  
– unit normal vector N ∈ ℝ³ (‖N‖ = 1)  
– radius R > 0  
– (optional) material pointer  

A ray is given by  
– origin O ∈ ℝ³  
– unit direction D ∈ ℝ³ (‖D‖ = 1)  
– valid parameter interval [t_min, t_max]  

You must implement the function  
    bool hit_disc(const Ray& r, double t_min, double t_max,  
                  const Disc& disc, HitRecord& rec);  
which returns true if the ray r intersects the disc within [t_min, t_max]. On success it must fill rec.t, rec.p (the hit point), rec.normal (unit surface normal, oriented to face the incoming ray), and rec.u, rec.v (UV‐coordinates on the disc, see below).

1. Math derivation (3 pts)  
   (a) Show that the ray intersects the infinite plane of the disc at  
       t = ((C–O)·N) / (D·N),  
       provided D·N ≠ 0.  
   (b) Explain how to test whether the intersection point P = O + t D lies inside the radius R.

2. UV mapping (4 pts)  
   We define an orthonormal basis {U, V, N} where U and V lie in the disc’s plane. One way to pick U is:  
     U = normalize(arbitrary_vector × N),  
   then V = N × U.  
   For a point P on the disc let Δ = P – C, r′ = ‖Δ‖, θ = atan2(Δ·V, Δ·U) ∈ (–π,π].  
   Define  
     u = (θ + π) / (2π)  ∈ [0,1),  
     v = r′/R           ∈ [0,1].  

3. Implementation (13 pts)  
   Complete the following C++‐style stub. Your code should:  
   – reject rays parallel to the plane (|D·N| < ε)  
   – check t_min < t < t_max  
   – check r′ ≤ R  
   – orient the normal so it opposes the ray direction  
   – compute (u,v) as above  

```cpp
// Vector functions: dot(a,b), cross(a,b), normalize(v), length(v)
// Ray:    origin O, direction D
// HitRecord: double t; Vec3 p; Vec3 normal; double u,v;
// Disc:   Vec3 center; Vec3 normal; double radius; Material* mat_ptr;

bool hit_disc(const Ray& r,
              double t_min, double t_max,
              const Disc& disc,
              HitRecord& rec)
{
    // 1) Compute denom = D·N
    double denom = dot(r.direction, disc.normal);
    if (fabs(denom) < 1e-6) 
        return false;           // Ray is parallel to disc

    // 2) Compute t for plane intersection
    double t = dot(disc.center - r.origin, disc.normal) / denom;
    if (t < t_min || t > t_max)  
        return false;

    // 3) Compute intersection point P
    Vec3 P = r.origin + t * r.direction;

    // 4) Check if P lies inside the disc radius
    Vec3 Δ = P - disc.center;
    double dist2 = dot(Δ, Δ);
    if (dist2 > disc.radius * disc.radius)
        return false;

    // 5) Fill record
    rec.t      = t;
    rec.p      = P;

    // 5a) Choose orthonormal (U,V) in plane
    Vec3 U = normalize(fabs(disc.normal.x) > 0.9 
                 ? cross(Vec3(0,1,0), disc.normal)
                 : cross(Vec3(1,0,0), disc.normal));
    Vec3 V = cross(disc.normal, U);

    // 5b) Compute polar coords on disc
    double rprime = sqrt(dist2);
    double theta  = atan2(dot(Δ, V), dot(Δ, U)); 
    rec.u = (theta + M_PI) / (2.0 * M_PI);
    rec.v = rprime / disc.radius;

    // 5c) Orient normal to oppose the ray
    Vec3 outward_normal = disc.normal;
    if (dot(r.direction, outward_normal) > 0)
        outward_normal = -outward_normal;
    rec.normal = outward_normal;

    rec.mat_ptr = disc.mat_ptr;
    return true;
}
```

Explain each step with brief comments and be sure your implementation handles all edge cases.

############### 5.6 ###############
Ray–Disc Intersection Programming Exercise

In this exercise you will implement a ray–disc intersection test. A disc is a flat, circular surface in 3D space, specified by:

  • Center point C (Vec3)  
  • Unit normal vector N (Vec3) pointing “up” from the disc’s surface  
  • Radius R (float)

A ray is given by  
  R(t) = O + t·D,  t ≥ 0  
where O is the ray origin (Vec3) and D is a unit‐length direction vector (Vec3).

Your task is to:

1.  Derive the intersection parameter t at which the ray meets the plane of the disc.  
2.  Check whether the intersection point lies within the disc’s radius.  
3.  If it does, return hit‐data (t, hit point, disc normal); otherwise report “no hit.”

Part A – Mathematical Derivation  
--------------------------------  
1.  Write down the plane equation for the disc in point‐normal form.  
2.  Show that the ray–plane intersection tₚₗₐₙₑ is given by:

      tₚₗₐₙₑ = dot(C − O, N) / dot(D, N)

   and explain what happens when dot(D, N) ≈ 0.  
3.  Show that once you have tₚₗₐₙₑ, the intersection point P = O + tₚₗₐₙₑ·D lies on the plane, and that it is within the disc if

      |P − C| ≤ R.

Part B – Implementation  
------------------------  
Implement the following function in C++ (or your language of choice). Assume you have a small vector library with Vec3 supporting +, −, dot(), length(), and normalized vectors.

```cpp
struct Ray {
    Vec3 origin;      // O
    Vec3 direction;   // D, assumed normalized
};

struct Disc {
    Vec3 center;      // C
    Vec3 normal;      // N, assumed normalized
    float radius;     // R
};

struct HitInfo {
    bool   hit;       // true if intersection occurs
    float  t;         // ray parameter
    Vec3   point;     // intersection point
    Vec3   normal;    // surface normal at intersection
};

// Return true and fill hitInfo if the ray intersects the disc in front of the origin.
bool intersectDisc(const Ray& ray, const Disc& disc, HitInfo& hitInfo);
```

Your implementation must:

  1.  Compute denominator den = dot(ray.direction, disc.normal).  
  2.  If |den| is very small (e.g. < 1e-6), return false (ray is parallel to the disc).  
  3.  Compute tₚₗₐₙₑ = dot(disc.center − ray.origin, disc.normal) / den.  
  4.  If tₚₗₐₙₑ < 0, return false (intersection is behind the ray origin).  
  5.  Compute P = ray.origin + tₚₗₐₙₑ · ray.direction.  
  6.  If (P − disc.center).length() > disc.radius, return false (outside the disc).  
  7.  Otherwise fill hitInfo with hit=true, t=tₚₗₐₙₑ, point=P, normal=disc.normal (or −disc.normal, depending on which side you consider “front”), then return true.

Part C – Test Cases  
--------------------  
Verify your code against these cases:

1.  Disc: center=(0, 0, 5), normal=(0, 0, 1), radius=2  
    Ray A: origin=(1, 1, 0), direction=(0, 0, 1)  
      • Should hit at t=5, point=(1, 1, 5), normal=(0,0,1).  
    Ray B: origin=(3, 0, 0), direction=(0, 0, 1)  
      • Misses (point at (3,0,5) is outside radius).  

2.  Disc: center=(0, 0, 0), normal=(1, 0, 0), radius=1  
    Ray: origin=(−2, 0.5, 0), direction=(1, 0, 0)  
      • Should hit at t=2, point=(0,0.5,0), normal=(1,0,0).  

3.  Disc: center=(0, 1, 0), normal=(0, 1, 0), radius=1.5  
    Ray: origin=(0, 0, 0), direction=(0, −1, 0)  
      • No hit (ray points away from the disc plane).

Deliverables  
------------  
• Your source code for `intersectDisc`.  
• A short write‐up showing the derivation from Part A.  
• Output of your test cases, demonstrating correct “hit”/“miss” classification, t-values, and hit points.

############### 5.7 ###############
Ray–Disc Intersection  
=====================

In this exercise you will write a function that tests a given ray against a single, planar disc in 3D.  The disc is specified by its center point, its unit‐length normal, and its radius.  If the ray hits the disc you must return the ray‐parameter *t* of the first intersection (the smallest positive *t*) and the intersection point and normal.

1) Definitions and data structures  
   • Ray R(t) = O + t D  
     – O: 3D origin point (vector)  
     – D: 3D direction vector, assumed normalized  
     – t ≥ 0  
   • Disc  
     – center C (vector)  
     – normal n (vector, ‖n‖ = 1)  
     – radius r > 0  
   • HitRecord (output)  
     – t: the ray‐parameter of intersection  
     – P: the point of intersection on the disc  
     – N: the surface normal at P (for a flat disc this is ±n)  

2) Ray–Disc Intersection Algorithm  
   To test R(t)=O+tD against the plane of the disc:  
   a. Compute denom = D⋅n.  
      • If |denom| < ε (e.g. ε=1e–6), the ray is parallel to the disc’s plane → no hit.  
   b. Compute t = ((C–O)⋅n) / denom.  
      • If t < 0 → the plane intersection is “behind” the ray origin → no hit.  
   c. Compute P = O + t D.  
   d. Check whether P lies within the radius of the disc:  
         if ‖P – C‖² ≤ r², it is on the disc.  
      Otherwise → no hit.  
   e. If all tests pass, record:  
      • HitRecord.t = t  
      • HitRecord.P = P  
      • HitRecord.N = (denom < 0 ?  n : –n)  
        (so that N always opposes the incoming ray direction)  

3) Programming Task  
   Implement in the language of your choice a function with this signature (here shown in C++‐style pseudocode):

   struct Vec3 { float x,y,z; /* → implement vector add, subtract, dot, scale, length2 */ };  
   struct Ray    { Vec3 O, D; };               // D is normalized  
   struct Disc   { Vec3 center, normal; float radius; };  // normal is normalized  
   struct HitRecord { float t; Vec3 P, N; };

   // Returns true if the ray hits the disc at t > 0.
   bool intersectDisc(const Ray& ray,
                      const Disc& disc,
                      HitRecord& hit)
   {
     // your code here
   }

   Requirements:  
   • Follow exactly the steps in the algorithm above.  
   • Use an epsilon test (e.g. 1e–6) when checking for parallelism.  
   • Ensure the returned normal points against the ray’s direction.  
   • Return the *smallest* positive t.

4) Example Test Case  
   Let  
     Ray   O = (0,–1, 0), D = normalize(0, 2, 5)  
     Disc  C = (0, 0, 0), n = (0, 1, 0), r = 2.0  
   – The plane is y=0; the ray points upward and forward.  
   – You should compute a positive t, a point P on the disc’s circle of radius 2, and N = (0,1,0).  

5) What to hand in  
   • Your source code for intersectDisc.  
   • A brief explanation (1–2 sentences) of how you handle the normal’s sign.  
   • The output (t, P, N) for the example test case above.

############### 5.8 ###############
Ray–Disc Intersection (Programming Exercise)

Background  
In this exercise you will extend your ray tracer to support a finite circular “disc” (a filled circle) lying in 3D space. The disc is specified by:  
 • Center point C ∈ ℝ³  
 • Unit‐length normal vector N ∈ ℝ³ (defines the plane of the disc)  
 • Radius R > 0  

A ray is specified by an origin O ∈ ℝ³ and a (normalized) direction D ∈ ℝ³.

Your task is to derive and implement a routine that tests a ray against a disc, computes the hit parameter t, and—when there is an intersection—fills in a simple hit record.

Problem Statement  
1. Mathematical Derivation (20 pts)  
   a) Show that the ray-plane intersection parameter is  
      t = ((C – O) · N) / (D · N),  
      provided D·N ≠ 0. Clearly state any assumptions you make (e.g. D·N ≠ 0, t > 0).  
   b) Once you have t, write the expression for the intersection point  
      P = O + t D.  
   c) State the condition on P that guarantees it lies within the disc of radius R.

2. Pseudocode / API Design (10 pts)  
   Propose a function signature in C++ (or Java/C#/pseudo‐C) named `intersectDisc`. It should take as input a ray and a disc and return a boolean indicating whether an intersection occurred. If there is a hit, it should also output at least the following in a HitRecord struct:  
     – float t           (ray parameter)  
     – Vec3  position    (hit point P)  
     – Vec3  normal      (the disc’s normal N)  
   Be sure to include any epsilon or parallel‐ray tests you need.

3. Implementation (30 pts)  
   Write the body of `intersectDisc` according to your signature. Your code must:  
   a) Reject rays whose direction is (nearly) parallel to the disc plane.  
   b) Compute t and reject hits with t ≤ 0 or t outside a supplied [tMin, tMax].  
   c) Compute the hit point P, then test whether |P – C| ≤ R.  
   d) If there is a valid hit, fill in the HitRecord and return true; otherwise return false.

4. Testing (10 pts)  
   Provide at least two test cases (ray + disc parameters) with known outcomes (hit/no‐hit). For each, give all inputs and the expected t, P, and hit normal N if a hit occurs.

5. (Optional) UV Mapping (10 pts)  
   A common way to assign 2D texture coordinates (u,v) to a disc is via polar coordinates around its center:  
     r′ = |P – C| / R,  
     θ = atan2((P–C)·T, (P–C)·B)   (where T, B are any two orthonormal basis vectors in the disc’s plane)  
     u = 0.5 + r′ cos θ / 2,   v = 0.5 + r′ sin θ / 2  
   Briefly outline how you would compute T and B given N, and how you would fill (u,v) into your HitRecord.

Submission  
• A PDF containing your derivations and pseudocode.  
• A .cpp (or .java, .cs) source file implementing `intersectDisc` and your test cases.  

Grading will emphasize correctness of the intersection test, clarity of derivation, and completeness of your test cases. Good luck!

############### 5.9 ###############
Ray–Disc Intersection (Programming Exercise)

Background  
A disc in 3D is the set of all points P satisfying  
 P = C + u·U + v·V  
where C ∈ ℝ³ is the center, U and V are two orthonormal tangent vectors spanning the plane of the disc, and u²+v² ≤ R² (R ≥ 0 is the radius). Equivalently, the disc can be specified by its center C ∈ ℝ³, a unit normal N ∈ ℝ³, and a scalar radius R.

A ray is given by  
 P(t) = O + t·D, t ≥ 0  
with origin O ∈ ℝ³ and direction D ∈ ℝ³ (assume D is normalized).

Goal  
Write code to test intersection of a ray with a finite, flat disc. If there is an intersection, your routine should return  
• the hit‐distance t (smallest t ≥ t_min),  
• the hit point P,  
• the surface normal at P,  
• (optionally) 2D parametric coordinates (u,v) on the disc.

Requirements  
1. Use the following C++‐style function signature (you may adapt type names):  
   ```cpp
   struct Ray { Vec3 origin; Vec3 dir; };       // dir need not be unit but you may assume it is
   struct Disc { Vec3 center; Vec3 normal;     // normal is guaranteed unit‐length
                 float radius; };
   struct Hit { float t; Vec3  p, n; float u, v; };

   // Returns true if ray hits disc in t ∈ [t_min, t_max], and fills hit record.
   bool intersectDisc(const Ray& ray,
                      const Disc& disc,
                      float t_min,
                      float t_max,
                      Hit& hit);
   ```
2. Your implementation must:
   a. Reject rays parallel (or nearly parallel) to the disc plane.  
   b. Compute the plane‐intersection parameter t:  
         denom = dot(ray.dir, disc.normal)  
         t = dot(disc.center – ray.origin, disc.normal) / denom  
      and only accept if t_min ≤ t ≤ t_max.  
   c. Compute the hit point P = ray.origin + t·ray.dir.  
   d. Reject if ‖P – disc.center‖ > disc.radius.  
   e. Set hit.n = ±disc.normal so that hit.n always opposes the incoming ray direction.  
   f. (Optional) Compute 2D coordinates (u,v) with u = angle around center ∈ [0,1), v = radial fraction ∈ [0,1]:
         • Let local = P – disc.center.  
         • Project local onto two orthonormal basis vectors U,V spanning the disc plane.  
         • θ = atan2(dot(V,local), dot(U,local)); if θ<0, θ += 2π.  
         • u = θ/(2π), v = ‖local‖/disc.radius.

3. Your code must handle numerical robustness (e.g. epsilon test for denom ≈ 0).

Questions  
1. Derive the formula for t (the intersection of a ray with the plane of the disc).  
2. Explain why checking ‖P–C‖ ≤ R ensures the intersection lies inside the disc.  
3. In your code, how do you choose the sign of the normal at the hit point?  
4. (Optional) Describe how your UV‐mapping will affect texturing the disc.  

Deliverables  
• Well‐commented source code for intersectDisc(…)  
• A short write‐up (1–2 pages) addressing questions 1–4 above.  
• One or two test cases (ray + disc) that exercise the parallel‐ray case, a hit inside, and a miss outside.

############### 6.0 ###############
Programming Assignment: Ray-Quad with Circular Hole Intersection

Background  
You are to extend a simple ray tracer with a new primitive: an axis-aligned (or arbitrarily oriented) rectangular quad in 3D that has a circular hole punched through its center.  A ray “hits” this object if it intersects the plane of the quad, lands inside the rectangle’s bounds, and lies outside the circular hole.

Object Description  
• Quad center point C (Vec3)  
• Orthonormal basis (U, V, N):  
  – U and V lie in the quad’s plane (U · V = 0, ∥U∥ = ∥V∥ = 1)  
  – N = U × V is the quad’s outward normal  
• Half‐width wu along U (i.e. full width = 2·wu)  
• Half‐height wv along V (i.e. full height = 2·wv)  
• Circular hole radius r centered at C, lying in the same plane

Ray Description  
• Origin O (Vec3)  
• Direction D (Vec3, assume normalized)  
• Valid t range [tMin, tMax]

Task  
Implement the function  
  bool IntersectQuadWithCircleHole(  
    const Ray& ray,  
    float tMin,  
    float tMax,  
    const Vec3& C,  
    const Vec3& U,  
    const Vec3& V,  
    float wu,  
    float wv,  
    float r,  
    float& outT,  
    Vec3& outNormal  
  );  

This function should return true if the ray intersects the quad (outside the hole) between tMin and tMax.  On a hit, it outputs the intersection distance outT and the surface normal (either +N or –N, chosen so that the normal opposes the incoming ray).

Detailed Requirements  

1.  Plane Intersection  
    • Compute denom = D · N.  
    • If |denom| < ε (use ε = 1e–6), the ray is parallel to the quad; return false.  
    • Compute t = ((C – O) · N) / denom.  
    • If t < tMin or t > tMax, return false.  

2.  Compute Hit Point and Local Coordinates  
    • P = O + t·D.  
    • Local coordinates relative to C:  
       x = (P – C) · U  
       y = (P – C) · V  

3.  Rectangle Bounds Test  
    • If |x| > wu or |y| > wv, return false.

4.  Circular Hole Test  
    • If x² + y² < r², the point is inside the hole; return false.

5.  Valid Hit  
    • outT = t  
    • Choose outNormal = (denom < 0 ? N : –N)  
    • Return true

What to Submit  
• Your implementation of IntersectQuadWithCircleHole (C++ or pseudocode is fine).  
• A brief explanation (1–2 paragraphs) of how you handle numerical robustness (e.g. your choice of ε, treatment of edge cases on the boundary of the hole or quad).  
• Two non-trivial test cases: include the ray parameters, quad parameters, and the expected result (hit/no hit, t value, normal).

Grading Criteria  
• Correctness of intersection logic (planes, bounds, hole)  
• Proper normal orientation  
• Handling of parallel rays and edge‐case alignment  
• Clarity and robustness of code/comments

############### 6.1 ###############
Ray‐QuadWithHole Intersection  
==============================  

In this exercise you will derive and implement a ray‐intersection test against a planar rectangular “quad” that has a circular hole cut out of its center.  A ray hitting the rectangle anywhere **outside** the hole counts as a hit; a ray that would land within the hole must be rejected.  

1) Mathematical derivation  
---------------------------  

   Let  
     • Ray:    O + t D,   where O∈ℝ³ is the origin, D∈ℝ³ is a unit direction, and t≥0  
     • Quad center: C∈ℝ³  
     • Quad normal: N∈ℝ³ (unit length)  
     • Quad width: w > 0 (extent along local u‐axis)  
     • Quad height: h > 0 (extent along local v‐axis)  
     • Hole radius: r ≥ 0 (circle centered at C in the quad’s plane)  

   You must also choose two orthonormal tangent vectors (û, v̂) spanning the quad’s plane, so that  
     N·û = 0, N·v̂ = 0, û·v̂ = 0, ‖û‖=‖v̂‖=1.  

   (a) Solve for the plane intersection parameter t:  
        denom = D·N  
        if |denom| < ε then no intersection (ray ∥ plane).  
        t = ( (C−O)·N ) / denom  
        if t < 0 then no intersection (hit is “behind” the ray).  

   (b) Compute the hit point P = O + t D.  

   (c) Project P into the quad’s local (u, v) coordinates:  
        p_u = (P − C)·û  
        p_v = (P − C)·v̂  

   (d) Check rectangular bounds:  
        if |p_u| > w/2 or |p_v| > h/2 then reject (outside the quad).  

   (e) Check circular hole:  
        if (p_u)² + (p_v)² < r² then reject (inside the hole).  

   (f) Otherwise accept the hit.  The surface normal is N (or −N if you wish two‐sided quads), and you may compute UV‐coordinates as:  
        u = (p_u / w) + 0.5  
        v = (p_v / h) + 0.5  

2) Programming task  
-------------------  

   • Define a data structure for Ray and for QuadHole:  
       struct Ray { Vec3 O, D; };  
       struct QuadHole {  
         Vec3 C;    // center  
         Vec3 N;    // normal (unit)  
         Vec3 u, v; // tangent axes (unit, orthogonal)  
         float w,h; // width, height  
         float r;   // hole radius  
       };  

   • Implement a function with signature (in C++‐style pseudocode):  
  
       bool intersectQuadHole(  
         const Ray& ray,  
         const QuadHole& q,  
         float& outT,     // distance along ray  
         Vec3& outPos,    // hit position  
         Vec3& outNorm,   // hit normal  
         float& outU,     // [0,1] texture u  
         float& outV      // [0,1] texture v  
       );  

   • In your implementation follow exactly the steps (a) through (f) above. Fill outT, outPos, outNorm, outU, outV if and only if you return true.  

3) Testing example  
------------------  

   Use the following concrete parameters to test your code:  
     • QuadHole q:  
         C = (0,0,5),  N = (0,0,−1)  
         u = (1,0,0),  v = (0,1,0)  
         w = 4,  h = 2,  r = 1  
     • Ray 1: O=(0,0,0), D=(0,0,1) → should hit at t=5, P=(0,0,5) but that’s inside the hole (r=1), so NO HIT.  
     • Ray 2: O=(1.5,0,0), D=(0,0,1) → intersects at P=(1.5,0,5).  Here p_u=1.5, p_v=0, (1.5)²>1² so OUTSIDE hole but within |u|≤2,|v|≤1 ⇒ HIT.  

Deliverables  
------------  
  • A short write‐up deriving your intersection test.  
  • Well‐commented source code for `intersectQuadHole`.  
  • A brief log of your test‐ray results, confirming both hit and miss cases.

############### 6.2 ###############
Ray‐Object Intersection: Axis‐Aligned Quad with a Circular Hole
========================================================================

Problem Statement
-----------------
You are to implement ray‐intersection tests against a flat, axis‐aligned square (quad) in the XY‐plane, but with a round hole cut out of its center.  The square is centered at the origin (0,0,0), lies in the plane z=0, and has side length 2.  A circular hole of radius 0.5 is centered at (0,0,0) as well.

Specifically:

  1. The quad’s four corners (in CCW order as seen from +z) are:
     A = (−1, −1, 0),
     B = (+1, −1, 0),
     C = (+1, +1, 0),
     D = (−1, +1, 0).

  2. The hole is the set of all points (x,y,0) satisfying x² + y² < (0.5)².

  3. The quad’s surface normal is (0,0,1) on its front side (the “top” side).

Your task is to write a method

    bool QuadWithHole::hit( const Ray& r,
                            float t_min,
                            float t_max,
                            HitRecord& rec ) const;

that returns true only if the ray `r(t) = r.origin + t * r.direction` hits the quad outside the circular hole, with t in [t_min, t_max].  If there is a valid hit, you must fill `rec` with:

  •  rec.t       — the ray parameter t at intersection  
  •  rec.p       — the intersection point  
  •  rec.normal  — the surface normal at rec.p (always (0,0,1))  
  •  rec.u, rec.v — the local UV coordinates on the quad, with u,v ∈ [0,1], where  
                     u = (x + 1) / 2,  v = (y + 1) / 2  

Data Structures
---------------
Assume the following definitions:

    struct Ray {
      Point3 origin;
      Vec3   direction;
    };

    struct HitRecord {
      Point3 p;
      Vec3   normal;
      float  t;
      float  u, v;
    };

    class QuadWithHole {
    public:
      // returns true if hit; fills rec
      bool hit(const Ray& r, float t_min, float t_max, HitRecord& rec) const;
    };

Requirements & Hints
--------------------

1.  **Plane Intersection**  
    - The quad lies in the plane z=0.  
    - Solve for t such that r.origin.z + t * r.direction.z = 0.  
    - If r.direction.z ≈ 0, the ray is parallel—no hit.

2.  **Check t‐Range**  
    - If the computed t is not in [t_min, t_max], return false.

3.  **Compute Intersection Point**  
    - Let P = r.origin + t * r.direction.

4.  **Quad Bounds Test**  
    - Check if P.x ∈ [−1, +1] and P.y ∈ [−1, +1].  
    - If either fails, return false.

5.  **Circular Hole Test**  
    - Compute d² = P.x² + P.y².  
    - If d² < (0.5)², the ray hits inside the hole ⇒ return false.

6.  **Fill HitRecord**  
    - rec.t      = t  
    - rec.p      = P  
    - rec.normal = Vec3(0, 0, 1)  
    - rec.u      = (P.x + 1) * 0.5  
    - rec.v      = (P.y + 1) * 0.5  

Example Skeleton Implementation (C++‐Style Pseudocode)
------------------------------------------------------

    bool QuadWithHole::hit(const Ray& r,
                           float t_min,
                           float t_max,
                           HitRecord& rec) const
    {
      // 1) Intersect plane z=0
      float dz = r.direction.z;
      if (fabs(dz) < 1e-6f)
        return false;                      // ray parallel

      float t = -r.origin.z / dz;
      if (t < t_min || t > t_max)
        return false;                     // out of range

      // 2) Compute intersection point
      Point3 P = r.origin + t * r.direction;

      // 3) Check quad bounds
      if (P.x < -1.0f || P.x > +1.0f ||
          P.y < -1.0f || P.y > +1.0f)
        return false;

      // 4) Check circular hole
      float dist2 = P.x*P.x + P.y*P.y;
      if (dist2 < 0.5f * 0.5f)
        return false;                     // inside hole

      // 5) Fill hit record
      rec.t      = t;
      rec.p      = P;
      rec.normal = Vec3(0, 0, 1);
      rec.u      = (P.x + 1.0f) * 0.5f;   // map x∈[−1,1] to u∈[0,1]
      rec.v      = (P.y + 1.0f) * 0.5f;   // map y∈[−1,1] to v∈[0,1]

      return true;
    }

Deliverables
------------
Submit your fully commented implementation of `QuadWithHole::hit(...)`.  You may assume standard vector and point classes with the usual operators are available. Make sure your code handles edge cases (parallel rays, rays grazing the hole edge, etc.) robustly.

############### 6.3 ###############
Ray–Quad-with-Circular-Hole Intersection 

Background  
You are extending a basic ray tracer to support a new “quad with a circular hole” primitive. This primitive lies in a single plane. Geometrically it is the region inside an axis-aligned rectangle (quad) but with a concentric circular hole cut out of its interior.

Your task is to write a function that tests a given ray against this primitive and, if there is a hit, returns the intersection distance t and the surface normal at the hit point.

Primitive specification  
• Plane: z = 0  
• Quad (rectangle) bounds: x ∈ [–1, +1], y ∈ [–1, +1]  
• Circular hole: center = (0,0,0), radius = 0.5  
• Surface normal: (0,0,+1) on the front side  

Ray specification  
struct Ray {  
  Vec3 origin;      // ray origin  
  Vec3 direction;   // normalized direction  
};  

Hit record specification  
struct HitRecord {  
  double t;         // ray‐parameter of intersection  
  Vec3 point;       // intersection point  
  Vec3 normal;      // surface normal at intersection  
};  

Function prototype (in C++‐style pseudocode)  
bool intersectQuadWithHole(  
    const Ray& ray,  
    double t_min,            // minimum acceptable t  
    double t_max,            // maximum acceptable t  
    HitRecord& outHit);      // on success, fill and return true  

Requirements  
1. Compute intersection of the ray with the plane z=0.  
   Plane equation: n·P = 0, where n=(0,0,1).  
   Solve for t_plane:  
     t_plane = –(n·ray.origin) / (n·ray.direction).  
2. Reject if t_plane < t_min or t_plane > t_max.  
3. Compute hit point P = ray.origin + t_plane * ray.direction.  
4. Test if P lies inside the quad:  
     –1 ≤ P.x ≤ +1  AND  –1 ≤ P.y ≤ +1.  
5. Test if P lies outside the circular hole:  
     P.x² + P.y² ≥ (0.5)².  
6. If both tests pass, fill outHit.t = t_plane, outHit.point = P, outHit.normal = (0,0,1) and return true. Otherwise return false.

Deliverables  
1. Complete the body of intersectQuadWithHole according to the requirements above.  
2. Provide at least two non-trivial test cases (ray origin/direction) that  
   • Hit the quad outside the hole  
   • Miss because they go through the hole  
   • Miss because they miss the quad entirely  

Example skeleton solution (you must fill in the “TODO” parts):

```
bool intersectQuadWithHole(
    const Ray& ray,
    double t_min,
    double t_max,
    HitRecord& outHit)
{
    // 1) Ray‐plane intersection
    Vec3 n(0,0,1);
    double denom = dot(n, ray.direction);
    // If denom is nearly zero, the ray is parallel to the plane
    if (fabs(denom) < 1e-8)
        return false;

    double t_plane = -dot(n, ray.origin) / denom;
    if (t_plane < t_min || t_plane > t_max)
        return false;

    // 2) Compute the intersection point
    Vec3 P = ray.origin + t_plane * ray.direction;

    // 3) Quad bounds test
    if (P.x < -1.0 || P.x >  1.0 ||
        P.y < -1.0 || P.y >  1.0)
    {
        return false;
    }

    // 4) Circular hole test
    double dist2 = P.x * P.x + P.y * P.y;
    if (dist2 < 0.5 * 0.5)
        return false;

    // 5) Record hit information
    outHit.t      = t_plane;
    outHit.point  = P;
    outHit.normal = n;   // always (0,0,+1)

    return true;
}
```

Test-Case Examples  
1) Ray from (0,  0,  5) toward (0,  0, –1)  
   – Should miss (goes through the hole).  
2) Ray from (0.75, 0, 5) toward (0,  0, –1)  
   – Should hit at P=(0.75,0,0). t=5.  
3) Ray from (2, 2, 5) toward (0,  0, –1)  
   – Should miss (outside the quad bounds).  

Be sure to test cases where the ray is nearly parallel to the plane as well.

############### 6.4 ###############
Ray–Quad Intersection with a Circular Hole

In this exercise you will write a routine that tests a ray against an axis-aligned square (a “quad”) in the plane z=0, but with a circular hole cut out of its center.

――――――――――――――――――――――――――――――  
Object description  
――――――――――――――――――――――――――――――  

1.   Quad (square) lies in the plane z = 0.  
2.   Its four vertices, listed in counter-clockwise order as seen from +z, are:  
     v0 = (–1, –1, 0)  
     v1 = (+1, –1, 0)  
     v2 = (+1, +1, 0)  
     v3 = (–1, +1, 0)  
3.   The quad’s outward normal is n = (0, 0, +1).  
4.   There is a circular hole of radius R = 0.5 centered at (0, 0, 0) in the plane z=0.  
     Any point whose (x, y)-distance to the origin is < R lies in the hole and should NOT count as a hit.  

――――――――――――――――――――――――――――――  
Ray description  
――――――――――――――――――――――――――――――  

A ray is defined by  
   R(t) = O + t·D,  
where  
   • O = (Ox, Oy, Oz) is the ray origin,  
   • D = (Dx, Dy, Dz) is a normalized direction vector,  
   • t ∈ [tMin, tMax] is the valid interval along the ray.  

――――――――――――――――――――――――――――――  
Your task  
――――――――――――――――――――――――――――――  

1.  Derive the value of t at which the ray intersects the plane z=0:  
       n·(O + tD) = 0  
   and solve for t.  

2.  In code, reject the intersection if:  
     a.  The ray is parallel to the quad (i.e. n·D ≈ 0).  
     b.  t is not in the range [tMin, tMax].  

3.  Compute the hit point P = O + tD.  Then test:  
     a.  P.x < –1  or  P.x > +1  → outside the square → no hit  
     b.  P.y < –1  or  P.y > +1  → outside the square → no hit  
     c.  (P.x)² + (P.y)² < R²  → inside the circular hole → no hit  

4.  If none of the above rejects occur, you have a valid intersection at t.  
   Fill a hit record with:  
     • t  
     • position P  
     • normal n = (0, 0, +1)  

5.  Return true if you hit the quad (outside the hole), false otherwise.  

――――――――――――――――――――――――――――――  
Starter code (C++‐style pseudocode)  
――――――――――――――――――――――――――――――  
struct Vec3 { float x,y,z; /* … vector ops … */ };  
struct Ray  { Vec3 o, d;           };  // d is normalized  
struct Hit {  
  float    t;        // hit time  
  Vec3     p;        // hit point  
  Vec3     normal;   // surface normal  
};  

bool intersectQuadWithHole(  
    const Ray& ray,  
    float       tMin,   // minimum valid t  
    float       tMax,   // maximum valid t  
    Hit&        outHit  // output on success  
) {  
  const Vec3 n = {0, 0, 1};  
  const float R     = 0.5f;  
  const float denom = dot(n, ray.d);  
  // 1) Reject if parallel or back-facing  
  if (fabs(denom) < 1e-6f)  
    return false;  

  // 2) Solve for t where ray hits plane z=0  
  float t = -dot(n, ray.o) / denom;  
  if (t < tMin || t > tMax)  
    return false;  

  // 3) Compute intersection point  
  Vec3 P = ray.o + ray.d * t;  

  // 4) Reject if outside quad bounds  
  if (P.x < -1.0f || P.x > +1.0f)  return false;  
  if (P.y < -1.0f || P.y > +1.0f)  return false;  

  // 5) Reject if inside circular hole  
  if (P.x*P.x + P.y*P.y < R*R)  
    return false;  

  // 6) Success: fill hit record  
  outHit.t      = t;  
  outHit.p      = P;  
  outHit.normal = n;  
  return true;  
}  

――――――――――――――――――――――――――――――  
What to submit  
――――――――――――――――――――――――――――――  

• A brief derivation of the plane‐intersection formula  
• The completed code (or pseudo‐code) above  
• A short explanation of each rejection test  
• (Optional) Two or three sample rays and the expected result (hit or miss)  

Answer clearly, concisely, and ensure your code handles all edge cases listed.

############### 6.5 ###############
Ray-Object Intersection: Quad with Circular Hole
===============================================

In this exercise you will implement a ray­-intersection test for an object that is a flat rectangular quad in the plane z = 0 with a circular “window” cut out of its center.  The quad is axis-aligned and the hole is centered inside it.  Your task is to detect whether a given ray hits the solid part of this object (the quad minus its hole) and, if so, to compute the hit parameters.

1. Object Description
   -------------------
   • Quad plane: z = 0  
   • Quad corners (in CCW order as seen from +z):  
     v0 = (–1, –1, 0)  
     v1 = ( +1, –1, 0)  
     v2 = ( +1, +1, 0)  
     v3 = (–1, +1, 0)  
   • Circular hole: center C = (0, 0, 0), radius R = 0.5  

   Thus the “solid” region is all points on the plane z=0 that lie within the square [–1, 1]×[–1, 1] but whose distance to (0,0,0) is ≥ 0.5.

2. Ray & HitRecord Data Structures
   --------------------------------
   Assume the following simplified C++ structs (you may adapt to your own code):

     struct Ray {
       Vec3 origin;        // ray origin
       Vec3 direction;     // unit-length direction
       float t_min, t_max; // valid interval for t
     };

     struct HitRecord {
       float t;            // ray parameter at hit
       Vec3 p;             // hit point = origin + t*direction
       Vec3 normal;        // surface normal at hit
       float u, v;         // optional: local UV coordinates
     };

3. Function Signature
   --------------------
   Implement:

     bool intersectQuadWithHole(const Ray& r,
                                HitRecord& rec);

   On success (intersection), return true and fill rec with:
   – rec.t        : the smallest t ∈ [r.t_min, r.t_max]  
   – rec.p        : the intersection point  
   – rec.normal   : outward surface normal (for this flat quad, it’s either +z or –z)  
   – rec.u, rec.v : optional: 2D coordinates mapped from the quad (see below)  

4. Algorithm Outline
   ------------------
   1. Ray­-Plane Intersection  
      • Plane equation: z = 0 → normal N_plane = (0,0,1).  
      • Compute denom = dot(r.direction, N_plane).  
        – If |denom| < ε (e.g. 1e–6), ray is parallel → no hit.  
      • Compute t_hit = –(r.origin.z) / denom.  
      • If t_hit ∉ [r.t_min, r.t_max], return false.

   2. Compute Hit Point  
      • P = r.origin + t_hit * r.direction.

   3. Check Quad Bounds  
      • If P.x < –1 or P.x > +1 or P.y < –1 or P.y > +1, return false.

   4. Check Circular Hole  
      • Let d2 = P.x*P.x + P.y*P.y.  
      • If d2 < R*R (i.e. < 0.25), P is inside the hole → return false.

   5. Record Hit  
      • rec.t = t_hit  
      • rec.p = P  
      • rec.normal = denom < 0 ? (0,0,1) : (0,0,–1)  
          (So that the normal always opposes the entering ray.)  
      • Optionally compute (u,v) on the quad:  
          u = (P.x + 1) * 0.5  
          v = (P.y + 1) * 0.5  
        These map (–1,–1)→(0,0), (+1,+1)→(1,1).

5. What to Submit
   ----------------
   • Your C++ (or pseudocode) implementation of intersectQuadWithHole.  
   • A brief explanation (2–3 sentences) of how you handle the parallel‐ray case, the quad‐vs‐hole test, and the choice of normal direction.  
   • (Optional) Two or three example rays (origin + direction) along with your program’s output (hit/no-hit, t, p, normal).

Grading will focus on correctness of t, correct inside/outside tests for both quad and hole, and a consistent normal direction. Good luck!

############### 6.6 ###############
Ray–Quad-with-Circular‐Hole Intersection

In this exercise you will extend the basic ray–plane and ray–quad intersection tests by “punching” a circular hole out of your quad.  Your task is to write a function

    bool intersectQuadWithHole(
        const Ray&    ray,        // input ray: origin + direction (normalized)
        float&        tHit,       // output: distance along ray to intersection
        Vec2&         uvHit       // output: local (u,v) coords on the quad
    );

that returns true if and only if the ray hits the rectangular region **minus** the circular hole.  If there is an intersection, `tHit` should be set to the smallest positive solution along the ray, and `uvHit` to the local quad‐coordinates of the hit point.

-----------------------------------------------------------------------
1. Object definition
-----------------------------------------------------------------------
– The quad lies in the plane z=0.  
– Its four corners are
    A = (0, 0, 0)  
    B = (2, 0, 0)  
    C = (2, 1, 0)  
    D = (0, 1, 0)  

– We parameterize the quad by  
    P(u,v) = A + u·(B–A) + v·(D–A),  
  where 0 ≤ u ≤ 1, 0 ≤ v ≤ 1.

– The circular hole is centered at  
    H = (1.0, 0.5, 0)  
  with radius  
    r = 0.25  

-----------------------------------------------------------------------
2. Intersection algorithm outline
-----------------------------------------------------------------------
1. Compute the plane normal  
     E1 = B–A,  E2 = D–A  
     n  = normalize(cross(E1, E2))  // here n = (0,0,1) or (0,0,–1)

2. Ray–plane intersection  
     den = dot(n, ray.direction)  
     if (|den| < ε) return false;  // ray is parallel  
     t = dot(n, A – ray.origin) / den  
     if (t ≤ 0) return false;       // intersection is behind the ray

3. Compute the hit point  
     P = ray.origin + t·ray.direction

4. Project P into quad’s (u,v)  
     vP = P – A  
     u = dot(vP, E1) / dot(E1, E1)  
     v = dot(vP, E2) / dot(E2, E2)  
     if (u < 0 || u > 1 || v < 0 || v > 1)  
         return false;   // outside the rectangular region

5. Test against the circular hole  
     Vec3 offset = P – H  
     if (dot(offset, offset) < r²)  
         return false;   // inside the hole

6. Success: fill outputs  
     tHit = t  
     uvHit = Vec2(u, v)  
     return true

-----------------------------------------------------------------------
3. What to hand in
-----------------------------------------------------------------------
– Your fully commented C++ (or C) implementation of `intersectQuadWithHole`.  
– A brief written explanation (1–2 paragraphs) of each major step:
   • plane–ray intersection  
   • mapping into (u,v)  
   • hole test  
– A few test rays (origin + direction) and whether you expect them to hit or miss  
  with brief justifications.  

Make sure your code handles rays parallel to the quad, rays that hit the solid part of the quad, and rays that pass through the circular opening.

############### 6.7 ###############
Ray–Quad-with–Circular‐Hole Intersection  
======================================

In this exercise you will write a function that tests a ray against a single planar quadrilateral that has a circular hole cut out of its interior.  If the ray hits the quad but the hit‐point falls inside the circular hole, the ray is considered to miss.

——————————————————————————————  
Geometry Setup  
——————————————————————————————  
• Quad vertices (counter-clockwise):  
  V0 = (1, 0, 0)  
  V1 = (3, 0, 0)  
  V2 = (3, 2, 0)  
  V3 = (1, 2, 0)  

• Quad lies in the plane z = 0 with outward normal N = (0, 0, +1).  

• Circular hole: center C = (2, 1, 0), radius r = 0.5.  

• Local UV coordinates on the quad:  
  – U axis runs from V0→V1 (length 2 → u in [0,1])  
  – V axis runs from V0→V3 (length 2 → v in [0,1])  

——————————————————————————————  
Function Specification  
——————————————————————————————  
Implement the following function in C++, Java or pseudocode of your choice:

bool intersectQuadWithCircleHole(  
    const Ray&     ray,  
    float&         thit,        // out: distance along ray to hit  
    Vec3&          hitNormal,   // out: surface normal at hit  
    Vec2&          hitUV        // out: (u,v) on quad, each ∈ [0,1]  
);

Where:  
• Ray has origin O and (unit) direction D.  
• The function returns true if the ray hits the quad outside the hole; otherwise false.  
• On a hit, thit must be the smallest positive t such that O + t D lies on the quad—but not in the hole.  
• hitNormal must be (0,0,1).  
• hitUV must be the local coordinates inside the quad:  
    u = ((P − V0)·(V1 − V0)) / |V1 − V0|²  
    v = ((P − V0)·(V3 − V0)) / |V3 − V0|²  

——————————————————————————————  
Implementation Hints  
——————————————————————————————  
1.  Compute ray–plane intersection:  
     t = −(O·N + d) / (D·N)  
    where the plane equation is N·P + d = 0.  For our quad, d = 0 since V0 has z=0.  

2.  If D·N ≈ 0 or t ≤ 0, reject (no hit or behind the ray).  

3.  Compute P = O + t D.  Check that P’s x and y lie within the quad bounding box:  
     1 ≤ P.x ≤ 3,  0 ≤ P.y ≤ 2.  

4.  Compute local (u,v) as above.  If u<0 or u>1 or v<0 or v>1, reject.  

5.  Test for the circular hole:  
     if  (P.x − 2)² + (P.y − 1)²  <  r²   then reject.  

6.  Otherwise you have a valid hit: set thit, hitNormal=(0,0,1), hitUV=(u,v), and return true.  

——————————————————————————————  
Example Test Rays  
——————————————————————————————  
1. Ray( O=(2,1,−1), D=(0,0,1) )  
   • Hits at t=1, P=(2,1,0) but that is inside the hole ⇒ return false.  

2. Ray( O=(1.5,0.5,−1), D=(0,0,1) )  
   • Hits at t=1, P=(1.5,0.5,0), u=0.25, v=0.25, outside hole ⇒ return true.  

3. Ray( O=(4,1,1), D=(−1,0,0) )  
   • Intersects plane at z=0? No (D.z=0) ⇒ return false.  

——————————————————————————————  
Submission  
——————————————————————————————  
Provide:  
• Your complete function implementation.  
• Brief comments explaining each step.  
• Output of the example test rays.  

Good luck!

############### 6.8 ###############
Ray-Object Intersection: Quad with Circular Hole

In this exercise you will implement a ray-intersection test against a rectangular quad (axis‐aligned in the z=0 plane) that has a circular hole cut out of its center.  Your function should return whether the ray hits the remaining (solid) part of the quad, and if so at what parameter t and with what surface normal.

Object definition  
1. The quad lies in the plane z = 0.  
2. Its four corners are A = (–1, –1, 0), B = ( 1, –1, 0), C = ( 1,  1, 0), D = (–1,  1, 0).  
3. There is a circular hole of radius r = 0.5 centered at (0, 0, 0).  
4. The “solid” part of the object is the set of points P = (x, y, 0) such that  
   a. –1 ≤ x ≤ 1 and –1 ≤ y ≤ 1,  
   b. and x² + y² ≥ (0.5)².  

Ray definition  
• Ray origin: O = (Ox, Oy, Oz)  
• Ray direction: D = (Dx, Dy, Dz), assumed normalized.  
• Ray equation: R(t) = O + t·D, t ≥ 0

Task  
Write a function with this signature (in C++-style pseudocode):  
bool intersectQuadWithHole(  
    const Ray& ray,     // input ray  
    float& tHit,        // output: ray parameter at intersection  
    Vec3& normalOut     // output: surface normal at hit  
);

The function should:  
1. Check if the ray is parallel to the plane z=0. If so, return false.  
2. Compute tPlane = (0 – Oz) / Dz. If tPlane ≤ 0, return false.  
3. Compute intersection point P = O + tPlane·D.  
4. Check quad bounds: if P.x < –1 or P.x > 1 or P.y < –1 or P.y > 1, return false.  
5. Check hole region: if (P.x)² + (P.y)² < 0.25, return false.  
6. Otherwise, you have a hit: set tHit = tPlane, normalOut = (0, 0, 1) (since the quad is front‐facing in +z). Return true.

Requirements  
• Clearly handle the case when Dz is zero (ray parallel to quad).  
• Only accept intersections with t > 0 (in front of the ray origin).  
• Return the upward‐pointing normal (0,0,1).  
• Use exactly the bounds and hole size given; do not introduce extra margins.  

Example test rays (for your own verification)  
1. Ray O=(0,0,–1), D=(0,0,1)  
   – Hits at P=(0,0,0) but that is inside the hole → no intersection.  
2. Ray O=(0.75,0,–1), D=(0,0,1)  
   – Hits at P=(0.75,0,0). 0.75²+0² ≥ 0.25 and within [–1,1]→ intersection at t=1, normal=(0,0,1).  
3. Ray O=(2,0,–1), D=(0,0,1)  
   – P=(2,0,0) outside quad bounds → no intersection.  
4. Ray O=(0,0,1), D=(0,0,1)  
   – Ray points away from quad → tPlane negative → no intersection.

Submit your implementation of intersectQuadWithHole. Make sure it passes all of the above sanity checks without any special cases beyond those described.

############### 6.9 ###############
Ray‐Quad with Circular Hole Intersection  
=======================================

In this exercise you will implement ray‐intersection against a flat, axis‐aligned rectangle (quad) in the plane z = 0, but with a circular hole cut out of its center.  Points that lie inside the circle are “empty” and must not report a hit.  

--------------------------------------------------------------------------------  
Object Description  
------------------  
• Quad (rectangle) lies in the plane z = 0.  
• Its four corners (in counter‐clockwise order) are:  
  A = (−1, −1, 0)  
  B = (+1, −1, 0)  
  C = (+1, +1, 0)  
  D = (−1, +1, 0)  
• It has a circular hole of radius R = 0.5, centered at the origin (0, 0, 0).  
• The surface normal of the quad (outside the hole) is (0, 0, +1).  

--------------------------------------------------------------------------------  
Task  
----  
1.  Implement the function  
      bool intersectQuadWithHole(const Ray& ray, float tMin, float tMax, Hit& hit)  
    which returns true if the ray hits the quad (outside the hole) between tMin and tMax, false otherwise.  
2.  If there is a hit, fill in `hit.t`, `hit.point`, `hit.normal`, and 2D surface‐parameter `hit.uv`.  

You are given these data structures:  
  struct Ray {  
    Vec3 origin;    // ray origin  
    Vec3 dir;       // normalized direction  
  };  

  struct Hit {  
    float t;        // ray‐parameter of intersection  
    Vec3 point;     // intersection point  
    Vec3 normal;    // surface normal at point  
    Vec2 uv;        // 2D parameter on quad, u,v ∈ [0,1]×[0,1]  
  };  

You may assume:  
 - right‐handed coordinate system;  
 - `ray.dir.z` may be positive or negative;  
 - if ray is parallel to the quad (i.e. dir.z == 0) there is no intersection;  
 - points exactly on the circular boundary (distance == R) should be treated as “inside the hole” (no hit);  
 - points exactly on the quad edges (x==±1 or y==±1) count as a hit.  

--------------------------------------------------------------------------------  
Outline of a Correct Solution  
-----------------------------  
1.  Solve for plane intersection  
      t = −ray.origin.z / ray.dir.z  
    If ray.dir.z == 0 or t < tMin or t > tMax, return false.  

2.  Compute intersection point  
      P = ray.origin + t * ray.dir  

3.  Test against quad bounds  
      if P.x < −1 or P.x > +1 or P.y < −1 or P.y > +1  
        return false  

4.  Test against circular hole  
      if (P.x*P.x + P.y*P.y) ≤ R*R   // use ≤ so boundary is excluded  
        return false  

5.  Otherwise we have a valid hit:  
      hit.t = t  
      hit.point = P  
      hit.normal = Vec3(0,0,1)       // upward‐facing normal  

   Compute 2D quad‐UV by mapping x,y ∈ [−1,1] → u,v ∈ [0,1]:  
      hit.uv.x = (P.x + 1) * 0.5  
      hit.uv.y = (P.y + 1) * 0.5  

   return true  

--------------------------------------------------------------------------------  
Example Test Cases  
------------------  
1) Ray origin = (0,0, 1), dir = (0,0,−1), tMin=0.001, tMax=100  
   Intersection point = (0,0,0), but (0²+0²)=0 < R² ⇒ inside hole ⇒ no hit.  

2) Ray origin = (0.75,0,1), dir = (0,0,−1), tMin=0.001, tMax=100  
   P = (0.75,0,0) is within [−1,1]² and 0.75²=0.5625 > 0.25 ⇒ outside hole ⇒ hit:  
   t=1.0, normal=(0,0,1), uv=( (0.75+1)/2, (0+1)/2 ) = (0.875, 0.5).  

3) Ray parallel to plane (dir.z=0) ⇒ no hit.  

--------------------------------------------------------------------------------  
What to Submit  
---------------  
• Your implementation of `intersectQuadWithHole(...)`.  
• Brief comment on how you handle edge cases (parallel rays, boundary tests).  
• (Optional) An AABB for this object: min = (−1,−1,0), max = (+1,+1,0).

############### 7.0 ###############
Ray–Plane with Triangular Hole Intersection  

In this exercise you will implement a ray‐object intersection routine for a special primitive: an infinite plane in 3D that has a triangular “cut‐out” (a hole).  Any ray that hits the plane outside the triangle should report a hit; any ray that hits inside the triangle must pass through (no hit).  

1. Data Structures  
   • Ray  
     • origin:  Vec3 O  
     • direction:  Vec3 D   (assume D is normalized)  
   • Intersection result  
     • bool   intersects  
     • double tHit       (distance along the ray; t>0)  
     • Vec3   hitNormal (unit normal at the hit point)  

2. Primitive Definition  
   • Plane  
     • point on plane:    P0 = (0, 0, 0)  
     • unit normal:       N  = (0, 0, 1)  
       (so the plane equation is N·(X–P0) = 0, i.e. z=0)  
   • Triangular Hole (all vertices lie exactly in the plane z=0)  
     • V0 = ( 1,  0, 0)  
     • V1 = ( 0,  1, 0)  
     • V2 = (−1, 0, 0)  

3. Intersection Algorithm Outline  
   Implement a function with this signature in the language of your choice:  

     bool intersectPlaneWithTriangleHole(
       const Ray& ray,
       double& out_tHit,
       Vec3&   out_hitNormal
     );  

   The function should:  
   1. Compute denom = N · ray.D.  
      • If |denom| < ε  (e.g. ε = 1e−6), the ray is parallel → return false.  
   2. Compute t = N · (P0 – ray.O) / denom.  
      • If t ≤ 0  → intersection is behind the ray origin → return false.  
   3. Compute intersection point P = ray.O + t·ray.D.  
   4. Determine whether P lies inside the triangle V0,V1,V2.  
      You may use any correct method (e.g. barycentric‐coordinate test or edge‐sign tests).  
      • If P is inside or on the boundary of triangle V0V1V2 → this region is a hole → return false.  
      • Otherwise → it is a valid hit.  
   5. On a valid hit, set:  
      • out_tHit     = t  
      • out_hitNormal = N  (or −N, if you want the normal to point against the incoming ray)  
      • return true  

4. Testing  
   (a) Ray from above, pointing down through the hole:  
       O = (0.0, 0.0,  2.0),  D = (0.0, 0.0, −1.0)  
       → Should report no hit because the ray passes through the triangular hole.  

   (b) Ray from above, pointing down just outside the hole:  
       O = ( 0.75, 0.75, 2.0),  D = (0.0, 0.0, −1.0)  
       → Should report a hit at t = 2.0, normal = (0,0,1).  

   (c) Ray from below, pointing up through the plane outside the hole:  
       O = (−2.0,  0.2, −1.0),  D = (1.0, 0.0, 1.0) normalized  
       → Computes t>0 and a valid hit; normal orientation is your choice (flip if necessary).  

Deliverables:  
  • Complete source code for intersectPlaneWithTriangleHole(…)  
  • A brief explanation of your triangle‐inside test  
  • Results (tHit and normal) for the three test rays above.

############### 7.1 ###############
Ray–Plane Intersection with a Triangular “Hole”  

In this exercise you will implement a function that tests a ray against an infinite plane which has had a single triangular region removed (i.e. a “hole”).  If the ray hits the plane at a point outside the triangular hole, your function should report the intersection; if the ray would pass through the hole, it must report “no hit.”  

--------------------------------------------------------------------------------  
1) Scene description  

• Plane: Defined by a point P₀ and a unit normal **n**.  The plane is infinite in extent, except for the triangular region removed.  
• Triangle hole: Three vertices v₀, v₁, v₂ all lie exactly in the plane.  That triangle is “cut out” of the plane (i.e. rays passing through that triangular region see background).  
• Ray: Has origin **o** and (normalized) direction **d**.  

--------------------------------------------------------------------------------  
2) Your task  

Write a function with signature (you may adapt to your language of choice):  
    bool intersectPlaneWithTriangleHole(  
        const Ray& ray,               // ray.o, ray.d  
        const Vec3& P0,               // a point on the plane  
        const Vec3& N,                // plane normal (unit‐length)  
        const Vec3& v0, v1, v2,       // triangle‐hole vertices  
        float& outT,                  // (output) distance along ray to hit  
        Vec3& outP                   // (output) intersection point  
    );  

It should return true only if:  
  a) The ray intersects the plane at parameter t > ε (you may choose ε = 10⁻⁴).  
  b) The intersection point P = o + t·d lies **outside** the triangle (v₀,v₁,v₂).  

Otherwise return false.  

--------------------------------------------------------------------------------  
3) Hints  

A) Ray–plane intersection  
  1. Compute denom = dot(N, d).  If |denom| < ε, the ray is (nearly) parallel → no hit.  
  2. Compute t = dot(N, P₀ – o) / denom.  If t ≤ ε → no hit.  
  3. Intersection point P = o + t·d.  

B) Triangle‐hole test (point‐in‐triangle)  
  Method 1 (barycentric coordinates):  
    • Compute edge vectors e0 = v1 – v0, e1 = v2 – v0.  
    • Solve [e0 e1] · [u v]ᵀ = (P – v0).  
    • If u ≥ 0, v ≥ 0, and u+v ≤ 1 → P lies inside the triangle (i.e. in the hole).  

  Method 2 (half‐spaces):  
    For each triangle edge (vi→vj), compute the edge normal in the plane, test the sign of dot(edgeNormal, P–vi).  
    If all three tests are ≥ 0 (or all ≤ 0, depending on winding), P is inside the triangle.  

--------------------------------------------------------------------------------  
4) Example data and expected results  

Plane:  
  P₀ = (0,0,0),  N = (0,1,0)  

Triangle hole vertices (all y=0):  
  v₀ = (0,0,0),  v₁ = (1,0,0),  v₂ = (0,0,1)  

Test ray A (through the hole):  
  o = (0.5, 1, 0.2),  d = (0, –1, 0)  
  → denom = dot(N,d)=–1 → t = (0–1)/–1 = 1 → P = (0.5,0,0.2)  
  This P lies inside the triangle (u=0.5,v=0.2,u+v=0.7<1) → no hit (false).  

Test ray B (outside the hole):  
  o = (2, 1, 2),  d = (0, –1, 0)  
  → denom=–1 → t=1 → P=(2,0,2)  
  P is outside the triangle → report hit: t=1, P=(2,0,2).  

--------------------------------------------------------------------------------  
5) What you must submit  

• Source code of your function intersectPlaneWithTriangleHole.  
• A short derivation/description of how you compute t and how you test “inside‐triangle.”  
• Console or unit‐test output showing the two sample rays above and your function’s results.  

Grade will be based on correctness (both plane‐intersection and hole‐rejection), numerical robustness (use of ε), and clarity of implementation.

############### 7.2 ###############
Ray–Plane with a Triangular Hole  
================================

In this exercise you will implement a ray‐object intersection routine for the infinite plane z=0 that has a triangular “hole” cut out of it.  A ray hitting the plane anywhere outside the triangle should report a hit; a ray that would hit inside the triangle should report no hit.

Object Description  
------------------  
 • Plane: the infinite plane defined by z = 0.  
 • Plane normal: N = (0, 0, 1) (we treat the plane as one‐sided; rays must come from z>0 to hit).  
 • Hole: a triangle in that plane with vertices  
    v0 = (–1, 0, 0)  
    v1 = ( 1, 0, 0)  
    v2 = ( 0, 2, 0)  

Ray Definition  
--------------  
A ray is given by  
  R(t) = O + t D, t ≥ 0  
where O is the origin and D is a normalized direction.

Function Signature (C++‐style)  
-------------------------------  
```cpp
struct Vec3 { float x, y, z; /* plus vector ops */ };
struct Ray  { Vec3 origin, direction; };

/**
 * Intersect a ray with the plane z=0 that has a triangular hole.
 *
 * @param ray      The input ray (origin O, direction D must be normalized).
 * @param tHit     Output: the t-value of intersection along the ray.
 * @param hitP     Output: the 3D point of intersection.
 * @param normal   Output: the surface normal at the hit point.
 * @return         True if the ray intersects the plane outside the hole; 
 *                 false otherwise.
 */
bool intersectPlaneWithTriangleHole(
    const Ray&  ray,
    float&      tHit,
    Vec3&       hitP,
    Vec3&       normal);
```

What you must do  
-----------------  
1. **Ray–plane intersection**  
   • If D.z == 0, the ray is parallel → no hit.  
   • Compute t_plane = –O.z / D.z.  
   • If t_plane ≤ 0, the plane is behind or at the origin → no hit.  

2. **Compute intersection point**  
   • hitP = O + t_plane * D  

3. **Test against the triangular hole**  
   Determine whether hitP lies **inside** the triangle (v0,v1,v2) in the z=0 plane.  If it is inside, the ray “falls through” the hole → **no hit**.  
   
   You may use any robust inside‐triangle test, for example  
   – Barycentric coordinates: solve P = αv0 + βv1 + γv2 with α+β+γ=1 and check α,β,γ ≥ 0.  
   – Half‐space (edge‐normal) test: for each edge (vi → vj), check sign of cross((vj–vi), (P–vi))·N.  

4. **Return**  
   • If hitP is outside the triangle:  
       tHit = t_plane;  
       hitP = O + t_plane * D;  
       normal = (0,0,1);  
       return true;  
   • Otherwise return false.

Hints / Implementation Notes  
----------------------------  
• Be careful about numerical precision when testing inside/outside—points on an edge may be treated as outside (your choice) to avoid spurious hits.  
• Ensure you only return hits with tHit > 0.  
• The plane is one‐sided: we assume rays must intersect from z>0 (i.e. D.z < 0).  

Sample Test Cases  
-----------------  
1. Ray from O=(0, 1, 1), D=(0, –1, –1).normalized()  
   – Hits the plane at P=(0,0,0). This point lies on the edge between v0→v1. Depending on your edge‐test policy, you may count it as a hit (outside) or no‐hit.  

2. Ray from O=(0, 1, 1), D=(0, –0.5, –1).normalized()  
   – Hits P≈(0, 0.5, 0), which is strictly inside the triangle → no‐hit.  

3. Ray from O=(2, 1, 1), D=(–1, –1, –1).normalized()  
   – Hits plane P≈(1,0,0). Outside the triangle → hit.  

Deliverables  
------------  
Submit your fully commented implementation of  
   bool intersectPlaneWithTriangleHole(...)  
along with a brief explanation (2–3 sentences) of your inside‐triangle test.

############### 7.3 ###############
Ray-Plane Intersection with a Triangular Hole

In this exercise you will write a function that intersects a ray with an infinite plane (the X–Y plane, z = 0) but treats a specific triangle carved out of that plane as a “hole”: any ray hitting inside the triangle should report no intersection.

1. Scene Description  
   - Plane: infinite, defined by point P0 = (0, 0, 0) and unit normal N = (0, 0, 1).  
   - Triangle hole: three coplanar vertices V0, V1, V2, all lying on the plane z = 0. No other portion of the plane is removed.  

     Let  
       V0 = ( 1,  0, 0)  
       V1 = ( 0,  1, 0)  
       V2 = (-1,  0, 0)  

     This is an isosceles triangle whose interior is the “hole.”  

2. Ray Definition  
   A ray is given by  
     O = ray origin (Vector3)  
     D = ray direction (normalized Vector3)  
   Points on the ray: R(t) = O + t·D,  t ≥ 0.  

3. Your Task  
   Implement a function with the signature (in pseudocode/C++ style):  
     bool intersectPlaneWithTriangleHole(const Ray& ray,  
                                         float    epsilon,  
                                         float&   out_t,  
                                         Vector3& out_normal);  
   - ray: contains origin O and direction D (already normalized).  
   - epsilon: small positive number to guard against division-by-zero and self-intersection (e.g. 1e-6).  
   - out_t: on success, set to the smallest t > epsilon where the ray hits the plane outside the triangular hole.  
   - out_normal: on success, set to the plane’s normal (0, 0, 1).  
   - return true if there is a valid intersection; false otherwise.  

4. Algorithm Outline  
   a) Compute denom = dot(N, D).  
      If |denom| < epsilon, the ray is parallel to the plane → return false.  
   b) Compute t0 = dot(P0 – O, N) / denom.  
      If t0 ≤ epsilon, the intersection is behind the ray origin or too close → return false.  
   c) Compute hit point H = O + t0·D.  
   d) Test whether H lies inside the triangle V0V1V2. If it does, the ray passes through the hole → return false.  
   e) Otherwise, set out_t = t0, out_normal = N, and return true.  

5. Point-In-Triangle Test (edge-crossing method)  
   For a point H and triangle vertices {Vi}, compute for i = 0,1,2 (with V3 ≡ V0):  
     edge = Vi+1 – Vi  
     vp   = H       – Vi  
     c    = cross(edge, vp)  
   If dot(c, N) ≥ 0 for all three i, then H is on the same side of each edge (inside triangle).  
   Otherwise H is outside.  

6. Example Test Cases  

   1) Ray from above hole, through origin  
      O = (0, 0, 1), D = (0, 0, –1)  
      → plane intersection at H = (0,0,0), which lies inside triangle V0V1V2  
      → function returns false.  

   2) Ray from the side, pointing down  
      O = (2, 0, 1), D = (0, 0, –1)  
      → plane intersection at H = (2,0,0), which is outside the triangle  
      → function returns true, out_t = 1.0, out_normal = (0,0,1).  

   3) Ray grazing the plane at a shallow angle  
      O = (0, 0, 1), D = (1, 1, –0.001) normalized  
      → denom ≈ –0.001/√2, t0 large but valid; if H outside triangle, returns true; if inside (rare), returns false.

Deliverables  
- Complete implementation of intersectPlaneWithTriangleHole.  
- Brief explanation of your triangle-inside test.  
- Validation of the three example rays above.

############### 7.4 ###############
Ray–Object Intersection: Plane with a Triangular Hole

Problem Description  
We have an infinite plane lying in the z = 0 plane with a constant shading normal N = (0,0,1).  Carved out of that plane is a triangular hole whose vertices (in counter-clockwise order when viewed from +z) are:

  • A = (1, 0, 0)  
  • B = (0, 1, 0)  
  • C = (–1, 0, 0)  

Any ray that intersects the plane inside that triangle should be treated as a miss (no hit).  Rays that intersect the plane outside the triangle should register a hit at the intersection point with the normal N.

You must implement a function with the following behavior:

Function Signature (in your language of choice)  
  bool intersectPlaneWithTriangleHole(const Ray& ray, Hit& hit);

Where  
  • ray.origin is the 3D start point of the ray  
  • ray.direction is the normalized 3D direction vector  
  • hit.t is the hit‐distance along the ray  
  • hit.position is the 3D intersection point  
  • hit.normal is the surface normal at hit.position  

Return true if there is a valid intersection with the plane outside the triangle; return false otherwise.

Requirements  

1.  Reject rays parallel to the plane.  
2.  Compute t = –(ray.origin·N) / (ray.direction·N).  
    – If denominator (ray.direction·N) is nearly zero, return false.  
    – If t ≤ 0, the intersection is behind the origin; return false.  
3.  Compute P = ray.origin + t * ray.direction.  
4.  Test whether P lies inside triangle ABC.  If it does, return false (hole).  
5.  Otherwise:  
     • hit.t = t  
     • hit.position = P  
     • hit.normal = N  
     • return true  

Triangle‐Inside Test (half‐space method)  
Let cross(u,v) be the 3D cross product and “·” be the dot product.  Define  

  edge0 = B–A,    vp0 = P–A  
  edge1 = C–B,    vp1 = P–B  
  edge2 = A–C,    vp2 = P–C  

Compute  

  c0 = cross(edge0, vp0)·N  
  c1 = cross(edge1, vp1)·N  
  c2 = cross(edge2, vp2)·N  

If c0 ≥ 0 and c1 ≥ 0 and c2 ≥ 0, then P is inside the CCW triangle ABC.

Sample Rays and Expected Results  

  1. ray.origin = (0, 0, 5), ray.direction = (0, 0, –1)  
     – Plane intersection at P=(0,0,0)  
     – (0,0,0) is inside the triangle ⇒ return false  

  2. ray.origin = (2, 2, 5), ray.direction = (0, 0, –1)  
     – P=(2,2,0) is outside the triangle ⇒ return true  
       hit.t=5, hit.position=(2,2,0), hit.normal=(0,0,1)  

  3. ray.origin = (0, 0, 5), ray.direction = (1, 1, 0)  
     – ray.direction·N = 0 ⇒ parallel ⇒ return false  

  4. ray.origin = (0, –2, –5), ray.direction = (0, 0, 1)  
     – P=(0,–2,0) is outside triangle ⇒ return true  
       hit.t=5, hit.position=(0,–2,0), hit.normal=(0,0,1)  

Deliverables  
  • The source code for intersectPlaneWithTriangleHole(...)  
  • A brief explanation of your triangle‐inside test  
  • Output logs for the four sample rays above demonstrating correct behavior

############### 7.5 ###############
Ray–Plane‐With‐Triangle‐Hole Intersection  
---------------------------------------

In this exercise you will write a function that tests a ray against an infinite plane having a single triangular “cut‐out” (hole).  The plane lies in 3D space at z = 0; the hole is the interior of a triangle whose vertices also lie in that plane.

1. Geometry Definitions  
   • Plane  
     – Point on plane: P₀ = (0, 0, 0)  
     – Normal       : N = (0, 0, 1)  (pointing toward +z)  
   • Triangle hole  
     – A = (1, 1, 0)  
     – B = (2, 1, 0)  
     – C = (1, 2, 0)  
     (A, B, C are ordered counter‐clockwise when viewed from +z.)

2. Ray Definition  
   struct Ray {  
     Vec3 origin;    // (oₓ,oᵧ,o𝓏)  
     Vec3 direction; // (dₓ,dᵧ,d𝓏), assume normalized  
   };

3. Desired Function Signature (C++‐style)  
   // Returns true if the ray hits the plane outside the triangle hole.  
   // On return, tHit is the positive distance along the ray to the intersection,  
   // and outNormal is the plane normal.  
   bool intersectPlaneWithTriangleHole(  
     const Ray&    ray,  
     float&        tHit,  
     Vec3&         outNormal  
   );

4. Intersection Algorithm Outline  
   1) Compute denom = N · ray.direction.  
      • If |denom| < ε (e.g. 1e-6), the ray is parallel to the plane → no intersection.  
   2) Compute t = (P₀ – ray.origin) · N / denom.  
      • If t ≤ 0 → intersection is behind the ray origin → no intersection.  
   3) Compute hit point P = ray.origin + t * ray.direction.  
   4) Test whether P lies inside—or on the edge of—the triangle ABC:  
      • You may use barycentric‐coordinate tests or the half‐space method.  
      • If P is inside (or exactly on) the triangle, it falls in the hole → reject.  
   5) Otherwise, we have a valid hit:  
      • tHit = t;  
      • outNormal = N;  
      • return true.

5. Requirements and Edge‐Cases  
   • Treat points exactly on the triangle’s edges or vertices as “inside the hole” → no intersection.  
   • Use an epsilon tolerance (e.g. 1e-6) for all float comparisons.  
   • ray.direction is guaranteed normalized.  
   • Return the first positive intersection only.

6. Sample Test Rays  
   Ray R₁: origin = (0, 0, 1), direction = normalize(1, 0, –1)  
     – Intersection at (1, 0, 0): outside triangle → hit  
     – Expected: true, tHit ≈ √2, outNormal = (0,0,1)  
   Ray R₂: origin = (0, 0, 1), direction = normalize(1, 1, –1)  
     – Intersection at (1, 1, 0): on vertex A → in hole → no hit  
     – Expected: false  
   Ray R₃: origin = (1.5, 0, 2), direction = normalize(0, 1, –2)  
     – Intersection at (1.5, 1, 0): inside triangle → no hit  
     – Expected: false

Deliverables  
  • Complete implementation of intersectPlaneWithTriangleHole.  
  • Brief comments explaining your triangle‐inside test.  
  • Verification of the three sample rays above (print pass/fail).

############### 7.6 ###############
Ray‐Object Intersection: Infinite Plane with Triangular Hole
-------------------------------------------------------------------

In this exercise you will write a routine that tests a ray against an infinite plane but treats a specified triangle in the plane as a “hole” (i.e. rays passing through that triangle do *not* register a hit).  If the ray intersects the plane outside the triangle, you must record the hit point, the valid t-value, and the correct surface normal.  If it either misses the plane or passes through the triangular hole, the routine returns false.

Object Definition
-----------------
  • Plane: defined by  
      – Normal N = (0, 1, 0) (i.e. horizontal plane)  
      – Plane equation: N·P + D = 0 with D = 0 ⇒ y = 0  
  • Triangle‐hole: three coplanar vertices all lying in y=0:  
      V0 = (–1, 0,  1)  
      V1 = ( 1, 0,  1)  
      V2 = ( 0, 0, –1)  

Ray Definition
--------------
  struct Ray {  
    Vec3 origin;        // ray origin  
    Vec3 direction;     // normalized direction  
  };  

Hit Record
----------
  struct HitRecord {  
    float t;            // ray parameter at intersection  
    Vec3  point;        // intersection point  
    Vec3  normal;       // surface normal at intersection  
  };  

Function Signature
------------------
  bool intersectPlaneWithTriangleHole(  
      const Ray& ray,  
      float tMin,  
      float tMax,  
      HitRecord& outRec  
  );  

Requirements
------------
1.  Compute intersection t_plane between ray and the infinite y=0 plane.  
    • If ray.direction.y is nearly zero ⇒ ray ∥ plane ⇒ return false.  
    • Otherwise solve  t_plane = −(ray.origin.y) / ray.direction.y.  
    • If t_plane < tMin or t_plane > tMax ⇒ no valid hit ⇒ return false.  

2.  Compute the candidate intersection point  
       P = ray.origin + t_plane * ray.direction  

3.  Determine whether P lies *inside* the triangle V0–V1–V2.  If it does, the ray “passes through the hole” ⇒ return false.  
    You may use any correct point‐in‐triangle test, e.g.:  
    • Barycentric‐coordinate method  
    • Edge‐sign (half‐plane) method  

4.  If P is outside the triangular hole, record a hit:  
    outRec.t      = t_plane  
    outRec.point  = P  
    outRec.normal = (ray.direction.y < 0) ? (0, 1, 0) : (0, -1, 0)  
    return true  

Edge Cases
----------
  • Intersection exactly on a triangle edge: treat that as “inside” the hole ⇒ return false.  
  • Rays originating on the plane (origin.y = 0): only count intersections for t > 0.  

Deliverables
------------
  • Well‐commented source code for intersectPlaneWithTriangleHole(…)  
  • A brief description (1‐2 paragraphs) of how you implement the point‐in‐triangle test  
  • A small table of at least three test rays, with:  
      – ray origin and direction  
      – expected boolean result  
      – expected t and intersection point (when result=true)  

Scoring Criteria
----------------
  • Correctness of intersection logic (45%)  
  • Robust handling of parallel rays and edge cases (25%)  
  • Clarity and organization of code and explanation (20%)  
  • Quality of test cases (10%)

############### 7.7 ###############
Ray‐Plane Intersection with a Triangular Hole  
--------------------------------------------

In this exercise you will write a function that tests a ray against an infinite plane (the XZ–plane at y = 0) which has a single triangular “cut‐out” (a hole) in it.  Any ray that hits the plane **outside** that triangle is a valid intersection; any ray that would hit **inside** the triangle or misses the plane entirely must return “no hit.”

1) Geometry setup  
   • Plane:  y = 0  
     – Normal n = (0, 1, 0) (points “up”)  
   • Triangle‐hole vertices (all lie in the plane y=0):  
       A = (0, 0, 0)  
       B = (2, 0, 0)  
       C = (1, 0, 1.73205)   (so that ABC is an equilateral triangle of side 2)  

2) Ray representation  
   struct Ray {  
     Vec3 origin;    // O  
     Vec3 direction; // D (assume normalized)  
   };  

3) API you must implement  
   // Returns true if ray hits the plane *outside* triangle ABC.  
   // If so, t_out > 0 is the ray‐parameter at the hit and  
   // hitPoint = O + t_out * D is the intersection.  
   bool intersectPlaneWithTriangleHole(  
       const Ray &ray,  
       float &t_out,  
       Vec3 &hitPoint  
   );  

4) Steps / hints  

   a) Ray‐plane intersection  
      • Denominator denom = dot(n, D).  
      • If denom is 0 (or very close), the ray is parallel → no hit.  
      • Solve for t:  n·(O + t D) = 0  ⇒  t = –(n·O) / denom  
      • If t ≤ 0  ⇒  intersection is behind the ray origin → no hit.  
      • Compute P = O + t D.  This is the point on the plane.  

   b) Point‐in‐triangle test (to detect if P lies inside the hole ABC)  
      You may choose either method:  
      – Barycentric coordinates:  
         • Project A,B,C,P onto the XZ–plane (drop y).  
         • Compute vectors v0 = C–A, v1 = B–A, v2 = P–A.  
         • Compute dot products d00 = v0·v0, d01 = v0·v1, d11 = v1·v1, d20 = v2·v0, d21 = v2·v1.  
         • Denominator denom2 = d00*d11 – d01*d01.  
         • u = (d11*d20 – d01*d21) / denom2  
         • v = (d00*d21 – d01*d20) / denom2  
         • P is inside ABC iff u ≥ 0, v ≥ 0, u+v ≤ 1.  
      – “Same‐side” cross‐product test in 3D:  
         For each edge (A→B, B→C, C→A), compute cross(edge, P–edge_start) and ensure all three cross-products point in the same (upwards) direction relative to n.  

      If P lies **inside** triangle ABC, that means it hit the hole → return false.  
      Otherwise, the plane is solid at P → return true with t_out and hitPoint = P.  

5) Example test cases

   // 1) Ray from above, pointing straight down at the center of the hole  
   Ray r1 = { {1, 5, 0.57735}, {0, -1, 0} };  
   // intersection at t=5 exactly at P=(1,0,0.57735) which is inside ABC → no hit  

   // 2) Ray from above, pointing down at outside region  
   Ray r2 = { {-1, 2, 0}, {0, -1, 0} };  
   // intersection at t=2 yields P=(-1,0,0) outside ABC → hit at t=2  

   // 3) Ray is parallel to plane  
   Ray r3 = { {0,1,0}, {1,0,0} };  
   // denom = dot(n,D)=0 → no hit  

Deliverables  
-----------  
– Full source code for intersectPlaneWithTriangleHole(…) implementing the steps above.  
– A brief explanation of how you handle parallel rays, t≤0, and the point‐in‐triangle test.  
– Output of the three example rays showing “no hit” or “hit at t=…” plus the hitPoint.

############### 7.8 ###############
Here is a self-contained programming exercise on ray–object intersection.  The scene object is an infinite plane with a triangular “hole” cut out of it.  All details are stated so there is exactly one correct solution.

---  
Problem Statement  
---  
You must write a function that tests intersection between a ray and a plane with a triangular hole.  The plane is the infinite XY-plane at z = 0, but any point inside the triangle A B C is omitted (no hit).

Plane:  
• Equation: z = 0  
• Surface normal (pointing toward +z): N = (0, 0, 1)  

Hole (triangle) vertices in counter-clockwise order as seen from +z:  
A = (0, 0, 0)  
B = (2, 0, 0)  
C = (1, 2, 0)  

Your ray is parameterized as:  
  R(t) = O + t D,    t ≥ 0  
where O = (Ox, Oy, Oz) is the origin and D = (Dx, Dy, Dz) is a normalized direction.

Write a function with signature (in pseudocode/C++) like:

```cpp
// If the ray intersects the plane outside the triangle, return true,
// set outT = t, outNormal = (0,0,1).  Otherwise return false.
bool intersectPlaneWithTriangleHole(
    const Vec3& O, const Vec3& D,
    float& outT, Vec3& outNormal
);
```

You must perform these steps:

1.  Compute the plane intersection parameter t_plane:
      if (Dz == 0) return false; // parallel to plane  
      t_plane = –Oz / Dz;  
      if (t_plane < 0) return false; // intersection behind ray origin  

2.  Compute intersection point P:
      P = O + t_plane * D  
      // Note: by construction P.z == 0

3.  Determine whether P lies inside triangle ABC.  If it does, this is the hole, so the ray does NOT hit.  If it lies outside, the ray does hit the plane at P.

   To test “inside” triangle, use the edge-cross‐dot method:  
     For each edge E_i:  
       E0 = B−A,   VP0 = P−A  
       E1 = C−B,   VP1 = P−B  
       E2 = A−C,   VP2 = P−C  
     Compute cross products (all in 3D):  
       C0 = E0 × VP0  
       C1 = E1 × VP1  
       C2 = E2 × VP2  
     Since the triangle is in the z=0 plane and vertices are CCW as seen from +z, each C_i should point in +z if P is inside.  
     If (C0.z ≥ 0 AND C1.z ≥ 0 AND C2.z ≥ 0), P is inside → return false.  

4.  Otherwise, P is on the plane but outside the hole.  Report hit:  
      outT = t_plane  
      outNormal = (0,0,1)  
      return true  

---  
Test Cases  
---  
Below are several rays.  For each, give the intersection result and, if hit, the value of t.

1) O = (0, 0, 1),   D = (0, 0, -1)  
   Hits plane at P = (0,0,0) which is vertex A → inside hole → no hit

2) O = (1, 1, 1),   D = (0, 0, -1)  
   P = (1,1,0).  
   Is (1,1,0) inside ABC?  
   • Edge tests yield mixed signs → outside → hit  
   t = 1.0

3) O = (0.5, 0.5, 1), D = (0, 0, -1)  
   P = (0.5,0.5,0) inside → no hit

4) O = (3, 0, 1),   D = (-1, 0, -1).normalized()  
   t_plane = Oz / |Dz| = 1 / 0.7071 ≈ 1.4142  
   P ≈ (1, 0, 0) which lies on edge AB (but edge counts as inside) → no hit

5) O = (3, 0, 1),   D = (-2, 1, -2).normalized()  
   Solve t_plane = 1/2 = 0.5  
   P = (3,0,1) + 0.5*(−2,1,−2) = (2, 0.5, 0)  
   Outside triangle → hit, t = 0.5

Use these to validate your implementation.

############### 7.9 ###############
Title: Ray–Object Intersection with an Infinite Plane Minus a Triangular Hole

Problem statement  
We have an infinite plane (the xz-plane) and a triangular hole cut out of it. Your job is to write a ray-intersection routine that returns a hit only if the ray intersects the plane outside the hole. If the intersection point lies inside (or on the edge of) the triangle, it is treated as a miss.

Object description  
• Plane:  
  – Point on plane P₀ = (0, 0, 0)  
  – Unit normal N = (0, 1, 0)  
  – Equation: (P – P₀)·N = 0  ⇔  y = 0  

• Triangular hole (all vertices lie on the plane):  
  V₀ = (0, 0, 0)  
  V₁ = (1, 0, 0)  
  V₂ = (0, 0, 1)  

Ray description  
• Ray origin O = (Oₓ, O_y, O_z)  
• Ray direction D = (Dₓ, D_y, D_z), assumed normalized (|D| = 1)  

Intersection rule  
1. Reject if D·N = 0 (ray parallel to plane).  
2. Solve for t:  
     t = (P₀ – O)·N  ÷  (D·N).  
   If t ≤ ε (a small positive threshold, e.g. 1e–4), reject (intersection is behind or too close).  
3. Compute intersection point P = O + t D.  
4. Determine whether P lies inside the triangular hole:  
   – Compute two edge vectors e₀ = V₁ – V₀, e₁ = V₂ – V₀.  
   – Compute vector v = P – V₀.  
   – Solve for barycentric coordinates (u, v) in v = u e₀ + v e₁.  
     • For example, form the 2×2 system in (x,z) or use an area‐based test.  
   – If u ≥ 0, v ≥ 0 and u + v ≤ 1, then P is inside (or on) the triangle ⇒ it lies in the hole ⇒ reject.  
5. Otherwise it is a valid hit: return t, the intersection point P, and a shading normal nHit = ±N chosen so that nHit·D < 0 (normal faces against the incoming ray).

Function signature (C++-style pseudocode)  
```cpp
// Returns true if ray hits the plane outside the triangular hole.
// On hit:
//   tHit    = distance along ray to intersection
//   hitPoint = O + tHit * D
//   hitNormal = unit normal at hit (facing the ray)
// On miss: returns false, tHit and hitNormal are undefined.
bool intersectPlaneWithTriangleHole(
    const Vec3 &O, const Vec3 &D,
    float &tHit, Vec3 &hitNormal);
```

Implementation hints  
• Check D·N first to avoid division by zero.  
• Use a small ε (e.g. 1e–4) to avoid self-intersection.  
• For the barycentric test you can project onto the xz-plane (ignore y) and solve:  
    [ e₀ₓ  e₁ₓ ] [u] = [vₓ]  
    [ e₀_z  e₁_z ] [v]   [v_z]  
• Alternatively, test P against the three edge half-spaces or use an area-ratio method.

Test cases  
For each ray below, report “hit” or “miss.” If hit, give tHit and hitNormal.

1) O = (0.5, 1.0, 0.5),  
   D = (0, –1, 0)  
   – Intersection at P = (0.5, 0, 0.5). This lies inside the triangle (0.5+0.5 = 1, on the edge) ⇒ hole ⇒ miss.  

2) O = (1.5, 1.0, 1.5),  
   D = (0, –1, 0)  
   – Intersection at P = (1.5, 0, 1.5). Here 1.5+1.5 = 3 > 1 ⇒ outside hole ⇒ hit.  
     tHit = 1.0, hitNormal = (0, 1, 0).  

3) O = (2, 2, 2),  
   D = normalize(–1, –2, –1)  
   – Solve t from y=0:  2 + (–2) t = 0 ⇒ t = 1.0  
     P = (1, 0, 1); 1+1 = 2 > 1 ⇒ outside hole ⇒ hit.  
     hitNormal = (0, 1, 0).  

Deliverables  
• Complete source or pseudocode for intersectPlaneWithTriangleHole(…)  
• Brief explanation of each step (plane intersection, barycentric test, normal orientation)  
• Results of the three test cases with your function’s output.

############### 8.0 ###############
Ray‐Ellipsoid Intersection Exercise

In this problem you will derive the intersection test between a ray and an axis–aligned ellipsoid, then implement it in code.

--------------------------------------------------------------------------------
Problem Statement
--------------------------------------------------------------------------------

We have:

• An axis–aligned ellipsoid E centered at C = (Cx,Cy,Cz) with radii Rx, Ry, Rz.  
  Its surface is the set of points X = (x,y,z) satisfying  
     ((x–Cx)/Rx)² + ((y–Cy)/Ry)² + ((z–Cz)/Rz)² = 1  

• A ray R(t) = O + t D, t ≥ 0, with origin O = (Ox,Oy,Oz) and (unit-length) direction D = (Dx,Dy,Dz).

Part A – Derivation  
1. Substitute X = O + t D into the ellipsoid equation to get a quadratic in t:  
     ((Ox+ t Dx – Cx)/Rx)²  
   + ((Oy+ t Dy – Cy)/Ry)²  
   + ((Oz+ t Dz – Cz)/Rz)² = 1.  

2. Show that it can be written as  
      At² + Bt + C = 0  
   where  
      A = (Dx/Rx)² + (Dy/Ry)² + (Dz/Rz)²  
      B = 2 [ (Ox–Cx)(Dx/Rx²) + (Oy–Cy)(Dy/Ry²) + (Oz–Cz)(Dz/Rz²) ]  
      C = (Ox–Cx)²/Rx² + (Oy–Cy)²/Ry² + (Oz–Cz)²/Rz² – 1  

3. Derive the discriminant Δ = B² – 4AC.  Under what condition(s) on Δ does the ray hit the ellipsoid?  If Δ ≥ 0, what are the two solutions t₁ and t₂?  Which one is the first intersection along the ray?

Part B – Implementation  

Write a function with this prototype in the language of your choice (C++, Java or Python pseudocode is fine):

    // Returns true if ray intersects ellipsoid; 
    // on hit, tHit is set to the smallest positive t.
    bool intersectEllipsoid(
        const Vec3& O,       // ray origin
        const Vec3& D,       // ray direction (normalized)
        const Vec3& C,       // ellipsoid center
        float Rx, float Ry, float Rz,
        out float& tHit
    );

Requirements:
 1. Compute A, B, C as above.  
 2. Compute Δ = B² – 4 A C.  
 3. If Δ < 0 return false (no intersection).  
 4. Otherwise compute the two roots  
       t₁ = (–B – √Δ)/(2A),  
       t₂ = (–B + √Δ)/(2A).  
 5. Set tHit to the smaller of {t₁,t₂} that is ≥ ε (e.g. ε=1e–4).  
    If both are < ε, return false. Otherwise return true.

Part C – Surface Normal (optional, for shading)  

Once you have tHit, the intersection point is  
    P = O + tHit D.  
The unit normal N at P on the ellipsoid is given by  
    N = normalize( (P–C) ⊘ (Rx², Ry², Rz²) )  
(where ⊘ denotes component-wise division).

--------------------------------------------------------------------------------
What to submit
--------------------------------------------------------------------------------
1. A one‐page derivation of A, B, C and the discriminant test.  
2. Working code for intersectEllipsoid(…) that compiles and runs.  
3. A brief note on how you handle cases when the ray starts inside the ellipsoid (optional).  

Good luck!

############### 8.1 ###############
Below is a self-contained programming exercise on ray–ellipsoid intersection.  Read it carefully, derive the required equations, then implement a working solution in the language of your choice.

――――――――――――――――――――――――――――――――  
Ray–Ellipsoid Intersection Exercise  
――――――――――――――――――――――――――――――――  

Context  
-------  
An axis-aligned ellipsoid E in 3D is defined by its center C = (Cx, Cy, Cz) and its principal semi-axes a, b, c along the x, y, and z directions.  The surface of E satisfies  
 ((x – Cx)/a)² + ((y – Cy)/b)² + ((z – Cz)/c)² = 1.  

A ray R is given by  
 R(t) = O + t D,  
where O = (Ox, Oy, Oz) is the ray origin, D = (Dx, Dy, Dz) is a (normalized) direction vector, and t ≥ 0.  

Your task is to detect intersections between R and E, compute the nearest (smallest nonnegative) t at which they meet, and—if an intersection exists—compute the surface normal at the hit point.  

Problem Statement  
-----------------  
1.  Derive the intersection equation.  Show that substituting R(t) into the ellipsoid equation yields a quadratic in t of the form  
   A t² + B t + C = 0,  
   and give expressions for A, B, and C in terms of O, D, C, a, b, c.  

2.  Write a function (in C++, Java, Python, etc.) with this signature (or equivalent in your language):  
   
   bool intersectEllipsoid(  
       Vec3 O, Vec3 D,            // ray origin & (normalized) direction  
       Vec3 C,                    // ellipsoid center  
       float a, float b, float c, // ellipsoid semi-axes  
       out float &tHit,           // output: nearest intersection t  
       out Vec3 &normal           // output: unit surface normal at hit  
   );  

   The function should:  
   a.  Form and solve the quadratic A t² + B t + C = 0.  
   b.  Determine whether real, nonnegative solutions exist.  
   c.  If yes, pick the smallest t ≥ ε (e.g. ε = 1e-4) to avoid self–intersection.  
   d.  Compute the hit point P = O + tHit D.  
   e.  Compute the outward normal at P for the ellipsoid:  
         N′ = ((Px – Cx)/a²,\; (Py – Cy)/b²,\; (Pz – Cz)/c²)  
      then normalize N′ to unit length.  
   f.  Return true if an intersection was found, false otherwise.  

3.  Test your implementation with at least two different rays and ellipsoids.  For each test, report:  
   • Ray O, D  
   • Ellipsoid C, (a, b, c)  
   • tHit (or “no hit”)  
   • Intersection point P  
   • Surface normal N  

Requirements & Hints  
--------------------  
•  Carefully handle the discriminant Δ = B² – 4AC.  If Δ < 0 there is no real intersection.  
•  If A is very small (ray direction almost parallel to one axis scaled by 1/a, etc.), take care to avoid division by zero.  
•  Reject any t ≤ ε.  If both roots are ≤ ε, return false.  
•  Normalize D before computing A, B, C to simplify A’s expression.  
•  Ensure your Vec3 type supports basic operations: addition, subtraction, dot-product, scalar multiply, normalization.  

Deliverables  
------------  
•  A one-page derivation of A, B, C.  
•  Well-commented source code of intersectEllipsoid.  
•  A short report of your test cases and results.  

Good luck!

############### 8.2 ###############
Here is a self‐contained programming exercise on ray–ellipsoid intersection suitable for an introductory Computer Graphics assessment.  It includes the mathematical derivation you’ll need, clear definitions of the ray and ellipsoid, and asks the student to implement and test the solution.

---

**Problem: Ray–Ellipsoid Intersection**

1. **Definitions**  
   • Ray:  r(t) = O + t·D,  
     – O = (Ox, Oy, Oz) is the ray origin (world‐space).  
     – D = (Dx, Dy, Dz) is the ray direction (assume normalized).  
     – t ∈ ℝ, t ≥ 0.  

   • Axis‐aligned Ellipsoid:  
     Centered at C = (Cx, Cy, Cz) with radii a, b, c > 0 along x, y, z axes respectively.  
     Its implicit equation is  
       F(P) = ((Px – Cx)² / a²) + ((Py – Cy)² / b²) + ((Pz – Cz)² / c²) – 1 = 0.  

2. **Derive the Intersection Equation**  
   Substitute P = O + t·D into F(P) = 0:  
     ((Ox + t Dx – Cx)² / a²)  
   + ((Oy + t Dy – Cy)² / b²)  
   + ((Oz + t Dz – Cz)² / c²)  
   – 1 = 0.  

   Collect terms in t to get a quadratic:  
     A t² + B t + C = 0,  
   where  
     A = (Dx² / a²) + (Dy² / b²) + (Dz² / c²),  
     B = 2 [((Ox – Cx)·Dx)/a² + ((Oy – Cy)·Dy)/b² + ((Oz – Cz)·Dz)/c²],  
     C = ((Ox – Cx)² / a²) + ((Oy – Cy)² / b²) + ((Oz – Cz)² / c²) – 1.  

   Compute discriminant Δ = B² – 4AC.  
   • If Δ < 0: no real intersection.  
   • Otherwise t = (–B ± √Δ) / (2A).  

3. **Implementation Task**  
   Write a function in C++ (or your preferred language) with the following signature:  

     bool intersectEllipsoid(  
       const Ray& ray,            // has origin O and normalized direction D  
       const Ellipsoid& el,       // has center C and radii (a,b,c)  
       float tMin,                // minimum acceptable t (e.g. 0.001f)  
       float tMax,                // maximum acceptable t  
       HitRecord& hit             // to be filled with t, point, normal  
     );  

   – Return true if there is an intersection t ∈ [tMin, tMax], false otherwise.  
   – On success, set:  
     • hit.t = the smallest t in [tMin, tMax]  
     • hit.p = ray.origin + hit.t * ray.direction  
     • hit.normal = ∇F(p) normalized  
       = ( (px–Cx)/a², (py–Cy)/b², (pz–Cz)/c² ) normalized.  

4. **Requirements & Hints**  
   a. Ensure ray.direction is normalized before calling.  
   b. Guard against A ≈ 0 (degenerate case).  
   c. When Δ ≈ 0 treat as tangent (one intersection).  
   d. Only accept t values ≥ tMin to avoid self‐intersections.  
   e. Fill HitRecord in world space.  

5. **Testing**  
   Provide at least two test cases:  
   - Ray originating outside and hitting the ellipsoid twice—verify the nearest intersection.  
   - Ray originating inside—should return the exit intersection.  
   - Ray missing the ellipsoid—function returns false.  

6. **Deliverables**  
   • Full derivation of A, B, C, and Δ.  
   • Complete source code of `intersectEllipsoid`.  
   • Output logs or rendered images demonstrating the three test cases.  

---

This problem ensures the student must (1) derive the correct quadratic coefficients, (2) implement the solver robustly, and (3) compute the correct surface normal on an axis‐aligned ellipsoid.

############### 8.3 ###############
Ray–Ellipsoid Intersection  
---------------------------  

In this exercise you will write a function that computes the intersection of a ray with an (axis-aligned) ellipsoid in 3D.  The ellipsoid is defined by its center C = (Cx, Cy, Cz) and its radii along the x, y, z axes, (a, b, c), so that the set of all points P = (x,y,z) on its surface satisfies:  

    ((x–Cx)/a)² + ((y–Cy)/b)² + ((z–Cz)/c)²  =  1  

A ray is given in parametric form as  

    R(t) = O + t·D,    t ≥ 0  

where O = (Ox,Oy,Oz) is the ray origin and D = (Dx,Dy,Dz) is a normalized direction vector.  

Your task  
---------  
1.  Derive the quadratic equation for t by substituting R(t) into the ellipsoid equation.  
2.  Implement a function  

       intersectEllipsoid(O, D, C, (a,b,c)) → t₀

    that returns the smallest positive solution t₀ (the first intersection along the ray).  
    – If there is no real, positive solution, return some sentinel (e.g. ∞ or –1).  
3.  (Optional, for extra credit) Compute the surface normal N at the intersection point P = O + t₀·D.  

Derivation hint  
---------------  
Let V = O – C.  Substitute x=Ox + t Dx, etc. into  

    ((Ox + t Dx – Cx)/a)² + ((Oy + t Dy – Cy)/b)² + ((Oz + t Dz – Cz)/c)² = 1  

You will obtain a quadratic in t:

    A t² + B t + C = 0

where  

    A = (Dx/a)² + (Dy/b)² + (Dz/c)²  
    B = 2[(Vx·Dx)/a² + (Vy·Dy)/b² + (Vz·Dz)/c²]  
    C = (Vx/a)² + (Vy/b)² + (Vz/c)² – 1  

Solve for t using the quadratic formula.  

Surface normal  
--------------  
At P, the outward normal of an ellipsoid is  

    N = normalize( ((Px–Cx)/a², (Py–Cy)/b², (Pz–Cz)/c²) )  

Function signature (in C-style pseudocode)  
------------------------------------------  
```c
// If no hit: return t = INFINITY (or a negative value).
float intersectEllipsoid(
    Vec3 O,    // ray origin
    Vec3 D,    // ray direction (assumed normalized)
    Vec3 C,    // ellipsoid center
    float a,   // x-radius > 0
    float b,   // y-radius > 0
    float c    // z-radius > 0
) {
    // 1) Compute V = O – C
    // 2) Compute A, B, Ccoeff as above
    // 3) Compute discriminant Δ = B² – 4AC
    // 4) If Δ < 0 return INFINITY
    // 5) Compute t1 = (–B – sqrt(Δ)) / (2A)
    //    Compute t2 = (–B + sqrt(Δ)) / (2A)
    // 6) If both t1,t2 < 0, return INFINITY
    //    Else return min positive of t1,t2
}
```

Example test cases  
------------------  
1) Ellipsoid centered at (0,0,0) with radii (2,1,1).  
   a) Ray O=(–5,0,0), D=(1,0,0):  
      V = (–5,0,0), A = (1/2)² = 0.25,  
      B = 2[ (–5·1)/2² ] = –2.5,  
      C = (–5/2)² – 1 = 6.25 – 1 = 5.25  
      Δ = (–2.5)² – 4·0.25·5.25 = 6.25 – 5.25 = 1  
      t1 = (2.5 – 1)/0.5 = 3,   t2 = (2.5 + 1)/0.5 = 7  
      → intersection at t₀=3.  

   b) Ray O=(0,0,0), D=(1,0,0): (origin inside ellipsoid)  
      expect one positive root: intersection at x=+2 ⇒ t₀=2.  

2) Ellipsoid at C=(1,2,3), radii a=1,b=2,c=1.5,  
   Ray O=(1,2,10), D=(0,0,–1):  
      Should hit “south pole” at z = 3 + c = 4.5 ⇒ t₀ = 10 – 4.5 = 5.5.  

Deliverables  
------------  
•  Source code for `intersectEllipsoid`.  
•  A brief write-up showing your derivation of A, B, C, and how you choose between t1 and t2.  
•  (Optional) Code snippet for computing the normal N at the hit point.

############### 8.4 ###############
Ray‐Ellipsoid Intersection Exercise

Description  
You are to implement a function that tests a 3D ray against a solid ellipsoid (axis-aligned) and, if they intersect, returns the nearest positive hit distance t along the ray, the intersection point, and the surface normal there.

Ellipsoid definition  
• Center C = (Cx, Cy, Cz)  
• Radii along axes: Rx (x-radius), Ry (y-radius), Rz (z-radius)  
  The ellipsoid surface is the set of all points P satisfying  
    ((Px – Cx)/Rx)² + ((Py – Cy)/Ry)² + ((Pz – Cz)/Rz)² = 1

Ray definition  
• Origin O = (Ox, Oy, Oz)  
• Direction D = (Dx, Dy, Dz), a normalized vector  
  The ray’s parametric equation is P(t) = O + t · D,  t ≥ 0

Tasks  
1.  Derive the quadratic equation at² + bt + c = 0 whose solutions are the intersection parameters t.  
    Hint: Let X = O – C, and define the scaled direction and offset  
      u = (Dx/Rx, Dy/Ry, Dz/Rz)  
      v = (Xx/Rx, Xy/Ry, Xz/Rz)  
    Then the intersection condition becomes (u·u) t² + 2(u·v) t + (v·v – 1) = 0.  
2.  Implement a function with this signature (in C++-style pseudocode):  
      struct Hit {  
        bool   hit;      // true if intersection at t > 0  
        float  t;        // nearest positive t  
        Vec3   position; // O + t·D  
        Vec3   normal;   // unit surface normal at position  
      };  
      Hit intersectEllipsoid(  
        const Vec3& O, const Vec3& D,  
        const Vec3& C, float Rx, float Ry, float Rz  
      );  
3.  In your code do the following steps:  
    a.  Compute X = O – C.  
    b.  Compute u and v as above.  
    c.  Compute coefficients A = u·u, B = 2(u·v), Cq = v·v – 1.  
    d.  Compute discriminant Δ = B² – 4 A Cq.  
       • If Δ < 0, return Hit{false, …}.  
    e.  Otherwise compute the two roots  
         t0 = (–B – √Δ)/(2 A)  
         t1 = (–B + √Δ)/(2 A)  
       • Discard any t ≤ 0.  
       • If both t0 and t1 ≤ 0, return Hit{false, …}.  
       • Let t = min positive root.  
    f.  Compute intersection point P = O + t·D.  
    g.  Compute the unnormalized normal N′ = ((Px – Cx)/Rx², (Py – Cy)/Ry², (Pz – Cz)/Rz²).  
    h.  Normalize N = N′ / |N′|.  
    i.  Return Hit{true, t, P, N}.  
4.  Provide a short test case. For example:  
    • Ellipsoid center C = (0,0,0), radii Rx=2, Ry=1, Rz=1.5  
    • Ray origin O = (−5, 0, 0), direction D = (1, 0.2, 0.1) normalized.  
    • Compute and print t, P, N.  

Deliverables  
• A clear derivation of the quadratic coefficients.  
• Correct, well-commented code for intersectEllipsoid(…).  
• A sample run showing that your function correctly finds the first intersection (or none).

############### 8.5 ###############
Ray‐Ellipsoid Intersection  
------------------------  

In this exercise you will implement a function that tests a ray against a (axis‐aligned) ellipsoid and, when there is an intersection, returns the nearest hit distance and surface normal.  The ellipsoid is defined by its center C = (Cx,Cy,Cz) and principal semi‐axes lengths a, b, c along the world X, Y, Z axes respectively, i.e. all points X = (x,y,z) on its surface satisfy  
  ((x–Cx)/a)² + ((y–Cy)/b)² + ((z–Cz)/c)² = 1.  

Your ray is given by  
  R(t) = O + t·D,  
where O = (Ox,Oy,Oz) is the ray origin, D = (Dx,Dy,Dz) is a normalized direction vector, and t ≥ 0.  

1) Derive the quadratic equation in t whose solutions correspond to intersections of R(t) with the ellipsoid.  Write it in the standard form  
  At² + Bt + C = 0,  
and express A, B, C in terms of O, D, C, a, b, c.  

2) Implement the following function in your language of choice (C/C++, Java, Python, etc.).  You may assume a small epsilon = 1e–6 for numerical robustness.  

    struct Ray {  
        Vec3 origin;      // O  
        Vec3 direction;   // D, assumed normalized  
    };  

    struct Hit {  
        float t;          // ray parameter at hit  
        Vec3 point;       // world‐space hit position  
        Vec3 normal;      // world‐space unit normal at hit  
    };  

    // Returns true if the ray hits the ellipsoid in front of the origin  
    bool intersectEllipsoid(  
        const Ray& ray,  
        const Vec3& center,   // C  
        float a,              // semi‐axis along X  
        float b,              // semi‐axis along Y  
        float c,              // semi‐axis along Z  
        Hit& outHit           // output hit information  
    );  

Your implementation must:  
• Compute the quadratic coefficients A, B, C using the ray and ellipsoid parameters.  
• Solve the quadratic robustly, checking the discriminant B²–4AC.  
• If there is at least one real root t > epsilon, pick the smallest positive t.  
• Compute the hit point P = O + t·D.  
• Compute the surface normal N by evaluating the gradient of the ellipsoid’s implicit function at P, i.e.  
  N = normalize( (P.x–Cx)/(a²), (P.y–Cy)/(b²), (P.z–Cz)/(c²) ).  
• Fill outHit.t, outHit.point=P, outHit.normal=N and return true; otherwise return false.  

3) Test your function on these two scenarios:  
   a) Ellipsoid centered at C=(0,0,0) with axes a=2, b=1, c=1, and a ray from O=(–5,0,0) pointing toward the origin D=(1,0,0). What t do you get and what is the normal at the hit?  
   b) Same ellipsoid, ray from O=(0,0,3) pointing down D=(0,0,–1). Does it hit? If so, at what t and with what normal?  

Submit:  
- Your derivation of A, B, C.  
- Well‐commented code for intersectEllipsoid.  
- Numerical answers (t and normals) for the two test rays.

############### 8.6 ###############
Ray–Ellipsoid Intersection (Programming Exercise)

Background  
We define an axis-aligned ellipsoid in world space by its center  
 C = (Cx, Cy, Cz)  
and its three (positive) semi-axes (radii)  
 rx, ry, rz.  
Its implicit surface equation is  
 ((x–Cx)/rx)² + ((y–Cy)/ry)² + ((z–Cz)/rz)² = 1.  

A ray is given by  
 O (origin) and D (direction, assumed normalized),  
so that any point on the ray is P(t) = O + t D, t ≥ 0.  

Your task is to derive and implement an intersection test between the ray and the ellipsoid.  

---  
Part (a): Derivation  
1. Substitute P(t) into the ellipsoid equation to obtain a quadratic in t:  
 A t² + B t + C = 0.  
2. Show that the coefficients A, B, C can be written in terms of O, D, C, rx, ry, rz.  

Part (b): Implementation  
Write a function in C++ (or pseudocode very close to C++) with the signature:  
  
  struct Vec3 { float x,y,z; /* plus vector ops */ };  
  struct Ray  { Vec3 O, D;         };  // D is normalized  
  struct Ellipsoid { Vec3 C; float rx, ry, rz; };  

  // Returns true if the ray hits the ellipsoid; 
  // tHit is set to the smallest positive t.  
  bool intersectEllipsoid(const Ray &ray,  
                          const Ellipsoid &ell,  
                          float &tHit)  
  {  
    // your code here  
  }  

Requirements:  
- Compute the quadratic coefficients A, B, C correctly.  
- Compute the discriminant Δ = B² – 4AC.  
- If Δ < 0, return false (no intersection).  
- If Δ ≥ 0, compute the two roots t0, t1 = (–B ± sqrt(Δ)) / (2A).  
- Let tNear = the smaller root, tFar = the larger.  
- Return the smallest t > ε (where ε = 1e-4 to avoid self-intersection).  
- If both roots ≤ ε, return false.  
- If ray direction D is already normalized, your A should simplify appropriately.  

Part (c): Worked Example (for self‐check)  
Given  
  Ray.O = (0, 0, 0),  
  Ray.D = normalize((1, 2, 3)),  
  Ellipsoid.C = (2, 0, 0),  
  Ellipsoid.rx = 3, ry = 2, rz = 1,  

1. Plug into your formulas for A, B, C.  
2. Compute Δ, t0, t1.  
3. Identify the valid intersection distance tHit.  

Deliverables  
- A clear derivation for A, B, C (typed or neatly handwritten).  
- The implementation of intersectEllipsoid().  
- (Optional) Numeric answers for the worked example.

Grading will be based on correctness of the derivation, robustness of the code (handling edge cases), and correct numeric results in Part (c).

############### 8.7 ###############
Ray–Ellipsoid Intersection Exercise

Background  
An ellipsoid centered at C = (Cx, Cy, Cz) with principal radii a, b, c is the set of points X = (x,y,z) satisfying  
    ((x–Cx)/a)² + ((y–Cy)/b)² + ((z–Cz)/c)² = 1.  

A ray is defined by  
    R(t) = O + t·D,  
where O = (Ox, Oy, Oz) is the origin, D = (dx, dy, dz) is the (normalized) direction, and t ≥ 0.

When you substitute R(t) into the ellipsoid equation, you get a quadratic in t:  
    A t² + B t + C = 0  
with  
    A = (dx²/a²) + (dy²/b²) + (dz²/c²)  
    B = 2·[ ((Ox–Cx)·dx)/a² + ((Oy–Cy)·dy)/b² + ((Oz–Cz)·dz)/c² ]  
    C = ((Ox–Cx)²/a²) + ((Oy–Cy)²/b²) + ((Oz–Cz)²/c²) – 1.  

The discriminant Δ = B² – 4AC tells you whether there is an intersection. If Δ < 0, no intersection. Otherwise the two solutions are  
    t₁ = (–B – √Δ)/(2A), t₂ = (–B + √Δ)/(2A).  

You typically take the smaller positive t within [t_min, t_max].

At the hit point P = R(t_hit), the outward normal on the ellipsoid is given (up to normalization) by the gradient of the implicit function:  
    N = ( (Px–Cx)/a²,  (Py–Cy)/b²,  (Pz–Cz)/c² ).  

---

Assignment

1.  Define the following data structures in your language of choice (C++, Java, Python, etc.):  
    •  Vec3 or Vector3 (with x, y, z and vector operations)  
    •  Ray { origin: Vec3, dir: Vec3 }  
    •  Ellipsoid { center: Vec3, radii: Vec3 }  

2.  Implement a function/method  

    bool intersectEllipsoid(  
        const Ray& ray,           // ray origin O and direction D (assume D is normalized)  
        const Ellipsoid& E,       // ellipsoid center C and radii (a,b,c)  
        float t_min, float t_max, // valid t interval  
        float& t_hit,             // output: intersection t  
        Vec3& out_normal          // output: surface normal at hit  
    );  

    The function should:  
    a)  Compute A, B, C as above.  
    b)  Compute the discriminant Δ.  
    c)  If Δ < 0, return false.  
    d)  Otherwise compute t₁, t₂; choose the smallest t in [t_min, t_max].  
    e)  If no valid t, return false; else set t_hit = chosen t.  
    f)  Compute hit point P = O + t_hit·D.  
    g)  Compute the (unnormalized) normal N = ((Px–Cx)/a², (Py–Cy)/b², (Pz–Cz)/c²), normalize it, store in out_normal.  
    h)  Return true.

3.  Derive the expressions for A, B, and C in your write-up, and briefly explain why the normal is computed via the gradient of the implicit equation.

4.  Test your function with these two cases:

    Case A  
    •  Ray origin O = (0, 0, –5)  
    •  Ray direction D = (0, 0, 1)  
    •  Ellipsoid center C = (0, 0, 0)  
    •  Ellipsoid radii (a, b, c) = (2, 1, 1.5)  
    •  t_min = 0.001, t_max = +∞  

    •  What is t_hit?  
    •  What is the intersection point P?  
    •  What is the (unit) normal at P?  

    Case B  
    •  Ray origin O = (3, 0, 0)  
    •  Ray direction D = (–1, 0, 0)  
    •  Ellipsoid center C = (0, 0, 0)  
    •  Ellipsoid radii (a, b, c) = (2, 1, 1.5)  
    •  t_min = 0.001, t_max = +∞  

    •  Does your function report an intersection?  
    • If yes, give t_hit, P and the normal.

Deliverables  
•  Source code implementing intersectEllipsoid and any helper routines.  
•  A short PDF or text file showing your derivation of A, B, C and a sample run for Case A and Case B with numerical answers.  
•  Comments in code explaining each step clearly.

############### 8.8 ###############
Ray–Ellipsoid Intersection  
=========================  

Background  
----------  
An ellipsoid in 3D can be defined by its center C = (cx, cy, cz) and three axis‐radii (rx, ry, rz).  A point X = (x,y,z) lies on the ellipsoid if and only if:  
  ((x – cx)/rx)² + ((y – cy)/ry)² + ((z – cz)/rz)² = 1  

A ray is given in parametric form as  
  R(t) = O + t D,    t ≥ 0  
where O = (ox, oy, oz) is the ray origin, and D = (dx, dy, dz) is a normalized direction vector (|D| = 1).  

By substituting R(t) into the ellipsoid equation you obtain a quadratic in t:  
  a t² + b t + c = 0  

Your task is to derive these coefficients, solve for t, and implement a routine that returns the nearest valid intersection (smallest t ≥ ε).  

Problem Statement  
-----------------  
1.  Derive expressions for the quadratic coefficients a, b and c in terms of O, D, C, rx, ry, rz.  
2.  Implement the following function in the language of your choice (e.g. C++, Java or Python):  

    bool intersectRayEllipsoid(  
        Vec3  O,      // ray origin  
        Vec3  D,      // ray direction (unit length)  
        Vec3  C,      // ellipsoid center  
        double rx,    // ellipsoid radius along X  
        double ry,    // ellipsoid radius along Y  
        double rz,    // ellipsoid radius along Z  
        double &t     // output: nearest intersection distance  
    );  

    – Return true if there is at least one intersection with t ≥ ε (e.g. ε = 1e–6).  
    – If true, set t to the smallest positive root.  
    – Return false otherwise.  

3.  Your implementation must:  
    •   Translate the problem to a “unit sphere” by scaling coordinates, OR directly build the quadratic coefficients.  
    •   Compute the discriminant Δ = b² – 4ac, test its sign.  
    •   If Δ < 0, there is no intersection.  
    •   Otherwise compute two roots t₁, t₂ = (–b ± √Δ)/(2a), sort them, and pick the smallest t ≥ ε.  

4.  Clearly comment your code to explain each step (derivation, discriminant check, root solving, selection of t).  

Example  
-------  
Input:  
  O  = ( 0, 0, –5)  
  D  = ( 0, 0,  1)  
  C  = ( 0, 0,  0)  
  rx = 1, ry = 2, rz = 1  

Expected behavior:  
  The ray points straight toward the center of a vertically stretched ellipsoid.  
  Intersection distances are t = 4.0 and t = 6.0.  
  Your function should return true and set t = 4.0.  

Deliverables  
------------  
– Source code implementing intersectRayEllipsoid.  
– A short write-up showing your derivation of a, b and c.  
– A brief test report demonstrating correct behavior on at least three different rays (e.g., miss, tangent, two intersections).  

Grading Criteria  
----------------  
•   Correctness of the quadratic derivation.  
•   Robust handling of edge cases (Δ < 0, Δ = 0, t < ε).  
•   Clear, well-commented code.  
•   Demonstration of testing.

############### 8.9 ###############
Ray-Ellipsoid Intersection Programming Exercise

Goal  
-----  
Implement a function that tests a ray against a general ellipsoid, finds the nearest intersection (if any), and computes the surface normal at the hit point.

Ellipsoid Definition  
--------------------  
An ellipsoid centered at C=(cx, cy, cz) with semi-axes a, b, c along the x, y, z axes respectively is the set of points X=(x,y,z) satisfying  
  ((x–cx)/a)² + ((y–cy)/b)² + ((z–cz)/c)² = 1  

Ray Definition  
--------------  
A ray is given in parametric form  
  R(t) = O + t D,  t ≥ 0  
where O=(ox,oy,oz) is the origin and D=(dx,dy,dz) is a unit-length direction vector.

Mathematical Derivation  
-----------------------  
Substitute R(t) into the ellipsoid equation:

((ox + t dx – cx)/a)²  
+ ((oy + t dy – cy)/b)²  
+ ((oz + t dz – cz)/c)² = 1  

Expand to a quadratic in t:

A t² + B t + C = 0  

where  
  A = (dx²/a²) + (dy²/b²) + (dz²/c²)  
  B = 2 [ (dx (ox–cx))/a² + (dy (oy–cy))/b² + (dz (oz–cz))/c² ]  
  C = ((ox–cx)²/a²) + ((oy–cy)²/b²) + ((oz–cz)²/c²) – 1  

Solve this quadratic for real roots t₁, t₂.  
– If no real roots ⇒ no intersection.  
– Otherwise choose the smallest t ≥ 0.  
– If both roots < 0 ⇒ ray points away ⇒ no intersection.  

Once you have t_hit, compute  
  P = O + t_hit D  (intersection point)  
  N_raw = ( (Px–cx)/a², (Py–cy)/b², (Pz–cz)/c² )  
  N = normalize(N_raw)  

Programming Task  
----------------  
1. Define suitable data structures for Ray and Ellipsoid.  
2. Write a function:

bool intersectEllipsoid(  
  const Ray &ray,  
  const Ellipsoid &ell,  
  float &t_hit,           // returned distance along ray  
  Vec3 &hitPoint,         // returned intersection point  
  Vec3 &hitNormal         // returned surface normal  
);

– Return true if an intersection at t_hit ≥ 0 is found, otherwise false.  
– On true, t_hit must be the smallest non-negative solution.  
– hitPoint = ray.O + t_hit * ray.D  
– hitNormal = normalized gradient as above.  

3. Be careful to:  
  • Normalize the ray direction before using it.  
  • Handle the “origin inside ellipsoid” case. If O is inside, C<0 and you still get two roots: pick the larger positive root for the exit intersection.  

Test Cases  
----------  
Use these to verify your code:

1) Ellipsoid centered at (0,0,0), a=2, b=1, c=1  
   Ray origin O=(5,0,0), D normalized = (–1,0,0)  
   Expected: intersects at t_hit=3.0  
     hitPoint = (2,0,0)  
     hitNormal = (1,0,0)

2) Same ellipsoid,  
   O=(0,0,0)  (inside),  D=(1,1,0) normalized ≈(0.7071,0.7071,0)  
   Solve for exit intersection.  
   Expected t_hit ≈ ?  (you should compute and verify)  

Deliverables  
------------  
• Source code implementing intersectEllipsoid.  
• A brief write-up showing your derivation of A, B, C.  
• Output from the two test cases above (numerical t_hit, hitPoint, hitNormal).

############### 9.0 ###############
Ray–CutSphere Intersection (Programming Exercise)

Overview  
---------  
In this exercise you will implement the ray‐object intersection for a “cut sphere.” A cut sphere is the portion of a full sphere that remains after slicing it by two parallel planes. Your code must compute, for any ray, whether it hits that truncated volume—and if so, at what parameter t and with what surface normal.

Object Definition  
-----------------  
• Center C = (Cx, Cy, Cz)  
• Radius R > 0  
• Lower cut plane: y = Cy + y_min  
• Upper cut plane: y = Cy + y_max  
  (Here y_min < y_max, measured relative to the sphere’s center.)  

The cut sphere consists of all points P on the full sphere |P–C|=R whose y‐coordinate satisfies  
  Cy + y_min ≤ Py ≤ Cy + y_max.  

Your task  
---------  
1. Define a class or struct CutSphere with members:  
     – Vec3 C;        // center  
     – float R;       // radius  
     – float y_min;   // lower cut offset  
     – float y_max;   // upper cut offset  

2. Implement a method (or function)  
     bool intersect(const Ray& ray, float t_min, float t_max, HitRecord& rec)  
   that:  
   a. Solves the quadratic for intersections with the full sphere.  
   b. For each candidate root t in [t_min, t_max], computes P = ray(t).  
   c. Checks if P.y – Cy is in [y_min, y_max].  
   d. Returns the smallest valid t, and fills rec with:  
      – rec.t = t  
      – rec.P = P  
      – rec.normal = (P–C) / R  (the outward‐pointing normal)  

3. If no valid intersection exists, return false.  

Requirements & Hints  
-------------------  
• Solve at most two roots of at^2 + bt + c = 0. Reject complex roots.  
• Always pick the smaller t that lies in [t_min, t_max] and whose P.y is in the allowed range.  
• Floating-point care: compare P.y–Cy ≥ y_min – ε and ≤ y_max + ε (ε≈1e–6) if needed.  

Test Cases  
----------  
Use the following data to verify your implementation. All rays originate outside the cut sphere.  

CutSphere parameters:  
 C = (0, 0, 0), R = 1.0, y_min = –0.5, y_max = +0.5  

Rays (each row is: origin O, direction D, expected hit?, expected t, expected normal N):  

1) O = (0, –2,  0), D = (0, +1, 0)  
   – Hits the lower cap at y = –0.5.  
   – t = 1.5  
   – N = (0, –1, 0)  

2) O = (0, –2,  0.9), D = (0, +1, 0)  
   – Misses (point on full sphere would be y=–0.435, but 0.9>√(1–0.435²) so no intersection).  
   – hit? = false  

3) O = (–2, 0,  0), D = (+1, 0, 0)  
   – Hits the cylindrical band of the cut sphere at x = –1.  
   – t = 1.0  
   – N = (–1, 0, 0)  

4) O = (0,  2,  0), D = (0, –1, 0)  
   – Hits the upper cap at y = +0.5.  
   – t = 1.5  
   – N = (0, +1, 0)  

5) O = (0,  2,  0.9), D = (0, –1, 0)  
   – Misses (same reasoning as #2).  
   – hit? = false  

6) O = (0,  0,  2), D = (0,  0, –1)  
   – Hits the band at z = +1.  
   – t = 1.0  
   – N = (0, 0, 1)  

Submission  
----------  
• Source file implementing CutSphere and its intersect() method.  
• A simple main() or unit‐test driver that runs the six test rays and prints for each:  
    hit / miss, t, and normal.  
• A brief README describing any epsilon thresholds you used.

############### 9.1 ###############
Ray‐Object Intersection: “Cut Sphere”  

In this exercise you will implement ray–object intersection for a “cut sphere,” i.e. a standard sphere of radius R and center C that has been truncated (cut) by two horizontal planes y = C.y + yMin and y = C.y + yMax.  Only the portion of the sphere with  
 C.y + yMin ≤ y ≤ C.y + yMax  
remains visible.  

----------------------------------------------------------------------  
Part 1 – Mathematical Derivation  

1.  Ray parameterization  
    Ray: P(t) = O + t D, t ≥ 0  
    O = ray origin, D = ray direction (normalized).  

2.  Sphere equation  
    ∥P − C∥² = R².  

3.  Substitute P(t) into sphere equation → quadratic in t:  
    A t² + B t + C₀ = 0,  
    where  
      A  = D · D  
      B  = 2 D · (O − C)  
      C₀ = (O − C)·(O − C) − R².  

4.  Discriminant Δ = B² − 4 A C₀.  
    – If Δ < 0: no real intersections → reject.  
    – Else solve t₁ = (−B − √Δ)/(2A), t₂ = (−B + √Δ)/(2A), with t₁ ≤ t₂.  

5.  Find the smallest t in your valid [t_min, t_max] range such that the corresponding hit point P(t) lies between the cut planes:  
    y = P(t).y satisfies C.y + yMin ≤ y ≤ C.y + yMax.  

----------------------------------------------------------------------  
Part 2 – Programming Task  

You are given the following C++ struct (you may adapt to your own language):  

  struct Ray {  
    Vec3     origin;    // O  
    Vec3     direction; // D, assumed normalized  
    float    tMin, tMax;  
  };  

  struct HitRecord {  
    Vec3     p;         // Intersection point  
    Vec3     normal;    // Surface normal at p  
    float    t;         // Ray parameter  
    float    u, v;      // Optional: parametric coords for shading  
  };  

  struct CutSphere {  
    Vec3     center;    // C  
    float    radius;    // R > 0  
    float    yMin;      // lower cut, relative to C.y  
    float    yMax;      // upper cut, relative to C.y  
  };  

Implement the method  

  bool intersect(const Ray& ray, const CutSphere& sph, HitRecord& rec);  

so that it returns true if and only if the ray hits the truncated sphere portion within ray.tMin ≤ t ≤ ray.tMax.  On success, it must fill rec with:  
  • rec.t        = the smallest valid t  
  • rec.p        = ray.origin + t*ray.direction  
  • rec.normal   = ∇(∥P−C∥²−R²) evaluated at P, pointing outward  
  • rec.u, rec.v = parametric coordinates on the sphere:  
        φ = atan2(p.z−C.z, p.x−C.x) ∈ (−π, +π]  
        if φ < 0 then φ += 2π  
        u = φ / (2π)  
        v = (p.y − (C.y + yMin)) / (yMax − yMin)  

Requirements:  
  1.  Compute A, B, C₀ and Δ exactly as above.  
  2.  If Δ < 0, return false.  
  3.  Compute t₁, t₂.  For each t in {t₁, t₂} in ascending order:  
      a.  Check ray.tMin ≤ t ≤ ray.tMax.  
      b.  Compute P = O + t D, check C.y + yMin ≤ P.y ≤ C.y + yMax.  
      c.  If both pass, record t and break.  
  4.  If no valid t is found, return false.  
  5.  Otherwise fill rec as specified and return true.  

----------------------------------------------------------------------  
Part 3 – Test Cases  

Below are a few rays and sphere parameters.  For each, state whether intersect() returns true or false.  If true, give t and the intersection point P.

1) sph: center=(0,0,0), R=1, yMin=−0.5, yMax=+0.5  
   ray: origin=(0,2,0), direction=(0,−1,0), tMin=0.1, tMax=10  
   → ?  

2) sph: center=(1,1,1), R=2, yMin=−1, yMax=+1  
   ray: origin=(1,4,1), direction=(0,−1,0), tMin=0, tMax=10  
   → ?  

3) sph: center=(0,0,0), R=1, yMin=0.8, yMax=1.5  
   ray: origin=(0,2,0), direction=(0,−1,0), tMin=0, tMax=10  
   → ?  

(You can solve these by hand or with a short script.)  

----------------------------------------------------------------------  
Grading Criteria  

– Correct quadratic setup and discriminant test  
– Proper ordering: t₁, t₂, ray bounds  
– Correct plane‐cut test on P.y  
– Accurate normal, u, v if requested  
– No false positives/negatives on edge cases (ray just grazing top/bottom cuts)

############### 9.2 ###############
Exercise: Ray–Cut-Sphere Intersection

Background  
A “cut sphere” is a standard sphere whose surface has been truncated (sliced off) by two parallel planes.  Only the portion of the spherical surface lying between these planes participates in ray‐object intersection tests (we do *not* include intersections on the planar caps themselves).

Object Definition  
• Center  C = (Cx, Cy, Cz)  
• Radius  R > 0  
• Lower clipping plane at y = y_min  (y_min ≥ Cy – R)  
• Upper clipping plane at y = y_max  (y_max ≤ Cy + R, and y_max > y_min)

Ray Definition  
• Origin  O = (Ox, Oy, Oz)  
• Direction  D = (Dx, Dy, Dz), assumed normalized  
• Ray parametric form:  P(t) = O + t D,  t ≥ 0

Your Task  
1.  Derive an algorithm (in prose or pseudocode) to compute the nearest intersection t₀ ≥ 0 between a ray and the cut sphere’s *curved surface*.  If there is no valid intersection, the function should indicate “no hit.”  
2.  In your algorithm, be explicit about each step:  
    a.  Solve the quadratic for the full sphere.  
    b.  Filter the real, positive roots by checking whether the intersection point’s y‐coordinate lies between y_min and y_max.  
    c.  Select the smallest valid t (if any).  
3.  Explain how to compute the surface normal N at the hit point P(t₀).  

Function Signature (for guidance)  
    struct Ray { Vec3 O, D; };  
    struct CutSphere { Vec3 C; float R, y_min, y_max; };  

    // Returns true if there is a hit.  
    // On hit, sets tHit = nearest t and hitNormal = outward normal.  
    bool intersectCutSphere(const Ray& ray,  
                            const CutSphere& sph,  
                            float& tHit,  
                            Vec3& hitNormal);

Deliverables  
• Pseudocode or step-by-step description of intersectCutSphere.  
• The mathematical expressions for a, b, c in the quadratic, and for the normal.  

Clarifications  
– You do *not* need to handle intersections with the planar caps.  
– Assume D is normalized.  
– If both roots lie outside [0, ∞) or yield y outside [y_min, y_max], report “no hit.”  

Optional Extension (extra credit)  
Modify your algorithm to *also* include intersections with the two planar caps. For each cap:  
  • Compute t_plane so that P.y(t_plane) = y_min or y_max.  
  • Check that the xz‐distance from the sphere’s axis satisfies (x–Cx)²+(z–Cz)² ≤ R².  
  • Include these t_plane candidates when choosing the nearest intersection.

############### 9.3 ###############
Ray‐Cut‐Sphere Intersection (Programming Exercise)

Objective  
---------  
Write a function that tests a ray against a “cut sphere,” i.e. the curved part of a sphere that has been truncated (cut off) by a single plane.  You should only consider intersections with the spherical surface itself; the planar cap is not part of the object.

Problem Description  
-------------------  
• The full sphere S has center  
  C = (0, 0, 0)  
  and radius  
  R = 1.0  
• The cutting plane P is given by  
  N · X = d  
  where  
  N = (0, 1, 0)  (unit normal pointing “up”)  
  d = 0.5  
  Thus P is the horizontal plane y = 0.5, and we keep only the portion of S satisfying N·X ≥ d (i.e. y ≥ 0.5).  

Ray parameterization:  
  r(t) = O + t D,   t ≥ 0  
where  
  O = ray origin,  
  D = ray direction (assume normalized).  

You must implement:

bool intersect_cut_sphere(  
    const Vec3& O,  
    const Vec3& D,  
    float  t_min,  
    float  t_max,  
    HitRecord& rec  
);

– Returns true if r(t) hits the curved part of the cut sphere for some t in [t_min, t_max].  
– On success, fills rec.t (the hit-time), rec.P (hit point), and rec.N (surface normal at P).  

HitRecord is defined as:  
struct HitRecord {  
    float t;     // parameter along the ray  
    Vec3  P;     // point of intersection  
    Vec3  N;     // surface normal at P (unit length, pointing outward)  
};  

Your task  
---------  
1.  Derive and solve the quadratic equation for intersections of the ray with the full sphere:  
     a = D·D  
     b = 2 D·(O − C)  
     c = (O − C)·(O − C) − R²  
     solve a t² + b t + c = 0.  
2.  If there are no real roots, return false.  
3.  Otherwise let t₀ ≤ t₁ be the two real solutions.  For each t in {t₀, t₁} (in ascending order):  
   a. If t < t_min or t > t_max, skip it.  
   b. Compute P = O + t D.  
   c. Check the plane constraint: N·P ≥ d?  
     – If no, skip to the next root.  
     – If yes, we have a valid hit:  
         • rec.t = t  
         • rec.P = P  
         • rec.N = normalize(P − C)  
         • return true  
4.  If neither root yields a valid hit, return false.  

Starter Code (C++-style pseudocode)  
-----------------------------------  
```cpp
struct Vec3 {
    float x,y,z;
    // ... (vector addition, dot product, scalar multiply, length, normalize, etc.)
};

struct HitRecord {
    float t;
    Vec3  P;
    Vec3  N;
};

bool intersect_cut_sphere(
    const Vec3& O,
    const Vec3& D,
    float        t_min,
    float        t_max,
    HitRecord&   rec
) {
    Vec3  C = Vec3{0,0,0};
    float R = 1.0f;
    Vec3  N = Vec3{0,1,0};   // plane normal
    float d = 0.5f;          // plane offset

    // Shift ray origin into sphere’s local space
    Vec3 OC = O - C;

    // Quadratic coefficients
    float a = dot(D, D);                    // =1 if D is normalized
    float b = 2.0f * dot(D, OC);
    float c = dot(OC, OC) - R*R;

    float disc = b*b - 4*a*c;
    if (disc < 0.0f) return false;  // no real roots

    float sqrt_disc = sqrt(disc);
    float inv2a = 1.0f / (2.0f * a);

    // two candidate hits
    float t0 = (-b - sqrt_disc) * inv2a;
    float t1 = (-b + sqrt_disc) * inv2a;

    // consider the smaller root first
    for (float t : {t0, t1}) {
        if (t < t_min || t > t_max) 
            continue;
        Vec3 P = O + D * t;        // hit point
        if (dot(N, P) < d)         // below the cut plane?
            continue;
        // record hit
        rec.t = t;
        rec.P = P;
        rec.N = normalize(P - C);  // outward normal of sphere
        return true;
    }

    return false;
}
```

Test Cases  
-----------  
1) Ray misses entirely:  
   O =(0,0,−3), D =(0,0,1) → It would hit the sphere at y=0 etc., but none of those points satisfy y≥0.5.  
   intersect_cut_sphere(...) should return false.  

2) Ray hits the curved patch:  
   O =(0,2,−3), D =(0,−1,1).normalized()  
   This ray comes from above and will intersect the spherical cap where y≥0.5.  
   Call intersect_cut_sphere(O,D,0.001,100,rec) → returns true, rec.t ≈ 2.121, rec.P ≈ (0,0.5,−0.5), rec.N ≈ (0,−0.5,−0.5).  

Deliverables  
------------  
• Complete implementation of `intersect_cut_sphere` in your language of choice.  
• A brief explanation (1–2 paragraphs) of how you enforced the plane‐cut constraint.  
• Output of at least two hand‐computed test rays (origin, direction) and the resulting hit record or “no hit.”

############### 9.4 ###############
Ray–Object Intersection Exercise: CutSphere  
===========================================

In this exercise you will extend your ray tracer to support a “cut sphere,” i.e. a standard sphere trimmed (clipped) by two horizontal planes.  Only the portion of the sphere between those planes should count as “surface.”

Object definition  
-----------------  
A CutSphere is defined by:  
•  Center C = (Cx, Cy, Cz)  
•  Radius R > 0  
•  y‐limits y₀ < y₁, given in world‐space coordinates  
  (so the valid surface on the sphere satisfies y₀ ≤ Py ≤ y₁)  

Geometric description  
---------------------  
The CutSphere consists of all points P on the sphere  
   ‖P – C‖ = R  
whose y–coordinate lies between y₀ and y₁.  
We do _not_ include the planar caps at y = y₀ or y = y₁—only the trimmed spherical surface.

Your task  
----------  
Implement the method
   bool CutSphere::hit(const Ray& r, float t_min, float t_max, HitRecord& rec) const;
which returns true if ray r(t) = A + t·B (t ≥ 0) intersects the CutSphere between t_min and t_max.  On success you must fill rec.t (the parameter t), rec.p (hit point), and rec.normal (unit normal).

1)  Derive the quadratic.  
    Let oc = A – C.  Then the sphere‐intersection equation  
       ‖A + t B – C‖² = R²  
    expands to  
       a t² + 2b t + c = 0  
    where  
       a = B·B  
       b = oc·B  
       c = oc·oc – R²  

2)  In your code, solve for the two roots t = [–b ± sqrt(b² – a·c)]/a.  (Notice we absorbed the 2 into b for clarity.)  

3)  For each root t in ascending order:  
   •  If t < t_min or t > t_max, reject it.  
   •  Compute P = r(t).  
   •  If P.y < y₀ or P.y > y₁, reject it (point lies outside the slab).  
   •  Otherwise you have a valid hit.  Set  
        rec.t = t  
        rec.p = P  
        rec.normal = (P – C) / R  
     and return true.  

4)  If neither root yields a valid hit, return false.

Function prototype (C++‐style)  
-------------------------------  
```cpp
struct HitRecord {
    float t;
    Vec3  p;
    Vec3  normal;
    // ... you can include other fields (u,v, material, etc.)
};

class CutSphere {
public:
    CutSphere(const Vec3& center, float radius, float y0, float y1, std::shared_ptr<Material> m)
      : C(center), R(radius), y_min(y0), y_max(y1), matPtr(m) {}

    // Ray: origin A, direction B, point P(t)=A+tB
    bool hit(const Ray& r, float t_min, float t_max, HitRecord& rec) const;

private:
    Vec3 C;         // center
    float R;        // radius
    float y_min;    // lower cap: y >= y_min
    float y_max;    // upper cap: y <= y_max
    std::shared_ptr<Material> matPtr;
};
```

What to implement  
-----------------  
Fill in CutSphere::hit(…) following the steps above.  Pay particular attention to:  
•  Computing the quadratic discriminant correctly.  
•  Testing both roots in ascending order.  
•  Clipping out points whose y–coordinate lies outside [y_min, y_max].  
•  Computing the outward‐facing normal on the spherical surface.

Test case  
---------  
You may verify your implementation with a CutSphere centered at C=(0,0,–5), R=2, y₀=–1, y₁=1.  
•  A ray from the origin (0,0,0) in direction (0,0,–1) should hit around t≈3.0, at P≈(0,0,–3).  
•  A ray from (0,2,0) in direction (0,–1,–2) normalized should miss (it passes above y=1).  
•  A ray from (0,0.8,0) in direction (0,0,–1) hits the curved surface near y=0.8.

Deliverables  
------------  
1. Your source code for `CutSphere::hit`.  
2. Brief derivation of your quadratic coefficients (a, b, c).  
3. A few rendered images or console test outputs demonstrating both hits and misses at various y–levels.

############### 9.5 ###############
Ray–Cut‐Sphere Intersection Exercise

In this problem you will implement ray‐object intersection for a “cut sphere,” i.e. a sphere that has been truncated (clipped) by two parallel planes.  The sphere is centered at the origin, has radius R, and only the portion with z ∈ [zMin, zMax] remains.  No end‐caps are added—rays can only hit the curved surface.

—————————————————————————————————————
Geometry

  CutSphere:
    Center C = (0, 0, 0)
    Radius R > 0
    zMin ≤ zMax  (the allowed z‐interval on the sphere’s surface)

  A point P = (x,y,z) lies on the curved surface of the CutSphere if and only if
    x² + y² + z² = R²
  and
    zMin ≤ z ≤ zMax.

Ray:
  r(t) = O + t D,    t ≥ 0,
  where O is the origin, D is a normalized direction, and t is the ray parameter.

Your task is to write a function that, given a Ray and a CutSphere, determines whether they intersect, and if so returns:

  • the nearest intersection parameter tHit ∈ [tMin, tMax],  
  • the hit‐point PHit = O + tHit D,  
  • the surface normal N at PHit, pointing outward.

—————————————————————————————————————
Part 1. Derivation (short answer)

a) Write the quadratic equation for t that results from substituting r(t) into the full sphere equation x²+y²+z²=R².  
   (Hint: expand |O + t D|² = R² to at² + bt + c = 0; identify a, b, c.)

b) Explain how you would test the two real roots t0 ≤ t1 to find the “first” valid intersection in [tMin, tMax] whose hit‐point’s z lies in [zMin, zMax].  

—————————————————————————————————————
Part 2. Implementation (in C++‐style pseudocode)

Using your answers from Part 1, fill in the body of this method.  You may assume:

  struct Vec3 { double x,y,z; /* +, –, dot, length², normalize, … */ };
  struct Ray  { Vec3 o, d; double tMin, tMax; };
  struct Hit  { double t; Vec3 p, n; };

  struct CutSphere {
    double radius;
    double zMin, zMax;
  };

  // Returns true if an intersection is found; hit is filled with t, p, n.
  bool intersect(const CutSphere &S, const Ray &ray, Hit &hit) {
    // 1) Sphere‐intersection coefficients
    double a = dot(ray.d, ray.d);
    double b = 2 * dot(ray.d, ray.o);
    double c = dot(ray.o, ray.o) - S.radius*S.radius;

    // 2) Solve quadratic a t² + b t + c = 0
    double disc = b*b - 4*a*c;
    if (disc < 0) return false;
    double sqrtD = sqrt(disc);

    // 3) Find the two roots t0 <= t1
    double inv2a = 0.5 / a;
    double t0 = (-b - sqrtD) * inv2a;
    double t1 = (-b + sqrtD) * inv2a;
    if (t0 > t1) std::swap(t0, t1);

    // 4) Check each root in turn for validity
    auto testRoot = [&](double tCandidate) -> bool {
      if (tCandidate < ray.tMin || tCandidate > ray.tMax) return false;
      Vec3 P = ray.o + ray.d * tCandidate;
      if (P.z < S.zMin || P.z > S.zMax)      return false;
      // It’s a valid hit
      hit.t = tCandidate;
      hit.p = P;
      // Outward normal on the sphere
      hit.n = normalize(P);  
      return true;
    };

    if (testRoot(t0)) return true;
    if (testRoot(t1)) return true;
    return false;
  }

—————————————————————————————————————
Part 3. Verification (example rays)

Given a CutSphere with R = 1.0, zMin = –0.5, zMax = +0.5:

1. Ray A: origin (0.9, 0, –3), direction (0, 0, 1), tMin = 0, tMax = 1e6  
   • Solve intersection: sphere hits at t≈2.565 so P≈(0.9,0,–0.435).  
   • –0.5 ≤ –0.435 ≤ +0.5 ⇒ valid.  
   • Your code should return t≈2.565, P≈(0.9,0,–0.435), N≈normalize(0.9,0,–0.435).

2. Ray B: origin (0, 0, –3), direction (0, 0, 1), tMin = 0, tMax = 1e6  
   • Hits full sphere at z=–1 (t=2) and z=+1 (t=4), but both lie outside [–0.5,+0.5].  
   • Your code should report “no intersection.”

—————————————————————————————————————
Deliverables

  • Part 1: short derivation and root‐testing description (1–2 paragraphs).  
  • Part 2: completed intersect(…) code.  
  • Part 3: computed t, P, N for the two example rays.

############### 9.6 ###############
Programming Assignment: Ray–Cut Sphere Intersection

Background  
A “cut sphere” is the portion of a sphere that remains after slicing it with two parallel planes. In this exercise you will implement ray–object intersection for a sphere of radius r centered at C = (cx, cy, cz), truncated by two horizontal planes y = y₀ and y = y₁ (with y₀ < y₁). Only the curved surface of the sphere between these two planes is considered “hittable.”  

Your task  
1. Define a class or struct `CutSphere` with members:  
   • Center C = (cx, cy, cz)  
   • Radius r  
   • Lower cut y₀  
   • Upper cut y₁  

2. Implement inside `CutSphere` a method with signature:  
   bool hit(const Ray& ray, double t_min, double t_max, HitRecord& rec) const;  

   The method should:  
   a. Solve for t in the ray equation P(t) = O + t D subject to |P(t) – C| = r.  
      • Let oc = O – C.  
      • Quadratic coefficients:  
         a = D·D  
         b = 2 D·oc  
         c = oc·oc – r²  
      • Discriminant Δ = b² – 4 a c  
      • If Δ < 0, return false (no real roots).  

   b. Compute the two roots:  
      t₁ = (–b – √Δ) / (2 a)  
      t₂ = (–b + √Δ) / (2 a)  

   c. For each root t in ascending order:  
      • Check t_min < t < t_max.  
      • Compute the y-coordinate of the intersection point:  
          y = O.y + t D.y  
      • If y₀ ≤ y ≤ y₁, then it is a valid hit on the curved surface. Record:  
         – rec.t = t  
         – rec.point = P(t)  
         – outward normal = (rec.point – C) / r  
         – (Optionally) compute texture coordinates (u,v):  
             φ = atan2(z – cz, x – cx)  
             θ = asin((y – cy)/r)  
             u = (φ + π) / (2π),  v = (θ + π/2) / π  
         – Return true.  

   d. If neither root yields a valid y, return false.  

3. Ensure that:  
   • You handle the two roots in the correct order so you always return the closest valid hit.  
   • The normal vector is consistently outward-pointing.  
   • Your code does not assume anything special about the ray direction (it may not be unit-length).  

Deliverables  
• Source code for `CutSphere` and its `hit` method.  
• A brief write-up (1–2 paragraphs) explaining how you derived the quadratic and how you applied the y-range checks.  

Testing  
Include at least three test rays that:  
• Miss the sphere entirely.  
• Hit the sphere outside the cut region.  
• Hit the curved surface within [y₀, y₁].  

Be prepared to discuss edge cases, e.g., grazing intersections at y=y₀ or y=y₁.

############### 9.7 ###############
Ray‐Object Intersection – Cut Sphere

In this exercise you will write an intersection routine for a “cut sphere,” defined as the portion of a sphere that lies between two parallel cutting planes.  Your task is to derive the ray–sphere intersection, clip it to the z‐limits, handle the planar caps, and return the correct hit point and normal.

Problem Statement
---------------

We define a cut sphere by:

  • A sphere of radius R centered at C = (Cx, Cy, Cz).  
  • Two horizontal cutting planes at z = Cz + z_min and z = Cz + z_max, with  
      –R ≤ z_min < z_max ≤ R.  
  • The resulting surface consists of  
      1. The portion of the sphere with Cz + z_min ≤ z ≤ Cz + z_max.  
      2. The planar caps (disks) where the sphere was sliced.

You are given a ray  
   O(t) = O + t D,  
where O is the origin, D is a unit‐length direction, and t ≥ 0.

Write a function in C++-like pseudocode:

  bool intersectCutSphere(  
      const Ray&    ray,        // contains ray.O and ray.D (unit)  
      const Vec3&   center,     // (Cx, Cy, Cz)  
      float         R,          // sphere radius > 0  
      float         z_min,      // lower cut, relative to Cz  
      float         z_max,      // upper cut, relative to Cz  
      float&        t_hit,      // output: smallest positive t  
      Vec3&         hitPoint,   // output: O + t_hit*D  
      Vec3&         normal      // output: outward unit normal  
  );

The function returns true if the ray intersects the cut sphere (either the curved surface or one of the caps) at some t_hit > 0, and false otherwise.

Your answer must include:

1.  **Derivation of the quadratic**  
    Show how to obtain the coefficients a, b, c of  
      ‖(O – C) + t D‖² = R²  
    and solve for t using the quadratic formula.

2.  **Z‐limit clipping**  
    For each root t_i > 0, compute the candidate point P_i = O + t_i D and check  
      Cz + z_min ≤ P_i.z ≤ Cz + z_max.  

3.  **Cap intersections**  
    If neither spherical‐surface hit lies within [Cz + z_min, Cz + z_max], test intersection with the planes z = Cz + z_min and z = Cz + z_max:  
      • Solve t_plane = (Cz + z_plane – O.z)/D.z,  
      • Check t_plane > 0,  
      • Compute P_plane = O + t_plane D,  
      • Accept only if (P_plane – C_xy)² ≤ R² (point lies inside the circular cap).

4.  **Normal computation**  
    • On the spherical surface: normal = (P – C).normalized()  
    • On the lower cap (z = Cz + z_min): normal = (0,0,–1)  
    • On the upper cap (z = Cz + z_max): normal = (0,0,+1)

5.  **Pseudocode**  
    Provide clear, step‐by‐step pseudocode that puts it all together, chooses the smallest positive t, and returns the correct normal and hit point.

Be concise. You do not have to handle numerical epsilons beyond noting “t > 0.”

############### 9.8 ###############
Ray-Object Intersection: “Cut Sphere”  
--------------------------------------  
In this exercise you will implement ray intersection against a “cut sphere,” i.e. a sphere truncated by two parallel planes.  The resulting solid has three faces:  
  1. The curved portion of the sphere between two z–limits.  
  2. A circular cap at z = zMin.  
  3. A circular cap at z = zMax.  

Your task is to write a function  
    bool intersectCutSphere(  
        const Ray&        ray,      // ray origin O and unit‐direction D  
        float             tMin,     // minimum t to consider (e.g. 0.001f)  
        float             tMax,     // maximum t to consider (e.g. +∞)  
        const CutSphere&  sph,      // cut‐sphere parameters  
        HitRecord&        rec       // OUT: if hit, stores t, point p, and normal n  
    );  
that returns true if the ray strikes the cut sphere at some t ∈ [tMin, tMax], storing the nearest hit in rec, and false otherwise.  

CutSphere Definition  
--------------------  
struct CutSphere {  
    Vec3   center;    // sphere center  
    float  radius;    // sphere radius > 0  
    float  zMin;      // z‐lower cut  (in sphere’s local coords)  
    float  zMax;      // z‐upper cut, with zMin < zMax, and |zMin|,|zMax| ≤ radius  
};  

All coordinates are in world space.  The planes z = zMin and z = zMax are understood in the sphere’s local coordinate system (i.e. after translating by –center).  

Algorithm Outline  
-----------------  
1. Sphere‐Surface Intersection  
   • Solve (O' + tD)·(O' + tD) = R², where O' = ray.origin – center.  
   • This yields up to two real roots t0 ≤ t1.  
   • For each t∈{t0,t1} in ascending order:  
       – Compute p = O' + tD.  
       – If p.z ∈ [zMin, zMax] and t ∈ [tMin, tMax], record this as a candidate.  

2. Planar Cap Intersections  
   For each cap plane k ∈ {zMin, zMax}:  
   • Solve O'.z + t·D.z = k  ⇒  t = (k – O'.z)/D.z, provided D.z ≠ 0.  
   • Compute p = O' + tD.  
   • If p.x² + p.y² ≤ R² (inside the circle), and t ∈ [tMin, tMax], record as a candidate;  
     the normal is +Z for k = zMax and –Z for k = zMin (in local space, then transform to world).  

3. Choose the smallest t among all valid candidates, fill rec.p and rec.normal (normalized), and return true.  
   If no candidate lies in [tMin, tMax], return false.  

What To Submit  
---------------  
• A short derivation of the quadratic you solve for the sphere.  
• A clean C++ (or Java/C#) implementation of intersectCutSphere(), including:  
  – All vector-math / dot products you use.  
  – Proper handling of the spherical surface and both caps.  
  – Careful selection of the nearest t in [tMin, tMax].  
• A brief test plan listing at least three rays (origin, direction) that exercise:  
  – Hitting only the spherical band.  
  – Hitting only the lower cap.  
  – Missing the cut sphere entirely.  

Scoring  
-------  
• Correct quadratic setup and solution: 30%  
• Proper z–range and cap tests:               40%  
• Code correctness & robustness (edge cases): 20%  
• Test cases & write-up clarity:               10%  

Good luck!

############### 9.9 ###############
Ray–Cut‐Sphere Intersection  
-----------------------------

In this exercise you will extend your ray tracer so that it can intersect a sphere that has been “cut” by a single plane.  The solid you must handle is

 S = { X ∈ ℝ³ | ‖X – C‖ ≤ R  and  (X·N) ≥ d }  

—that is, a sphere of radius R centered at C = (Cx, Cy, Cz) truncated by the half‐space on the side of the plane N·X = d (N is a unit‐length normal).  The surface of S consists of  
  1. the spherical portion S_sph:  { X | ‖X–C‖ = R  and  N·X ≥ d }, and  
  2. the planar cap    S_cap:  { X | N·X = d  and  ‖X–C‖ ≤ R }.  

Your task is to write a function

 Hit intersectCutSphere(const Ray& ray,
                       const Vec3& C,
                       float R,
                       const Vec3& N,
                       float d)

which returns the closest intersection (t, position P, normal n) with S for t > t_min, or “no hit” if there is none.  

----------------------------------------------------------------------  
1.  Ray‐Sphere Intersection  
    •  A ray is P(t) = O + t D, t > t_min.  Solve  
       ‖(O + t D) – C‖² = R²  
       → at² + bt + c = 0,  
         a = D·D,  
         b = 2 D·(O–C),  
         c = (O–C)·(O–C) – R².  
    •  Compute discriminant Δ = b² – 4ac.  If Δ < 0, no real roots → no sphere hit.  
    •  Otherwise compute the two roots t₁ ≤ t₂.  Consider each tᵢ > t_min in ascending order.  
       For each candidate tᵢ check the point Pᵢ = O + tᵢ D.  If N·Pᵢ ≥ d, it lies on the spherical patch S_sph → record it as a valid hit with normal  
           n = (Pᵢ – C) / R.  
       Otherwise discard that root and continue.  

2.  Ray‐Plane Intersection (the cap)  
    •  The plane is N·X = d.  Ray‐plane intersection gives  
           t_plane = (d – N·O) / (N·D)  
       if denom = N·D ≠ 0.  
    •  Check t_plane > t_min.  Let P_plane = O + t_plane D.  
       Then check whether P_plane lies inside the disc of radius R around C:  
           ‖P_plane – C‖² ≤ R².  
    •  If so, we have a valid hit on S_cap with normal n = N (or –N depending on which side you define as “outside”).  

3.  Choosing the Closest Hit  
    •  Collect up to three candidate hits: up to two from the sphere and one from the cap.  
    •  Discard any with t ≤ t_min or whose intersection‐point test fails.  
    •  Return the one with the smallest t; if none remain, return “no hit.”  

----------------------------------------------------------------------  
Function Prototype (C++‐style pseudocode)

struct Hit {
  bool    hit;        // did we hit anything?
  float   t;          // ray parameter
  Vec3    position;   // O + t*D
  Vec3    normal;     // unit normal at hit point
};

Hit intersectCutSphere(
    const Ray&  ray,   // ray.origin O, ray.direction D
    const Vec3& C,     // sphere center
    float        R,    // sphere radius
    const Vec3&  N,    // cut‐plane normal (assumed unit length)
    float        d,    // plane offset, plane equation N·X = d
    float        t_min // minimum valid t 
) {
  Hit closest; 
  closest.hit = false;
  closest.t   = +∞;

  // 1) Sphere‐body intersections
  Vec3  OC = ray.origin - C;
  float a = dot(ray.direction, ray.direction);
  float b = 2.0f * dot(ray.direction, OC);
  float c = dot(OC, OC) - R*R;
  float disc = b*b - 4*a*c;
  if (disc >= 0.0f) {
    float sqrtD = sqrt(disc);
    float t1 = (-b - sqrtD) / (2*a);
    float t2 = (-b + sqrtD) / (2*a);
    for (float t_sph : { t1, t2 }) {
      if (t_sph <= t_min || t_sph >= closest.t) continue;
      Vec3 P = ray.origin + t_sph*ray.direction;
      if (dot(N, P) < d) continue;            // outside cut‐halfspace
      // Valid spherical hit
      Vec3  n_sph = normalize(P - C);
      closest.hit      = true;
      closest.t        = t_sph;
      closest.position = P;
      closest.normal   = n_sph;
    }
  }

  // 2) Planar‐cap intersection
  float denom = dot(N, ray.direction);
  if (fabs(denom) > 1e-6f) {
    float t_plane = (d - dot(N, ray.origin)) / denom;
    if (t_plane > t_min && t_plane < closest.t) {
      Vec3 Pp = ray.origin + t_plane * ray.direction;
      if (length2(Pp - C) <= R*R) {
        // Valid cap hit
        Vec3 n_cap = (denom < 0) ? N : -N;  
        closest.hit      = true;
        closest.t        = t_plane;
        closest.position = Pp;
        closest.normal   = n_cap;
      }
    }
  }

  return closest;
}

----------------------------------------------------------------------  
Testing & Validation  
  •  Sphere center C = (0,0,0), R = 1, plane N = (0,1,0), d = 0.5.  
     – Rays from (0,–2,0) straight up: should hit the cap at y=0.5.  
     – Rays from (0,2,0) straight down: should hit the spherical shell if y>0.5.  
     – Rays from the side should miss if they pass under the cut.  
  •  Try rays grazing the edge of the disc at ‖P–C‖=1, y=0.5 to check numerical robustness.  

----------------------------------------------------------------------  
Hand‐in Requirements  
  1. Source code for intersectCutSphere(…) as above.  
  2. A brief paragraph explaining how you handle (a) sphere discriminant <0, (b) points rejected by the cut‐plane test, and (c) cap‐vs‐sphere‐surface precedence.  
  3. Output screenshots (or console logs) for at least three nontrivial test rays, reporting t, hit‐point, and normal.  

Good luck!

############### 10.0 ###############
Ray‐Shell Intersection (Sphere-with‐Sphere‐Hole)

Objective  
Implement a ray‐object intersection routine for a hollow sphere (a solid sphere with a concentric spherical cavity removed). Your code should return (a) whether the ray hits the shell, (b) the nearest positive hit‐distance t, and (c) the correctly oriented surface normal at the hit point.

Object Definition  
• Center C = (0, 0, 0)  
• Outer radius Rout = 2.0  
• Inner radius Rin = 1.0  
• The shell S = { x | Rin < |x–C| ≤ Rout }

Ray Definition  
A ray R(t) = O + t·D with t ≥ 0, O = origin, D = normalized direction.

Tasks  
1. Derivation (on paper)  
   a. Write the quadratic equation for intersections of R(t) with a sphere of radius R centered at C.  
   b. Apply it to the outer sphere (R = Rout) → roots to (t_o1, t_o2) sorted so t_o1 ≤ t_o2.  
   c. Apply it to the inner sphere (R = Rin) → roots (t_i1 ≤ t_i2).

2. Determine the valid hit interval  
   A ray intersects the hollow shell S if it enters the outer sphere before it leaves it, and that intersection point lies outside the inner cavity.  Concretely:  
   • Compute the two intersection intervals on the ray for the outer sphere [t_o1, t_o2] and for the inner sphere [t_i1, t_i2].  
   • The shell corresponds to the interval(s) [t_o1, t_o2] minus [t_i1, t_i2].  
   • From those remaining segments, select the smallest t ≥ 0. If none exist, there is no hit.

3. Surface normal orientation  
   Once you have the hit parameter t_hit and hit point P = O + t_hit·D:  
    – If P lies on the outer sphere surface (|P–C| ≈ Rout), outward normal N = (P–C)/Rout.  
    – If P lies on the inner cavity surface (|P–C| ≈ Rin), outward normal N = –(P–C)/Rin.  
   (This ensures normals always point “out” of the solid volume.)

4. Pseudocode  
   Write a function with signature something like  
     bool intersectShell(  
       const Ray& ray,  
       const Vec3& C, float Rout, float Rin,  
       float& t_hit, Vec3& normal  
     );  
   – Return true if there is a hit (t_hit set to nearest t ≥ 0).  
   – Return false otherwise.

   Your pseudocode should:  
   a. Solve both quadratics.  
   b. Sort the roots.  
   c. Construct the shell intervals.  
   d. Pick the nearest valid t.  
   e. Compute the normal as above.

5. Test case (for you to verify)  
   Ray: O = (3,  1, 0), D = normalize((–1, 0, 0)).  
   1) Compute t_o1, t_o2, t_i1, t_i2.  
   2) Show which segment of [t_o1,t_o2] minus [t_i1,t_i2] contains the hit.  
   3) Give numeric t_hit and normal N.

Deliverables  
– The derivation from part 1 and interval logic from part 2.  
– Well‐commented pseudocode (or C/++ style code) for intersectShell.  
– Hand‐computed results for the test case in part 5.

Grading points will be awarded for correctness of the math, clarity of interval logic, correct normal orientation, and code clarity.

############### 10.1 ###############
Ray–Object Intersection: “Sphere with a Spherical Hole”  

In this exercise you will implement a ray‐tracing intersection routine for a solid defined by subtracting one sphere from another.  Concretely, let  

  • S_outer be the solid sphere of radius R centered at the origin O = (0,0,0).  
  • S_hole  be the (smaller) sphere of radius r centered at C = (d, 0, 0), with 0 < r < R and |C| + r < R (so that S_hole lies entirely inside S_outer).  

We define our final object S as the set‐difference  
  S = S_outer \ S_hole  
i.e. all points inside (or on) the big sphere but strictly outside the small “hole” sphere.  

Your task is to write a function  

    bool intersectSphereWithHole(  
        const Vec3 &rayO,       // ray origin  
        const Vec3 &rayD,       // ray direction, assumed normalized  
        float  R,               // radius of outer sphere  
        const Vec3 &C,          // center of hole‐sphere  
        float  r,               // radius of hole‐sphere  
        float &t_out,           // (output) distance along ray to intersection  
        Vec3  &normal_out       // (output) unit normal at intersection  
    );  

that returns true if the ray hits S at some t > t_epsilon, returning in t_out the smallest such t, and in normal_out the outward‐pointing surface normal at the hit point P = rayO + t_out*rayD.  If the ray misses S, return false.

1) Intersection‐Interval Method  
   1.1) Write the standard quadratic‐solve for ray–sphere intersection with each of S_outer and S_hole.  From each you get up to two real roots:  
       • t0_o ≤ t1_o for the outer sphere,  
       • t0_h ≤ t1_h for the hole sphere.  
   1.2) The ray’s intersection with the solid S_outer alone lies on the t–interval [t0_o, t1_o].  
   1.3) The ray’s intersection with the removed region S_hole lies on the t–interval [t0_h, t1_h].  
   1.4) The ray actually “sees” S = S_outer \ S_hole on the set difference of intervals:  
       [t0_o, t1_o]  minus  [t0_h, t1_h].  
   1.5) Compute the resulting one or two sub‐intervals, then pick the smallest t > t_epsilon in those intervals as your hit.

2) Surface‐Normal  
   • If the intersection lies on the outer sphere (i.e. in [t0_o, t0_h) or in (t1_h, t1_o]), then  
        normal = (P – O)/|P – O|.  
   • If the intersection lies on the inner (hole) sphere face (i.e. in [t0_h, t1_h] ∩ [t0_o, t1_o]), then the outward normal points into the hole, so  
        normal = –(P – C)/|P – C|.  

3) Deliverables  
   • C++‐style pseudocode (or actual code) for intersectSphereWithHole(…) implementing the above.  
   • A short explanation of how you compute and subtract the two t–intervals.  
   • A discussion of any special cases you handle (e.g. ray origin inside the hole, tangential hits, no real roots).

4) Test Cases (for you to verify)  
   • Ray from (0,0,–5) along +z: should hit outer sphere at z = –√(R² – 0²) and not be affected by the hole if |C| is large enough.  
   • Ray from (d,0,–5) along +z aimed at the hole center: should enter outer sphere, then enter hole, then exit hole, then exit outer.  Your routine must pick the first segment on S_outer \ S_hole.  
   • Ray starting inside the hole sphere: should hit the inner wall first (with reversed normal).  

Make sure your code handles all these cleanly and returns the correct t_out and normal_out for the solid S.

############### 10.2 ###############
Ray-Object Intersection Project: Hollow Sphere (Sphere with a Spherical Hole)

Goal  
Implement ray‐intersection code for a hollow sphere: the solid region between an outer sphere of radius R_out and a concentric inner sphere of radius R_in (0 ≤ R_in < R_out).  Your routine should detect hits on either the outer surface or the inner (hollow) surface, return the closest valid intersection, and compute the correct surface normal.

Object Definition  
• Center C (Vec3)  
• Outer radius R_out > 0  
• Inner radius R_in with 0 ≤ R_in < R_out  
The “object” is the region { p | R_in ≤ ||p – C|| ≤ R_out }. Its two bounding surfaces are:  
  – Outer surface: ||p – C|| = R_out  
  – Inner surface (hole):  ||p – C|| = R_in  

Ray Definition  
A ray R(t) = O + t D,  
• O (origination point)  
• D (direction, assume normalized)  
We seek t ∈ [t_min, t_max], t > 0.

Function Signature (C++‐style)  
```cpp
struct Ray {
    Vec3 origin, direction;
    // ...
};

struct HitRecord {
    float t;         // ray parameter where hit occurs
    Vec3 p;          // hit point
    Vec3 normal;     // surface normal at hit
};

bool intersectHollowSphere(
    const Ray&    ray,
    float         t_min,
    float         t_max,
    const Vec3&   center,
    float         R_out,
    float         R_in,
    HitRecord&    rec
);
```

Requirements  
1. Quadratic Intersection  
   For each sphere (radius = R_out or R_in), solve  
     a = dot(D, D)  
     b = 2 · dot(D, O–C)  
     c = dot(O–C, O–C) – radius²  
   discriminant Δ = b² – 4ac.  
   If Δ < 0 → no real roots → no hit on that sphere.

2. Candidate t’s  
   For each sphere with Δ ≥ 0 compute two roots  
     t₁ = (–b – sqrt(Δ)) / (2a),  
     t₂ = (–b + sqrt(Δ)) / (2a).  
   Collect all tᵢ that satisfy t_min < tᵢ < t_max.

3. Select Closest Hit  
   Among all valid tᵢ, pick smallest t_hit > 0. If none exist, return false.

4. Hit Record  
   Once t_hit is chosen, compute  
     rec.t = t_hit;  
     rec.p = O + t_hit D;  
   Determine which sphere gave t_hit:  
     – If it came from the outer sphere, the surface normal is  
         rec.normal = normalize(rec.p – C);  
     – If from the inner sphere, the normal points into the cavity:  
         rec.normal = normalize(C – rec.p);  

5. Edge Cases  
   • Rays that originate inside the hollow cavity (||O–C|| < R_in) should still detect the inner‐sphere surface.  
   • Rays that start inside the shell (R_in ≤ ||O–C|| ≤ R_out) should detect whichever surface the ray exits first.  
   • If R_in = 0, the shape degenerates to a solid sphere; your code should still work.

Deliverables  
• The complete implementation of intersectHollowSphere(…)  
• A brief explanation (comments or separate write-up) of how you:  
   – Solved the quadratic for both spheres  
   – Filtered and merged candidate intersections  
   – Chose and oriented normals correctly  

Optional Extension  
• Compute UV coordinates on each surface if you wish to texture–map the shell.

############### 10.3 ###############
Ray–Sphere-With-Hole Intersection Exercise

In this problem you will extend your ray‐sphere intersection code to handle a “sphere with a spherical cavity.”  The object is defined as a solid outer sphere with a smaller inner sphere removed (Boolean difference).  Your task is to detect ray hits on this shape, report the closest valid intersection in a given [tMin, tMax] range, and compute the correct surface normal (pointing against the incoming ray).

Object specification  
1. Outer sphere S₁: center C₁ = (0, 0, 0), radius R₁ = 2.0  
2. Inner (cavity) sphere S₂: center C₂ = (0.5, 0, 0), radius R₂ = 1.0  
3. The final solid is S = S₁ \ S₂ (“outer minus inner”).  You may assume S₂ lies entirely inside S₁.

A. Analytical Intersection (write‐up)  
1. Write down the ray parameterization:  
   P(t) = O + t·D  
   where O is the ray origin, D is a unit direction vector, and t ≥ 0.  
2. For a sphere of center C and radius R, the intersection condition is  
   ‖P(t) – C‖² = R².  
   Show how this leads to a quadratic equation at² + bt + c = 0, and give expressions for a, b, c in terms of O, D, and C.  
3. Explain how you compute discriminant, then the two real roots t₁ ≤ t₂ (if they exist).

B. Programming Task  
Extend your existing “hit‐sphere” routine to handle the solid S = S₁ \ S₂.  You must:  
 • Find all real intersection t’s of the ray with S₁ and with S₂.  
 • From these, determine the closest t in [tMin, tMax] where the ray actually enters or exits the final solid S.  
 • Compute the surface normal at the hit point:  
   – If the hit is on S₁, the outward normal is (P – C₁)/R₁.  
   – If the hit is on S₂, the cavity surface normal should point inward into the solid, i.e. n = –(P – C₂)/R₂.  
 • Ensure the normal is oriented so that n·D < 0 (i.e. always “front‐face” normal).  

You may assume you already have a helper:  
```
bool intersectSphere(const Ray& r,
                     const Vec3& center,
                     float radius,
                     float tMin,
                     float tMax,
                     HitRecord& rec);
```
which finds the nearest hit in [tMin, tMax] on one sphere and fills rec.t, rec.p (hit point), rec.normal (outward normal), and rec.frontFace (boolean).

Now write:

```
bool intersectSphereWithHole(const Ray& r,
                             float tMin,
                             float tMax,
                             HitRecord& rec) 
{
    // 1) Find both intersections with outer sphere S₁.
    // 2) Find both intersections with inner sphere S₂.
    // 3) From all t’s, choose the smallest t in [tMin,tMax]
    //    where the ray is inside S₁ but outside S₂.
    // 4) Compute rec.p, rec.normal (flip for cavity), rec.frontFace.
}
```

Be careful to:
 • Reject intersection points that lie inside the cavity (i.e. where the surface would belong to S₂ but the ray is outside S₁).  
 • Handle the case when the ray starts inside S₁ (but outside S₂) so that the first valid t is an exit point.  
 • Not confuse the inner and outer surfaces when selecting the nearest valid t.

C. Test Cases  
1. Ray from O = (–5,0,0) with D = (1,0,0).  
   – It enters S₁ at t = 3, then potentially enters the cavity at t ≈ 4.5, then exits cavity at t ≈ 5.5, and finally exits S₁ at t = 7.  
   – Your code should report the hit at t=3 on the outer surface.  
2. Ray from O = (0.5, 0, 0) (inside the cavity) with D = (1, 0, 0).  
   – It immediately hits the inner sphere at t = R₂ = 1.0.  Normal should point inward into the shell.  
3. Ray grazing both spheres or missing entirely.  Verify your function returns false.

Deliverables  
1. A short derivation for part A.  
2. Completed code for intersectSphereWithHole that compiles and passes the above tests.  
3. A brief explanation (2–3 sentences) of how you pick the correct t when both spheres produce intersections.

############### 10.4 ###############
Ray‐Object Intersection Exercise: “Sphere with Spherical Cavity”

Background  
We want to render a “solid” sphere of radius Rbig from which a smaller sphere of radius Rsmall has been hollowed out.  In CSG terms, our object is  
  O = SphereBig \ SphereSmall  
where  
 • SphereBig has center Cbig and radius Rbig,  
 • SphereSmall has center Csmall and radius Rsmall,  
and SphereSmall is completely contained inside SphereBig (so the cavity does not poke outside).

Your task is to implement a ray‐object intersection routine that returns the closest visible hit with this hollowed‐out sphere, and computes the correct surface normal there.

Problem Statement  
Write a function  

    bool intersectSphereWithHole(  
        const Ray&     ray,        // ray.origin, ray.direction (normalized)  
        const Vec3&    Cbig,       // center of the big sphere  
        float          Rbig,       // radius of the big sphere  
        const Vec3&    Csmall,     // center of the small (cavity) sphere  
        float          Rsmall,     // radius of the small sphere  
        HitInfo&       hit         // (out) stores t, hit point p, normal n  
    );

that returns true if the ray hits the solid region (big sphere minus small sphere), and fills hit as follows:

  • hit.t        = the smallest positive t along the ray where it first exits the ray origin and reaches the object’s surface  
  • hit.p        = ray.origin + hit.t * ray.direction  
  • hit.normal   = unit outward normal of the surface at p  

Notes on Normals  
  – On the exterior of the big sphere, the normal is  
         n = (p – Cbig) / Rbig  
  – On the interior surface (the cavity), the normal must point **into** the material.  Since we’ve removed the small sphere from the big one, its “visible” interior surface is the inverse of the small sphere’s outward normal:  
         n = – (p – Csmall) / Rsmall  

Implementation Guidance  
1. Ray‐Sphere Intersection  
   For each sphere (Ci, Ri), substitute p = ray.origin + t·ray.direction into  
       ‖p – Ci‖² = Ri²  
   to obtain a quadratic in t:  
       a t² + b t + c = 0  
   with  
       a = dot(d, d)  
       b = 2·dot(d, o – Ci)  
       c = dot(o – Ci, o – Ci) – Ri²  
   Solve for t (only real roots, t > 0), yielding up to two hits per sphere.

2. Collect Candidate Hits  
   – Compute the positive roots {t1b, t2b} for the big sphere.  If none, the ray misses entirely.  
   – Compute the positive roots {t1s, t2s} for the small sphere.  (May be empty if the ray does not enter the cavity.)

3. Determine the Closest Valid Hit  
   Let all positive hits be in a list L = { (t, sphere‐ID) … }.  Sort L by t increasing.  
   Walk through L in ascending t, and for each candidate do:
     a) If sphere‐ID == Big:  
        – this point is on the exterior of the big sphere  
        – accept it immediately (it cannot lie in the removed region)  
     b) If sphere‐ID == Small:  
        – this point lies on the small sphere’s surface:  
          • if the ray is currently inside the big sphere (i.e. we have not yet exited big),  
            then we are hitting the cavity wall from inside the material ⇒ accept it.  
          • otherwise (we are outside big), ignore this root.  

   The first accepted candidate gives hit.t.  Compute hit.p and hit.normal accordingly.

4. Edge Cases  
   – If the ray origin is inside the cavity (inside the small sphere), the first valid hit will be with the interior surface of the small sphere.  
   – If the ray just grazes (discriminant = 0), treat it as no hit or very far hit—your choice, but document it.

Deliverables  
  1) Your full source code for intersectSphereWithHole, including the quadratic solver and hit selection logic.  
  2) A short explanation (1–2 paragraphs) of how you handle the normal orientation on both surfaces.  
  3) A diagram or list of test rays (origin + direction) that exercise each case:
     • Miss both spheres  
     • Hit only big sphere (never reaches cavity)  
     • Hit big sphere then cavity wall  
     • Origin inside big but outside small  
     • Origin inside small  

Grading Criteria  
  – Correctness of intersection test (t values, root selection)  
  – Correct selection between big‐sphere and small‐sphere hits  
  – Proper normal direction on both exterior and interior surfaces  
  – Code clarity and documentation of edge cases

############### 10.5 ###############
Programming Exercise: Ray–Sphere-with-Spherical-Hole Intersection

Goal  
Implement a ray–object intersection routine for a “sphere with a spherical hole”: the solid region inside a larger (outer) sphere minus the volume of a smaller (inner) sphere completely contained within it.

Object Specification  
— Outer sphere S₁  
 • Center C₁ = (0, 0, 0)  
 • Radius R₁ = 1.0  

— Inner (hole) sphere S₂  
 • Center C₂ = (0.5, 0.0, 0.0)  (guaranteed: |C₂−C₁| + R₂ ≤ R₁)  
 • Radius R₂ = 0.3  

The final object is CSG difference:  S = S₁ \ S₂.

Ray and HitRecord Definitions (in C++‐style pseudocode)  
```cpp
struct Ray {
    Vec3  origin;
    Vec3  direction;    // assumed normalized
};

struct HitRecord {
    Vec3   p;           // hit point
    Vec3   normal;      // surface normal (unit)
    float  t;           // ray parameter at hit
    bool   front_face;  // true if ray hits front face
};

// Helper: face normal orientation
inline void set_face_normal(const Ray& r, const Vec3& outward, HitRecord& rec) {
    rec.front_face = dot(r.direction, outward) < 0;
    rec.normal     = rec.front_face ? outward : -outward;
}
```

Your Task  
Write a function with this signature:

```cpp
bool intersect_sphere_with_hole(
    const Ray&       ray,
    float            t_min,
    float            t_max,
    HitRecord&       rec
);
```

that returns true if and only if the ray intersects the surface of the object S at some t in [t_min, t_max]. If true, the function must update `rec` with:
- rec.t       = the smallest valid t > 0,
- rec.p       = ray.origin + rec.t * ray.direction,
- rec.normal  = correctly oriented unit normal,
- rec.front_face.

Requirements / Hints

1. Solve the quadratic for each sphere:
   For a sphere centered at C with radius R, solve  
     dot(D, D) t² + 2·dot(OC, D) t + dot(OC, OC) − R² = 0  
   where OC = ray.origin − C, D = ray.direction.

2. For each sphere, collect its two real roots (if any): t₁ < t₂.

3. Determine the set of t-intervals where the ray is inside each sphere:
   — For S₁: inside between [t₁_outer, t₂_outer].  
   — For S₂: inside between [t₁_inner, t₂_inner].

4. The object S = inside(S₁) AND NOT inside(S₂).  
   On the ray this means:
   — Enter S at the smallest t where you enter S₁ but are not already inside S₂.  
   — Exit S at the next t where you either exit S₁ or re-enter S₂.

5. Among all entrance ts within [t_min, t_max], pick the smallest.  
   You only need to report the first hit point.

6. Surface normals:
   — If the hit is on S₁’s surface, outward normal = (p − C₁) / R₁.  
   — If on S₂’s surface, outward normal = −(p − C₂) / R₂  (it points into the cavity).

7. Use `set_face_normal(ray, outward, rec)` to fill `rec.normal` and `rec.front_face`.

What to Submit  
1. Your complete implementation of `intersect_sphere_with_hole`.  
2. A brief explanation (1–2 paragraphs) of how you combine the intervals to find the first valid intersection.  
3. One or two sample rays (origin & direction) with expected outcomes:  
   — Ray hits outer surface first  
   — Ray goes through the hole: hits inner surface  

Evaluation Criteria  
— Correctness of the quadratic solves  
— Accurate interval arithmetic for CSG difference  
— Proper normal orientation  
— Robust handling of numerical edge cases (e.g. tangent rays)

############### 10.6 ###############
Ray–Object Intersection: “Sphere with Spherical Hole” 

Objective  
--------  
Write a function that computes the first (nearest) intersection of a ray with a solid defined by an outer sphere _minus_ an inner (carved‐out) sphere.  Your function should return (1) the parameter t of the hit along the ray, (2) the hit point, and (3) a correctly oriented surface normal.

Object description  
------------------  
Let the object O be the set of points p in ℝ³ satisfying  
  |p – C₀| ≤ R₀ and |p – C₁| ≥ R₁  
where  
 • Outer sphere center C₀ = (0, 0, 0), radius R₀ = 3.0  
 • Inner (hole) sphere center C₁ = (1, 0, 0), radius R₁ = 1.0  
Note that the inner sphere lies wholly inside the outer sphere, carving out a hollow “bite” from it.

Ray description  
---------------  
A ray is given by  
 r(t) = O + t D, t ≥ 0  
with O = ray origin, D = normalized direction.

Required function signature (in C++‐style pseudocode)  
------------------------------------------------------  
bool intersectSphereWithHole(  
 const Ray& ray,  
 float& tHit,                 // returned parameter along the ray  
 Vec3& hitPoint,              // returned intersection point  
 Vec3& hitNormal              // returned unit normal at hitPoint  
);

Steps to follow  
---------------  
1. Solve the quadratic for the ray vs. outer sphere (C₀, R₀).  
   Quadratic coefficients:  
     a = dot(D, D)  (assume normalized so a=1)  
     b = 2·dot(D, O–C₀)  
     c = dot(O–C₀, O–C₀) – R₀²  
   Compute discriminant Δ₀ = b² – 4ac.  
   • If Δ₀ < 0 ⇒ no intersection with the outer sphere ⇒ return false.  
   • Else compute t₀₁ ≤ t₀₂ = the two roots.

2. Solve the quadratic for the ray vs. inner sphere (C₁, R₁), giving roots t₁₁ ≤ t₁₂ (if Δ₁ ≥ 0).

3. Determine the intervals along the ray occupied by the outer shell:  
   I_outer = [t₀₁, t₀₂] ∩ [0, ∞)  
   I_inner = [t₁₁, t₁₂] ∩ [0, ∞)  (empty if no real roots or both negative)

4. Subtract the inner‐sphere interval from the outer‐sphere interval:  
   Let the “visible” intervals be the parts of I_outer that are not inside I_inner.  
   There are up to two resulting sub‐intervals:  
     A = [t₀₁, min(t₀₂, t₁₁)]  
     B = [max(t₀₁, t₁₂), t₀₂]  
   Discard any sub‐interval whose lower bound ≥ its upper bound or whose upper bound ≤ 0.

5. Pick the smallest t > ε (e.g. 1e–4) among the endpoints of A and B.  
   If none exists ⇒ return false.  
   Otherwise that's tHit.

6. Compute hitPoint = O + tHit D.

7. Determine which surface was hit:  
   • If tHit is in [t₀₁, t₀₂] but outside [t₁₁, t₁₂], and lies in A or B as defined above with tHit near t₀₁ or t₀₂ ⇒ you hit the outer sphere.  
     normal = normalize(hitPoint – C₀)  
   • Otherwise you hit the inner‐sphere cavity surface (i.e. tHit near t₁₁ or t₁₂):  
     normal = –normalize(hitPoint – C₁)  
     (the minus‐sign flips the normal to point into the solid region, not into the hole)

8. Return true.

Extra credit  
------------  
• Handle floating‐point robustness (e.g. bias ε, choosing correct root ordering).  
• Set a “frontFace” flag by checking whether dot(D, normal) < 0.  
• Generalize your code to arbitrary centers C₀, C₁ and radii R₀, R₁.

What to submit  
---------------  
• Well‐commented C++ (or pseudocode) implementing intersectSphereWithHole(…).  
• A brief explanation of your interval‐subtraction logic.  
• A few test rays (origin + direction) and their expected tHit, hitPoint, and hitNormal.

############### 10.7 ###############
Ray‐Object Intersection: Sphere with a Spherical Hole

In this exercise you will implement a ray‐intersection routine for an object O defined as “a solid sphere with a smaller spherical cavity carved out of it.”  Mathematically,

    S_out  = { p ∣ |p – C_out| ≤ R_out }  
    S_in   = { p ∣ |p – C_in| ≤ R_in }  
    O      = S_out ∖ S_in  = { p ∣ |p – C_out| ≤ R_out and |p – C_in| ≥ R_in }

Concrete parameters (fixed for this problem):  
    C_out = (0, 0, 0),  R_out = 1.0  
    C_in  = (0.5, 0, 0), R_in  = 0.3  

A ray is given by  
    R(t) = O + t D,  t ≥ 0,  with D normalized.

Your task is to write a function

  bool intersect_sphere_with_hole(  
     Vector3 rayOrigin,  
     Vector3 rayDir,          // assumed normalized  
     float &out_t,            // distance along the ray  
     Vector3 &outNormal       // surface normal at the hit  
  );

which returns true if the ray hits O, and false otherwise.  If it hits, store in out_t the smallest non‐negative t of intersection and in outNormal the unit surface normal at the hit point.

------------------------------------------------------------------------
PART A: DERIVE AND IMPLEMENT INTERSECTION

1. Compute intersections with the outer sphere S_out.  
   Solve ‖(O + t D) – C_out‖^2 = R_out^2.  
   That is, let L_out = O – C_out, then  
     a = D·D = 1  
     b = 2 (D·L_out)  
     c = L_out·L_out – R_out^2  
   Solve a t^2 + b t + c = 0 to get two real roots t0_out ≤ t1_out (or none).

2. Compute intersections with the inner sphere S_in similarly:  
   L_in = O – C_in  
     a = 1  
     b = 2 (D·L_in)  
     c = L_in·L_in – R_in^2  
   Solve for t0_in ≤ t1_in.

3. The ray‐interval inside the solid outer sphere is [t0_out, t1_out].  
   The ray‐interval inside the (forbidden) inner sphere is (t0_in, t1_in).  

   We want the set difference  
     I = [t0_out, t1_out] \ (t0_in, t1_in),  
   i.e. up to two disjoint intervals:  
     I1 = [t0_out, min(t1_out, t0_in)]  
     I2 = [max(t0_out, t1_in), t1_out]  (only if t1_in < t1_out)

4. Among all intervals in I, pick the smallest t ≥ 0.  That is:  
   – If t0_out ≥ 0 and t0_out < t0_in, let t_hit = t0_out (outer surface).  
   – Else if t1_in ≥ 0 and t1_in < t1_out, let t_hit = t1_in (inner‐cavity surface).  
   – Otherwise there is no valid hit.

5. Record which surface you hit:
   – If t_hit came from the outer‐sphere interval, mark ‘outer’.  
   – If it came from the post‐hole interval (i.e. t_hit = t1_in), mark ‘inner’.

------------------------------------------------------------------------
PART B: SURFACE NORMAL

Once you have t_hit, compute the hit point P = O + t_hit D and then

  if (surface == outer)  
    outNormal = normalize(P – C_out);

  else  // inner‐cavity surface  
    outNormal = –normalize(P – C_in);  
  // the minus‐sign flips the normal so it points “into” the carved cavity

------------------------------------------------------------------------
PART C: PSEUDOCODE SKETCH

function intersect_sphere_with_hole(O, D, &t_out, &N_out):
  // 1) outer sphere
  L_out = O – C_out
  b_out = 2 * dot(D, L_out)
  c_out = dot(L_out, L_out) – R_out^2
  roots_out = solveQuadratic(1, b_out, c_out)
  if roots_out is empty:
    return false
  t0_out, t1_out = sort(roots_out)

  // 2) inner sphere
  L_in = O – C_in
  b_in = 2 * dot(D, L_in)
  c_in = dot(L_in, L_in) – R_in^2
  roots_in = solveQuadratic(1, b_in, c_in)
  if roots_in empty:
    // no hole → whole solid sphere
    return intersect_solid_sphere_only(O, D, t_out, N_out)
  t0_in, t1_in = sort(roots_in)

  // 3) build intervals
  // [t0_out, t1_out] minus (t0_in, t1_in)
  // interval A: [tA0, tA1] = [t0_out, min(t1_out, t0_in)]
  tA0 = t0_out; tA1 = min(t1_out, t0_in)
  // interval B: [tB0, tB1] = [max(t0_out, t1_in), t1_out]
  tB0 = max(t0_out, t1_in); tB1 = t1_out

  // 4) pick smallest non‐negative t
  candidate_t = +∞
  hitSurface = NONE

  if tA0 ≥ 0 and tA0 ≤ tA1:
    candidate_t = tA0
    hitSurface = OUTER
  elseif tB0 ≥ 0 and tB0 ≤ tB1:
    candidate_t = tB0
    hitSurface = INNER

  if hitSurface == NONE:
    return false

  // 5) compute normal
  P = O + candidate_t * D
  if hitSurface == OUTER:
    N = normalize(P – C_out)
  else:
    N = –normalize(P – C_in)

  t_out = candidate_t
  N_out = N
  return true

------------------------------------------------------------------------
PART D: TEST CASES

Use these rays to verify correctness (all directions are normalized):

1) Ray origin = (–2, 0, 0), dir = (1, 0, 0)  
   • Should hit the outer surface first at t ≃ 1.0, normal = (–1, 0, 0).

2) Ray origin = (–2, 0, 0), dir = (1, 0.1, 0) normalized  
   • Might clip the hole or miss it—compute both intersections.

3) Ray origin = (0.5, 0, –2), dir = (0, 0, 1)  
   • Passes through the hole:  
     – Enters outer at t ≃ 1.0, exits into cavity at t_in ≃ 2.7  
     – No further hit, since after the cavity it’s still inside outer → next hit at t ≃ 2.3?  
     Check carefully your interval arithmetic.

4) Ray origin = (0.5, 0, 0), dir = (1, 0, 0)  
   • Starts inside the inner sphere → the first positive intersection is at t = t1_in  
     and the normal should point backward into the cavity.

------------------------------------------------------------------------
Deliverables:

- Your intersect_sphere_with_hole(…) implementation in C++ or pseudocode  
- A brief derivation of your interval‐arithmetic logic  
- Outputs (t, normal) for the four test rays above, with explanations  

This question tests your understanding of:  
  • Quadratic solution for ray–sphere intersection  
  • Boolean combinations of solid primitives via interval arithmetic  
  • Surface‐normal conventions on “hole” boundaries

############### 10.8 ###############
Ray‐Object Intersection Exercise: “Sphere with a Spherical Hole”  
-----------------------------------------------------------------  

Problem Statement  
-----------------  
We define a 3D solid S as the set‐difference of two spheres: the outer sphere Sₒ minus an inner (cavity) sphere Sᵢ.  A ray r(t) = O + t·D (t ≥ 0) should be tested against the boundary of S (i.e. the two spherical surfaces).  

Geometry specifications  
-----------------------  
• Outer sphere Sₒ  
  – Center Cₒ = (0, 0, 0)  
  – Radius Rₒ = 2.0  

• Inner (hole) sphere Sᵢ  
  – Center Cᵢ = (0, 0, 0.75)  
  – Radius Rᵢ = 0.5  

• Solid S = { x ∈ ℝ³ ∣ ‖x – Cₒ‖ ≤ Rₒ and ‖x – Cᵢ‖ ≥ Rᵢ }  

Your task is to implement in C++ (or detailed pseudocode) a function:  
bool intersectSphereWithHole(  
    const Ray& r,           // ray origin O, unit direction D  
    float t_min,            // minimum valid t (e.g. 0.001f)  
    float t_max,            // maximum valid t (e.g. +∞)  
    HitRecord& rec          // output record: t, point p, normal n, front_face  
);  

This function must return true if r intersects the boundary of S at some t ∈ [t_min, t_max], filling rec with:  
  • rec.t        – the nearest intersection t  
  • rec.p        – the hit point p = r(t)  
  • rec.normal   – unit normal pointing “outward” from S (see below)  
  • rec.front_face – whether the ray hits from outside  

Boundary surfaces and normals  
-----------------------------  
1. Outer surface (sphere Sₒ):  
   – Equation: ‖x – Cₒ‖ = Rₒ  
   – Outward normal at p: n =  (p – Cₒ) / Rₒ  

2. Inner surface (sphere Sᵢ):  
   – Equation: ‖x – Cᵢ‖ = Rᵢ  
   – Outward normal (i.e. pointing into the cavity) at p: n = (Cᵢ – p) / Rᵢ  

Step‐by‐step requirements  
--------------------------  
1. Ray–Sphere Intersection Derivation  
   a. For a sphere center C and radius R, derive the quadratic in t:  
      a = D·D  
      b = 2·(O – C)·D  
      c = (O – C)·(O – C) – R²  
      discriminant Δ = b² – 4ac  
   b. Show how to pick the two roots t₁, t₂ (if Δ ≥ 0), sorted so t₁ ≤ t₂.  

2. Helper Function  
   Implement:  
     bool intersectSingleSphere(  
       const Ray& r, const Vec3& C, float R,  
       float t_min, float t_max, float& t_hit  
     );  
   – Returns true if there is some root t ∈ [t_min, t_max], setting t_hit to the smaller valid root.  

3. Compute All Candidate Intersections  
   – Call intersectSingleSphere(r, Cₒ, Rₒ, t_min, t_max, tₒ₁) to get the first hit tₒ₁, and also compute tₒ₂ (the second root).  
   – Call intersectSingleSphere(r, Cᵢ, Rᵢ, t_min, t_max, tᵢ₁) to get tᵢ₁, plus tᵢ₂.  

4. Determine Valid Hit on S  
   The ray is inside Sₒ between tₒ₁ and tₒ₂.  It is inside Sᵢ between tᵢ₁ and tᵢ₂.  The solid S = Sₒ ∖ Sᵢ, so valid t‐intervals are:  
     [tₒ₁, tₒ₂] minus [tᵢ₁, tᵢ₂].  
   You must pick the smallest t ≥ t_min where the ray crosses into or out of S and t ≤ t_max.  

5. Record Hit Details  
   – rec.t = chosen t_hit  
   – rec.p = O + t_hit·D  
   – If t_hit lies on the outer sphere surface,  
       rec.normal = (rec.p – Cₒ)/Rₒ  
     else (inner surface),  
       rec.normal = (Cᵢ – rec.p)/Rᵢ  
   – Set rec.front_face so that rec.normal always opposes D.  

6. Edge Cases & Testing  
   • Ray origin inside the cavity but inside Sₒ  
   • Ray misses the outer sphere entirely  
   • Ray goes through the hole without hitting the outer boundary  
   • Ray grazes exactly at tₒ₁ = tᵢ₁  

Submission  
----------  
Provide:  
1. Your algebraic derivation for the quadratic and root selection.  
2. The full C++ (or pseudocode) for intersectSingleSphere and intersectSphereWithHole.  
3. A few test‐ray examples (origin, direction) and the expected rec.t, rec.p, rec.normal.  

Make sure all variable names are used consistently and that your logic handles every intersection case unambiguously.

############### 10.9 ###############
Ray‐Sphere‐With‐Hole Intersection 

Problem Statement  
We wish to render a “hollow” sphere: an outer sphere of radius R from which a smaller concentric sphere of radius r (r < R) has been removed.  Equivalently, the solid region is  
 { P ∈ ℝ³ | r ≤ |P–C| ≤ R }  
where C is the common center.

Your task is to write a function  

  bool intersectHollowSphere(  
    const Ray&      ray,     // ray.o = origin, ray.d = (unit) direction  
    float           t_min,   // minimum acceptable t  
    float           t_max,   // maximum acceptable t  
    const Vec3&     C,       // center of both spheres  
    float           R,       // outer radius  
    float           r,       // inner radius (hole)  
    HitRecord&      rec      // output hit information  
  );  

that returns true if the ray hits the hollow sphere for some t in (t_min, t_max), storing in rec:  
  • rec.t = solid‐geometry intersection distance  
  • rec.p = ray.o + rec.t * ray.d  
  • rec.n = outward‐facing normal at rec.p  

If the first intersection lies on the outer surface (|P–C|=R), n = (P–C)/R.  
If it lies on the inner surface (|P–C|=r), n = –(P–C)/r (points into the removed volume).

Hints / Algorithm Sketch  
1. Solve quadratic to get the two (real) intersection values t_out0 ≤ t_out1 with the outer sphere:  
     a = dot(d,d),  b = 2·dot(oc,d),  c = dot(oc,oc) – R²,  where oc = ray.o – C.  
2. Likewise solve for t_in0 ≤ t_in1 with the inner sphere (radius = r).  
3. Define intervals along the ray:  
     I_out = [t_out0, t_out1],   I_in = [t_in0, t_in1].  
4. The hollow‐sphere intersections occur in the set difference:  
     I_hollow = I_out \ I_in.  
5. Among all t ∈ I_hollow ∩ (t_min, t_max), choose the smallest.  
6. Determine whether that t comes from the outer or inner surface and set rec.n accordingly.

Function Signature & Data Structures (C++-style pseudocode)  
```cpp
struct Vec3 {
  float x,y,z;
  Vec3 operator-(const Vec3& v) const;
  Vec3 operator*(float s) const;
  // dot, length, normalized, etc.
};

struct Ray {
  Vec3 o;    // origin
  Vec3 d;    // normalized direction
};

struct HitRecord {
  float t;
  Vec3  p;
  Vec3  n;
};
```

Example Test Cases  
1) Ray from outside, striking the outer shell first  
   C = (0,0,0), R = 3.0, r = 1.5  
   ray.o = (5, 0, 0),  ray.d = normalize(–1,0,0)  
   ⇒ expected hit at t = 2.0,  p = (3,0,0),  n = (1,0,0)  

2) Ray passing through before it enters the hole  
   C = (0,0,0), R = 3.0, r = 1.5  
   ray.o = (2.5, 0, 0), ray.d = normalize(+1,0,0)  
   • This ray starts in the shell (r < |o–C| < R), marches outward:  
     first intersection with outer sphere at t = 0.5  
   ⇒ expected hit at t = 0.5,  p = (3.0, 0,0), n = (1,0,0)  

3) Ray that misses entirely  
   C = (0,0,0), R = 3.0, r = 1.5  
   ray.o = (0, 4, 0), ray.d = normalize(1, 0, 0)  
   ⇒ no intersection, return false  

Submission  
Provide a clear, well‐commented implementation of intersectHollowSphere(…), including:  
 • robust quadratic solver (handle discriminant < 0)  
 • correct interval arithmetic for I_out \ I_in  
 • correct outward normals on both surfaces  
 • respect the [t_min, t_max] bounds.

############### 11.0 ###############
Ray‐Object Intersection: Sphere with Cylindrical Hole
----------------------------------------------------

In this exercise you will implement ray‐object intersection for a sphere from which an infinite cylindrical hole has been “drilled.”  The final shape is the CSG difference

  Object = Sphere – Cylinder

where  
  • Sphere S = { p | ‖p‖² ≤ Rₛ² }, centered at the origin, radius Rₛ  
  • Cylinder C = { p | x² + y² ≤ R_c² }, an infinite cylinder of radius R_c (R_c < Rₛ) whose axis is the z-axis.

Your task is to write a function that, given a ray  
  R(t) = O + t D, t ≥ 0, ‖D‖=1  
computes the closest intersection (smallest t>0) between R and (S minus C).  If there is no hit, the function should indicate “no intersection.”  If there is a hit, it should also return the surface normal at the point of intersection.

Requirements
------------

1.  Ray–Sphere Intersection  
    a.  Derive the quadratic in t for intersecting R(t) with S.  
    b.  Find its real roots tₛ₁ ≤ tₛ₂ (if any).  These define the entry/exit points of the ray through the sphere.

2.  Ray–Cylinder Intersection  
    a.  Because the cylinder is infinite along z, the intersection depends only on x and y.  Derive the quadratic in t for x(t)² + y(t)² = R_c².  
    b.  Find its real roots t_c₁ ≤ t_c₂ (if any).  These define where the ray enters/exits the cylinder volume.

3.  CSG Difference (Sphere minus Cylinder)  
    a.  The ray’s “inside‐sphere” interval is [tₛ₁, tₛ₂].  
    b.  The ray’s “inside‐cylinder” interval is [t_c₁, t_c₂].  
    c.  The ray hits the final object where it lies in the sphere‐interval but *not* in the cylinder‐interval.  
    d.  Compute the one or two sub‐intervals of [tₛ₁, tₛ₂] that remain after removing [t_c₁, t_c₂].  
    e.  Choose the smallest t>0 in those remaining intervals as the hit point (if any).

4.  Surface Normal  
    At the intersection t_hit, compute the point  
  P = O + t_hit D.  
    Then the normal N is determined by which surface was hit:  
    • If P lies on the sphere portion (i.e. t_hit comes from [tₛ₁, tₛ₂] but not in [t_c₁, t_c₂]), then  
  N = normalize(P)  
    • If P lies on the cylindrical hole’s side wall (i.e. t_hit ∈ [t_c₁, t_c₂] ∩ [tₛ₁, tₛ₂]), then  
  N = normalize(vec(P.x, P.y, 0))  
    (pointing outward from the cylinder axis).

5.  Implementation  
    • Write your solution in a language of your choice (C++, Java, Python, etc.).  
    • Clearly handle cases with no real roots or intervals that do not overlap.  
    • Assume the ray direction D is normalized.  
    • Return (t_hit, N) if there is an intersection, or “no hit” otherwise.

6.  Test Cases  
    After you implement your function, verify it with at least these rays (using Rₛ = 1.0, R_c = 0.5):

    • Ray A: O = (2, 0, 0), D = (–1, 0, 0)  
      – Expected: enters the sphere at x=1.0, exits at x=–1.0, but the cylinder hole also extends from x=0.5 to x=–0.5.  
      – Thus the first visible hit is at x=1.0 on the sphere.  

    • Ray B: O = (0.3, 0, 2), D = (0, 0, –1)  
      – This ray passes through the north pole of the sphere but goes through the cylindrical hole first.  
      – It should *not* report a hit on the sphere surface but instead hit the cylinder wall at radius 0.5 in the xy‐plane.  

    • Ray C: O = (0, 0.6, 0), D = (1, 0, 0)  
      – Origin is inside the cylinder but inside the sphere.  The ray should exit the cylinder wall at y=±0.5 (no surface there, because that face was drilled out), then exit the sphere at x=√(1–0.6²) ≈ 0.8.  

Deliverables
------------

  1. Source code implementing the intersection function.  
  2. A brief write‐up showing your derivations for the quadratics and how you compute the CSG difference.  
  3. Results (t_hit and N) for the three test rays, with a short explanation of each.

############### 11.1 ###############
Ray–Object Intersection Exercise: Sphere with Cylindrical Hole

Description  
We define the solid S ⊂ ℝ³ by  
   S = { p ∣ ‖p‖ ≤ 1.0  AND  p.x² + p.z² ≥ (0.5)² }  
In other words, start with a unit sphere centered at the origin and remove (drill) an infinite cylindrical hole of radius 0.5 aligned with the y-axis.  

Your task is to write a function  

   bool intersect_sphere_with_cyl_hole(  
       const Ray& ray,         // ray.o = origin, ray.d = (normalized) direction  
       float&   t_hit,         // output: smallest positive t  
       Vec3&    n_hit          // output: surface normal at hit point  
   );

that returns true if the ray r(t) = ray.o + t·ray.d (t ≥ 0) intersects the boundary of S. If so, it fills t_hit with the smallest t > ε (e.g. ε=1e-4) and n_hit with the outward surface normal at the hit point. If the ray misses S entirely, return false.

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––  
Step 1: Ray–Sphere Intersection  
Solve for t in  
   ‖o + t d‖² = 1²  
i.e.  
   (d·d) t² + 2(o·d) t + (o·o − 1) = 0.  
Compute its real roots t_s[0], t_s[1], discard any ≤ ε, then let t_s_min = min(remaining).

Step 2: Ray–Cylinder Intersection  
The cylinder’s equation is x²+z² = 0.5² (infinite in y). Solve  
   (d.x² + d.z²) t² + 2(o.x d.x + o.z d.z) t + (o.x² + o.z² − 0.25) = 0.  
Compute its real roots t_c[0], t_c[1], discard any ≤ ε, let t_c_min = min(remaining).

Step 3: Filter Candidates  
You now have up to two candidates: t_s_min and t_c_min. For each candidate t, compute p = o + t d and test whether p actually lies on the boundary of S:

  • If t = t_s_min (sphere candidate), check  
       p.x² + p.z² ≥ 0.25 − ε.  
    If true, that hit lies on the exposed sphere surface.

  • If t = t_c_min (cylinder candidate), check  
       ‖p‖ = √(p.x²+p.y²+p.z²) ≤ 1.0 + ε.  
    If true, that hit lies on the interior cylinder wall.

Discard any candidate that fails its test.  

Step 4: Choose Smallest t  
If neither candidate survives, return false. Otherwise pick the smaller of the surviving t’s; set t_hit to that value.

Step 5: Compute Surface Normal  
Let p_hit = o + t_hit d.  
  • If t_hit came from the sphere:  
       n_hit = normalize(p_hit).  
  • If t_hit came from the cylinder:  
       // normals must point “out” of the solid into the drilled hole  
       n_hit = normalize(‐Vec3(p_hit.x, 0, p_hit.z)).  

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––  
Testing Your Implementation  
1) Ray o=(0, 2, 0), d=(0,−1,0): enters top of sphere, should hit the sphere surface (no cylinder).  
2) Ray o=(0.6, 0, −2), d=(0,0,1): x=0.6>0.5→misses hole, hits outer sphere.  
3) Ray o=(0, 0, −2), d=(0,0,1): passes through cylinder axis → no intersection (hole is infinite).  

Deliverable  
Submit well-commented C++ (or pseudocode) for intersect_sphere_with_cyl_hole, including  
  • robust quadratic solves  
  • handling of degenerate/parallel‐to‐axis cases  
  • an epsilon for numerical stability.

############### 11.2 ###############
Programming Exercise: Ray-Object Intersection with a Sphere Perforated by a Cylindrical Hole

Objective  
Write a function that computes the first intersection (if any) between a ray and an object defined as a solid sphere of radius R centered at the origin, from which a straight cylindrical hole of radius r (r < R) has been drilled along the z–axis. Your routine must return both the parametric distance t along the ray and the surface normal at the hit point.

Geometry Definition  
1. Sphere:    x² + y² + z² = R².  
2. Cylinder: x² + y² = r², extending through the sphere. The cylinder walls are the only remaining cylindrical surface (no caps), and they exist only where they lie inside the sphere. Equivalently the hole is the set { x² + y² ≤ r², |z| ≤ √(R² – r²) }.  

Thus the final solid is  
    S = { x² + y² + z² ≤ R²  AND  x² + y² ≥ r² }.

Your task is to detect intersections with both components of the boundary:  
  A. The portion of the sphere’s surface with x² + y² ≥ r².  
  B. The cylindrical surface x² + y² = r², with |z| ≤ √(R² – r²).

Function Signature (in C++-style pseudocode)

  struct Ray {
    Vec3 o;      // origin
    Vec3 d;      // direction (normalized)
  };

  struct HitInfo {
    float t;     // ray parameter at intersection
    Vec3 p;      // hit point = o + t*d
    Vec3 n;      // outward surface normal at p
  };

  // Returns true if the ray hits the perforated sphere; fills hit with the closest t > t_min
  bool intersectSphereWithHole(
      const Ray& ray,
      float R,          // sphere radius
      float r,          // cylinder radius, 0 < r < R
      float t_min,      // minimum valid t (e.g. 0.001f)
      float t_max,      // maximum valid t (e.g. +∞)
      HitInfo& hit);

Requirements & Hints

1. Ray–Sphere Intersection  
   Solve for t in  
     dot(d,d) t² + 2·dot(o,d) t + (dot(o,o) – R²) = 0.  
   Let t_sphere be the smaller positive root. For each candidate t_sphere ∈ [t_min, t_max]:
     • Compute p = o + t_sphere·d.  
     • Accept this hit only if p.x² + p.y² ≥ r².  
     • Normal: n = normalize(p).  

2. Ray–Cylinder Intersection  
   Solve for t in  
     (d.x² + d.y²) t² + 2·(o.x·d.x + o.y·d.y) t + (o.x² + o.y² – r²) = 0.  
   Let t_cyl be the smaller positive root. For each candidate t_cyl ∈ [t_min, t_max]:
     • Compute p = o + t_cyl·d.  
     • Accept this hit only if |p.z| ≤ √(R² – r²).  
     • Normal: n = normalize(Vec3(p.x, p.y, 0)).  

3. Choosing the Hit  
   Collect valid sphere and cylinder hits, then choose the one with the smallest t.

4. Edge Cases  
   • If the ray origin starts inside the hole (x² + y² < r² and inside sphere), the first intersection may be with either cylinder wall or sphere interior.  
   • If the ray is parallel to the cylinder axis (d.x = d.y = 0), the cylinder equation degenerates—skip cylinder intersection in that case.  
   • Floating-point robustness: check discriminant ≥ 0 before taking sqrt.

Sample Test Case (for validation)

 Let R = 2, r = 1.  
 1) Ray from o=(0,0,5) toward (0,0,0), d=(0,0,–1).  
    – Should hit the sphere at z = √(R²–0) = +2 at t=3.  
 2) Ray from o=(0.5,0,5) toward (0,0,–1).  
    – First passes through spherical cap (x²+y²=0.25<1 ⇒ inside hole):  
      t to reach z=+√(4–0.25)=+√3≈1.732 is t≈3.268. But at that p, x²+y²<1 so no sphere hit.  
    – Then at z=+√(R²–r²)=√3, the cylinder wall begins:  
      cylinder intersection t_cyl ≈ solve x=0.5+0·t => constant 0.5, y=0 ⇒ no; actually this ray misses the cylinder since x is constant < r.  
    – Finally hits sphere exit at z=–2, t=7. So t≈7, normal=(0.5,0,–2)/norm.  

Deliverables  
 Provide a complete implementation of intersectSphereWithHole() in the language of your choice (C/C++, Java, Python), with clear structure:  
 • Sphere intersection block  
 • Cylinder intersection block  
 • Validity checks on each hit  
 • Selection of nearest t and corresponding normal.

############### 11.3 ###############
Ray-Object Intersection Exercise: Sphere with Cylindrical Hole

Background  
We want to render a “drilled” sphere: a solid sphere of radius R, centered at the origin, with an infinite circular cylinder of radius r < R, drilled straight through along the z-axis.  In other words, the final object is  
   { p=(x,y,z) ∈ ℝ³ | ‖p‖ ≤ R and x² + y² ≥ r² }.  

Your task is to write a ray–intersection routine for this shape.  A ray is given by  
   Ray(t) = O + t D,   t ≥ 0  
where O is the origin point and D is a unit direction vector.

Part A: Intersection Logic (pen & paper / comments)  
1. Sphere Intersection  
   • Solve ‖O + tD‖² = R²  
     ⇒ (D·D) t² + 2(O·D) t + (O·O – R²) = 0  
   • You get two roots t₁ ≤ t₂ (or no real roots if the discriminant < 0).  

2. Cylinder Intersection  
   • Solve x² + y² = r² for Ray(t).  Let O = (Ox,Oy,Oz), D = (Dx,Dy,Dz).  
   • (Ox + tDx)² + (Oy + tDy)² = r²  
     ⇒ (Dx² + Dy²) t² + 2(Ox Dx + Oy Dy) t + (Ox² + Oy² – r²) = 0  
   • Two roots c₁ ≤ c₂ (or none if discriminant < 0).  

3. Combine  
   Along the ray, there will be up to four t’s: sphere entry/exit t₁,t₂ and cylinder entry/exit c₁,c₂.  You must find the smallest t ≥ ε (a small positive bias) for which the point  
      P = O + t D  
   lies inside the sphere (t ∈ [t₁,t₂]) and outside the cylinder (either t < c₁ or t > c₂).  

4. Surface Normal  
   • If the hit is on the sphere surface, N = normalize(P).  
   • If the hit is on the cylinder wall, N = normalize((Px,Py,0)).  

Part B: Implement in C++ (or your language of choice)  
Below is a suggested function signature and helper struct.  Fill in the intersection code, returning true if the ray hits the “sphere-with-hole” and false otherwise.  On hit, you must set the nearest t and the correct surface normal.

```cpp
struct Vec3 {
    float x, y, z;
    Vec3(){} 
    Vec3(float X, float Y, float Z): x(X), y(Y), z(Z){}
    Vec3 operator+(const Vec3& v) const { return Vec3(x+v.x, y+v.y, z+v.z); }
    Vec3 operator-(const Vec3& v) const { return Vec3(x-v.x, y-v.y, z-v.z); }
    Vec3 operator*(float s)       const { return Vec3(x*s, y*s, z*s); }
};

float dot(const Vec3& a, const Vec3& b) {
    return a.x*b.x + a.y*b.y + a.z*b.z;
}

Vec3 normalize(const Vec3& v) {
    float len = sqrt(dot(v,v));
    return Vec3(v.x/len, v.y/len, v.z/len);
}

struct Ray {
    Vec3 O;   // origin
    Vec3 D;   // direction (assumed normalized)
};

// Shape parameters:
const float R = 1.0f;   // sphere radius
const float r = 0.5f;   // cylinder radius
const float EPS = 1e-4f;

// Computes the smallest positive t at which the ray hits the sphere-with-hole.
// On success, returns true and writes:
//   tHit  = parametric distance along the ray
//   N_out = surface normal at the hit point
bool intersectSphereWithCylHole(const Ray& ray, float& tHit, Vec3& N_out) {
    // 1) Solve quadratic for sphere: at² + bt + c = 0
    float a_s = dot(ray.D, ray.D);
    float b_s = 2.0f * dot(ray.O, ray.D);
    float c_s = dot(ray.O, ray.O) - R*R;
    // … compute discriminant, t1_s, t2_s …

    // 2) Solve quadratic for cylinder: a_c t² + b_c t + c_c = 0
    float a_c = ray.D.x*ray.D.x + ray.D.y*ray.D.y;
    float b_c = 2.0f*(ray.O.x*ray.D.x + ray.O.y*ray.D.y);
    float c_c = ray.O.x*ray.O.x + ray.O.y*ray.O.y - r*r;
    // … compute discriminant, t1_c, t2_c …

    // 3) Collect candidate intervals:
    //    Sphere interval: [t1_s, t2_s]
    //    Cylinder interval: [t1_c, t2_c]  (points WITHIN the cylinder)

    // 4) Search for smallest t ≥ EPS in the sphere interval but NOT inside the cylinder:
    //    That is, t in [t1_s, t2_s] ∩ ( (-∞, t1_c] ∪ [t2_c, +∞) ).

    // 5) If found:
    //       P = ray.O + t*ray.D;
    //       if (t is on sphere boundary) N = normalize(P);
    //       else                       N = normalize(Vec3(P.x, P.y, 0));
    //       tHit = t; N_out = N; return true;
    //    Otherwise return false.

    // —— Your code goes here —— //

    return false; // replace with your logic
}
```

Deliverables  
1. The completed code for `intersectSphereWithCylHole`.  
2. A brief explanation (2–3 sentences) of how you choose between sphere vs. cylinder normals.  
3. (Optional) A simple test case: e.g. ray from (0,0,3) toward (0,0,-1) should hit the sphere cap if r<0. support cylinder.  

Grading Criteria  
• Correct quadratic solutions and interval logic.  
• Correct handling of edge cases (ray misses, grazing the hole, starts inside, etc.).  
• Proper normal orientation.  
• Clarity and brevity of your explanation.

############### 11.4 ###############
Ray‐Object Intersection: Sphere with a Cylindrical Hole

In this exercise you will implement a ray–object intersection routine for a “sphere with a cylindrical hole” drilled straight through its center.  Mathematically, the solid is the set
   { p ∈ ℝ³ : ‖p‖ ≤ R_s and x²+z² ≥ R_c² },
i.e. a sphere of radius R_s from which an infinite cylinder of radius R_c (axis along the y-axis) has been subtracted.

1) Object Description
   • Sphere center C = (0,0,0), radius R_s = 1.0  
   • Cylinder axis: the y-axis.  Cylinder radius R_c = 0.5  
   • The final surface consists of  
       a) the outer shell of the sphere wherever x²+z² ≥ R_c²  
       b) the inner cylindrical surface wherever ‖p‖ ≤ R_s  

2) Ray Parameterization
   A ray is given by  
       R(t) = O + t D,   t ≥ 0  
   where O is the ray origin and D is its (normalized) direction vector.

3) Your tasks
   a) Derive the quadratic equation for intersections with the sphere:  
         ‖O + tD‖² = R_s²  
   b) Derive the quadratic for intersections with the (infinite) cylinder:  
         (x(t))² + (z(t))² = R_c².  
   c) Write a routine that  
      1. Solves both quadratics to find all real roots t ≥ 0.  
      2. Sorts these roots into entry/exit intervals along the ray for each primitive:  
         • Sphere interval(s): [t_s1, t_s2] (at most two roots)  
         • Cylinder interval(s): [t_c1, t_c2] (at most two roots)  
      3. Computes the CSG difference S \ C by subtracting the cylinder interval(s) from the sphere interval(s).  
      4. Determines the smallest t_hit ≥ 0 in the resulting set.  
      5. Computes the point P = O + t_hit D and its surface normal n:  
         – If the hit is on the sphere surface, n = (P − C)/R_s.  
         – If the hit is on the cylinder, n = (x,0,z)/R_c, oriented outward.  
      6. Handles the special case when the ray starts inside the shape (O is in {‖O‖ ≤ R_s and x_O²+z_O² ≥ R_c²}).

4) Programming Requirements
   • Language: C++, Java or Python  
   • Implement a function with signature, for example (C++‐style):  
       bool intersectSphereWithHole(  
         const Ray& ray,  
         float&   t_hit,  
         Vec3&    hitPoint,  
         Vec3&    hitNormal  
       );  
     Return true if there is an intersection (and fill out t_hit, hitPoint, hitNormal), false otherwise.  
   • Do not use any external CSG library—perform the subtraction yourself.  
   • Aim for numerical robustness: check the discriminants before taking square roots, and reject t < ε (e.g. ε = 1e‐4) to avoid self-hits.  

5) Testing
   • Provide at least three test rays:  
     1) Outside the sphere, aimed directly at where the cylinder passes through (should hit the cylindrical wall).  
     2) Outside the sphere, aimed at the sphere shell (should hit the sphere first).  
     3) Origin inside the hole region (x_O²+z_O² < R_c²), heading out (should hit the inner cylinder or the outer sphere).  
   • For each test ray, report t_hit and verify the hit point lies on one of the two surfaces (sphere or cylinder) and its normal is correct.

Deliverables
   1) Source code implementing intersectSphereWithHole()  
   2) Mathematical derivation of the two quadratics and your interval-subtraction logic  
   3) Test cases with ray parameters, results (t_hit, P, n), and short explanation

Good luck!

############### 11.5 ###############
Ray‐Object Intersection: Sphere with a Cylindrical Hole
================================================================

Problem Overview
----------------
You must implement ray‐intersection code for the solid obtained by “drilling” an infinite cylinder through a sphere.  Concretely:

  • Sphere S  
    – Center C = (0, 0, 0)  
    – Radius  Rₛ > 0  

  • Cylinder K  
    – Axis along the world‐z axis  
    – Radius Rₖ, 0 < Rₖ < Rₛ  
    – Infinite in both +z and −z  

  • Composite object O = S  minus  (interior of K).  
    In other words, O = { p ∈ ℝ³ | |p−C| ≤ Rₛ  AND  √(pₓ² + p_y²) ≥ Rₖ }.

Given a ray  
   R(t) = O₀ + t·D  
with origin O₀ ∈ ℝ³ and normalized direction D (‖D‖=1), find the first intersection t₀ > 0 of R with O, together with the surface normal N at the hit point.

What to deliver
---------------

1. Derivations  
   a.  The quadratic equation for intersections with the sphere S.  
   b.  The quadratic (or pair of linear) equations for intersections with the cylinder K.  
   c.  A clear description of how to compute the union of intervals on t where the ray is inside S, subtract away intervals where the ray is inside K, and pick the smallest positive leftover t.

2. Pseudocode or code (in C++/Java/Python) for a function:

     bool intersectSphereWithCylHole(
         Ray    ray,        // origin O₀, direction D
         float  R_s,        // sphere radius
         float  R_k,        // cylinder radius
         Hit&   outHit      // returns t and normal
     );

   The function returns true if there is a hit (t > 0), false otherwise.  On hit, outHit.t is the distance along the ray and outHit.N is the outward‐facing normal at R(t).

3. A short explanation of how you handle edge cases, in particular:
   • Ray tangent to S but missing K.  
   • Ray tangent to K but inside S.  
   • Ray origin inside the cylinder‐hole region.  

Detailed Steps
--------------

1. Sphere Intersection  
   - Solve for t: ‖O₀ + t D − C‖² = Rₛ².  
   - Expand: (D·D) t² + 2 D·(O₀−C) t + ‖O₀−C‖² − Rₛ² = 0.  
   - Since D is normalized, D·D = 1.  Call the solutions t₁ₛ ≤ t₂ₛ (if they exist real).

2. Cylinder Intersection  
   - Cylinder axis = z.  Intersection condition: pₓ² + p_y² = Rₖ².  
   - Ray xy‐components: (O₀ₓ + t Dₓ)² + (O₀_y + t D_y)² = Rₖ².  
   - Expand to quadratic in t, call solutions t₁ₖ ≤ t₂ₖ (if they exist real).  

3. Build “inside” intervals  
   - Interval Iₛ = [t₁ₛ, t₂ₛ] is where the ray is inside the sphere.  
   - Interval Iₖ = [t₁ₖ, t₂ₖ] is where the ray is inside the (infinite) cylinder.  
   - We want the portions of Iₛ that lie outside Iₖ.  In interval arithmetic:  
       Iₒ = Iₛ \ Iₖ  
     This may yield up to two disjoint sub‐intervals.  

4. Select Hit  
   - From Iₒ, pick the smallest t > 0.  Call it t₀.  If none, return false.  
   - Determine whether t₀ corresponds to the sphere boundary (t₀ = t₁ₛ or t₂ₛ lying outside Iₖ) or to the cylinder wall (t₀ = t₁ₖ or t₂ₖ lying inside Iₛ).  

5. Compute Normal  
   - If hit on sphere: N = normalize((O₀ + t₀D) − C).  
   - If hit on cylinder:  
        Let P = O₀ + t₀D = (pₓ,p_y,p_z).  
        N = normalize((pₓ,p_y,0)).  

6. Edge Cases  
   - No real roots for sphere: no hit.  
   - Roots for cylinder that lie completely outside Iₛ: treat as if no cylinder.  
   - Ray origin inside K (i.e. O₀ₓ²+O₀_y² < Rₖ²) but inside sphere: your interval arithmetic still works—one interval will start at t = 0.

Example Signature in C++
// -------------------------------------------
struct Ray  { Vec3 o, d; };    // o = origin, d = unit vector
struct Hit  { float t; Vec3 N; };

bool intersectSphereWithCylHole(
    const Ray&  ray,
    float        R_s,
    float        R_k,
    Hit&         outHit
) {
    // 1. Solve sphere quad: t1s,t2s
    // 2. Solve cylinder quad: t1k,t2k
    // 3. Form Iₛ and Iₖ
    // 4. Subtract intervals: Iₒ = Iₛ minus Iₖ
    // 5. Find smallest t>0 in Iₒ
    // 6. Determine which surface (sphere or cylinder)
    // 7. Compute normal, fill outHit, return true
    // 8. If no valid t, return false
}
// -------------------------------------------

Deliverables
------------
1. The completed derivation of all intersection equations.  
2. Well‐commented code or pseudocode implementing intersectSphereWithCylHole.  
3. A brief write‐up (1–2 paragraphs) describing how your interval subtraction handles edge cases.  

Grading
-------
• Correctness of derivations and interval logic: 50%  
• Completeness and clarity of code/pseudocode: 40%  
• Handling of edge cases: 10%

############### 11.6 ###############
Ray‐Object Intersection: “Sphere with Cylindrical Hole”  

Description of the Solid  
  We define a 3D solid C by taking a solid sphere S of radius Rₛ centered at the origin and drilling an infinite cylindrical hole H of radius Rₕ (Rₕ < Rₛ) along the z–axis.  In set‐theoretic form:  
    C = S ∖ H  
  where  
    S = { (x,y,z) ∈ ℝ³ ∣ x² + y² + z² ≤ Rₛ² }  
    H = { (x,y,z) ∈ ℝ³ ∣ x² + y² ≤ Rₕ² }  

Task  
  Write a routine  
    bool intersectSphereWithHole(  
      const Ray&   ray,      // ray.origin = O, ray.dir = D (normalized)  
      float&       tHit,     // distance along ray to first intersection (tHit > 0)  
      Vec3&        nHit      // outward‐pointing surface normal at hit point  
    );  

  that returns true if the ray intersects the boundary of C and false otherwise.  If true, your routine must set:  
    • tHit = the smallest t > 0 such that P = O + t D lies on the boundary of C  
    • nHit = outward‐pointing normal of C at P  

You must handle all cases correctly (ray starts outside, inside the sphere, inside the hole, grazing tangents, etc.).  

Specifications and Hints  

1. Ray‐Sphere Intersection  
   Derive the quadratic for S:  
     aₛ = D·D = 1  (assume D is normalized)  
     bₛ = 2(D·O)  
     cₛ = O·O − Rₛ²  
   Solve aₛ t² + bₛ t + cₛ = 0 to obtain tₛ₁ ≤ tₛ₂, the entrance & exit along S.  

2. Ray‐Cylinder Intersection  
   The infinite cylinder H (axis = z‐axis) satisfies x² + y² = Rₕ².  Derive:  
     aₕ = Dₓ² + D_y²  
     bₕ = 2(Oₓ Dₓ + O_y D_y)  
     cₕ = Oₓ² + O_y² − Rₕ²  
   Solve aₕ t² + bₕ t + cₕ = 0 to obtain tₕ₁ ≤ tₕ₂, the entrance & exit along H.  

3. CSG Difference (S ∖ H)  
   – The ray enters/exits S at tₛ₁, tₛ₂.  Between these two parameters the ray is “inside the sphere.”  
   – The ray enters/exits H at tₕ₁, tₕ₂.  Between those the ray lies inside the cylindrical hole (which is empty).  
   – The solid C is “inside S AND outside H.”  Therefore the set of t for which the ray lies in C is the interval [tₛ₁, tₛ₂] minus the open interval (tₕ₁, tₕ₂).  

   Your algorithm must find the smallest t > 0 at which the ray crosses into C if it starts outside, or crosses out of C if it starts inside, and return that as tHit.  

4. Surface Normal  
   At your intersection point P = O + tHit·D:  
   – If the crossing is with the sphere boundary, nHit = normalize(P).  
   – If the crossing is with the cylinder wall, the outward normal of the remaining solid points *toward* the z‐axis:  
       nHit = –normalize( (Pₓ, P_y, 0) ).  

5. Implementation Outline (pseudocode)  
  • Solve both quadratics for (tₛ₁,tₛ₂) and (tₕ₁,tₕ₂).  
  • Discard any t ≤ 0.  You may get 0, 1 or 2 valid roots for each.  
  • Collect all valid events { (t, type) } where type ∈ { enterSphere, exitSphere, enterHole, exitHole }.  
  • Sort by t ascending.  
  • Initialize two booleans: insideSphere = ( O·O < Rₛ²), insideHole = (Oₓ² + O_y² < Rₕ²).  
  • Sweep through events in order: at each event, flip insideSphere or insideHole accordingly; after each flip, check if (insideSphere && !insideHole) has become true (first entry into solid) or has become false (first exit from solid).  Record that event’s t and type.  
  • If you found an entry/exit tHit > 0, compute P and nHit as above and return true; else return false.  

Deliverables  
  1. A clear derivation of the two quadratics.  
  2. A description of your interval arithmetic or event‐sweeping logic for C = S ∖ H.  
  3. Well‐commented C++ (or language X) code or detailed pseudocode for intersectSphereWithHole(...).  
  4. A brief note on handling degenerate cases (e.g. ray parallel to cylinder axis, ray origin exactly on a surface).

############### 11.7 ###############
Ray–Object Intersection: Sphere with a Cylindrical Hole

Problem statement  
You are to implement a ray‐intersection routine for a solid defined by a unit sphere from which a cylindrical “tunnel” has been drilled along the z–axis.  Formally, the object S is  
 S = { p = (x,y,z) ∈ ℝ³ | ‖p‖ ≤ R  and  √(x²+y²) ≥ r }  
where R is the sphere radius and r < R is the radius of the (infinite) circular cylinder cut out along the z–axis.

Your task is to write a function

    bool intersectSphereWithHole(
        const Ray& ray,      // ray.origin O, ray.dir D (normalized)
        float  R,            // sphere radius
        float  r,            // cylinder radius (r < R)
        float  tMin,         // minimum valid t (e.g. 1e–4)
        Intersection& isect  // out: t, hitPoint, normal
    );

that returns true if the ray hits the solid (at t ≥ tMin), and false otherwise.  On a hit, you must fill in:  
– t, the smallest positive intersection distance ≥ tMin  
– hitPoint = O + t·D  
– normal = surface normal at hitPoint (pointing outward from the solid)

You may assume D is normalized and that the cylinder extends infinitely in ±z.  In practice the “hole” only matters where it lies within the sphere.

Part A: Sphere and Cylinder Intersections  
1. Sphere:  
   Derive the quadratic in t for sphere intersection with center at the origin and radius R.  
   Write expressions for the discriminant Δₛ, the two roots tₛ₁ ≤ tₛ₂, and state when the ray misses the sphere.

2. Cylinder:  
   Derive the quadratic in t for an infinite cylinder of radius r whose axis is the z–axis.  (Ignore z in the cylinder equation.)  
   Write expressions for discriminant Δ𝚌, the two roots t𝚌₁ ≤ t𝚌₂, and state when the ray misses the cylinder.

Part B: Combining Intervals  
A ray enters the solid when it is inside the sphere but outside the cylinder.  Equivalently:  
– Inside‐sphere interval: [tₛ₁, tₛ₂] (if Δₛ ≥ 0)  
– Inside‐cylinder interval: [t𝚌₁, t𝚌₂] (if Δ𝚌 ≥ 0)

Show how to compute the set difference  
 I = [tₛ₁, tₛ₂]  \  [t𝚌₁, t𝚌₂]  
as up to two disjoint subintervals on the t‐axis.  Then describe how to pick the smallest t in I that is ≥ tMin.  Don’t forget these edge cases:  
– Ray misses sphere (no hit)  
– Ray misses cylinder entirely (hit is same as sphere hit)  
– Ray starts inside cylinder (so you only enter the solid when exiting the cylinder, then later exit the sphere)  
– Ray starts inside sphere but outside cylinder  

Part C: Implementation  
Using your results from A and B, provide C++‐style pseudocode (or actual code) for intersectSphereWithHole(…).  Your code should:  
1. Compute ts₁, ts₂ for the sphere; return false if no real, positive intersection.  
2. Compute tc₁, tc₂ for the cylinder (if any).  
3. Build the final hit interval(s) by subtracting the cylinder interval from the sphere interval.  
4. Scan these intervals in increasing t order to find the first t ≥ tMin and return the corresponding normal:  
   – On a sphere‐surface hit: normal = (P)/R  
   – On a cylinder‐surface hit (i.e. the inner tunnel wall): normal = normalize(vec2(P.x, P.y), 0.0)

Part D: Test Cases  
For the special case R = 1.0, r = 0.5, tMin = 1e–4, test your function on these two rays:

1. Ray 1:  
   O = (0.75, 0,  2), D = (0,0,−1)  
   Expected: hits the outer sphere shell (never touches the cylinder wall).  

2. Ray 2:  
   O = (0.25, 0, 2), D = (0,0,−1)  
   Expected: the ray travels down the drilled tunnel and never hits the solid—return false.

Be sure your implementation correctly handles all edge cases.

############### 11.8 ###############
Ray‐Object Intersection: “Sphere with Cylindrical Through‐Hole”  
==================================================================  

Problem statement  
-----------------  
You are to implement ray­-object intersection for a solid sphere of radius R centered at C = (Cx,Cy,Cz), from which an infinite circular cylinder of radius r < R, whose axis coincides with the sphere center and points along the world Z­-axis, has been drilled straight through.  The resulting object’s surface consists of:  
1. The outer spherical shell (except where the cylinder passed through).  
2. The inner cylindrical wall (only the portion that lies inside the original sphere).  

Given a ray (origin O, unit­-direction D), compute the nearest point of intersection with this composite surface, if any, and return  
— tHit: the smallest positive distance along the ray to the hit point P = O + tHit·D  
— N: the unit outward normal at P  
— hit: a boolean indicating whether an intersection was found (hit == true if tHit exists)  

Assume the ray origin lies strictly outside the original sphere.  

Mathematical details  
--------------------  
1. Ray‐sphere intersection  
   Solve ‖(O + t D) − C‖² = R².  
   Let L = O − C.  
   a = D·D = 1 (since D is normalized)  
   b = 2 (D·L)  
   c = L·L − R²  
   Δ = b² − 4ac  
   If Δ < 0, no real roots → no sphere intersection.  
   Else compute  
     t_s1 = (−b − √Δ)/(2a),  t_s2 = (−b + √Δ)/(2a).  
   For each t_s > 0, let P_s = O + t_s D; accept it as a *candidate* sphere‐hit only if its projection onto the XY-plane lies *outside* the drilled cylinder, i.e.  
     (P_sx − Cx)² + (P_sy − Cy)² ≥ r².  

2. Ray‐cylinder intersection  
   The infinite cylinder (axis = Z) satisfies (X − Cx)² + (Y − Cy)² = r².  
   Solve for t:  
     a_c = D_x² + D_y²  
     b_c = 2[(O_x − Cx)D_x + (O_y − Cy)D_y]  
     c_c = (O_x − Cx)² + (O_y − Cy)² − r²  
     Δ_c = b_c² − 4 a_c c_c  
   If Δ_c < 0, no real roots → no cylinder intersection.  
   Else compute  
     t_c1 = (−b_c − √Δ_c)/(2a_c),  t_c2 = (−b_c + √Δ_c)/(2a_c).  
   For each t_c > 0, let P_c = O + t_c D; accept it as a *candidate* cylinder‐hit only if P_c also lies inside the original sphere, i.e.  
     (P_c − C)·(P_c − C) ≤ R².  

3. Choosing the intersection  
   Collect all *valid* t_s and t_c candidates.  
   If none remain, hit = false.  
   Otherwise pick the smallest positive tHit among them, compute P = O + tHit·D, and set hit = true.  

4. Computing the outward normal N at P  
   If tHit came from a sphere‐candidate:  
     N = normalize(P − C)  
   Else (it came from the cylinder):  
     // The outward normal on the *inner* cylinder wall points *into* the removed volume, i.e. it is −(radial)  
     Vec3 radial = (P_x − Cx,  P_y − Cy,  0)  
     N = − normalize(radial)  

Programming task  
----------------  
Implement the following C++ function:  

```cpp
struct Vec3 {
    double x, y, z;
    // ... (vector addition, subtraction, dot, length, normalize, etc.)
};

struct Ray {
    Vec3 o;     // origin
    Vec3 d;     // normalized direction
};

// Returns true if ray hits the sphere-with-hole; tHit is the smallest positive t,
// P is the hit point, N is the outward normal at P.
bool intersectSphereWithCylinderHole(
    const Ray& ray,
    const Vec3& C,   // sphere center
    double R,        // sphere radius
    double r,        // cylinder radius (r < R)
    double& tHit,
    Vec3& P,
    Vec3& N
) {
    // Your implementation goes here
}
```

Requirements  
-----------  
1. Compute all roots for sphere and cylinder intersections as described.  
2. Filter out negative-t solutions.  
3. Enforce the “hole” condition:  
   – Sphere‐hits must lie *outside* the cylinder’s radius in XY.  
   – Cylinder‐hits must lie *inside* the sphere.  
4. Pick the nearest valid t > 0, fill in tHit, P and outward N, return true.  
5. If no valid intersection, return false.  

Deliverables  
------------  
1. The completed function `intersectSphereWithCylinderHole`.  
2. A brief explanation (in comments or separate text) of how you handle each case and ensure the normals point outward from the solid.

############### 11.9 ###############
Ray‐Object Intersection: “Bored” Sphere (Sphere minus Cylindrical Hole)  

In this exercise you will write (or outline in pseudocode) a routine that computes the first intersection of a ray with a “bored” sphere—that is, a solid sphere with an infinite cylindrical hole drilled straight through its center.  Your routine must also compute the correct surface normal at the hit point (sphere‐surface normal or cylinder‐surface normal), depending on which surface the ray actually struck.

Object definition  
1. Sphere  
   • Center C = (0, 0, 0)  
   • Radius R > 0  
2. Cylinder (the “hole”)  
   • Infinite along the Z axis, axis direction V = (0, 0, 1), passing through the origin  
   • Radius r with 0 < r < R  

The final solid is the CSG subtraction:  
   Solid = Sphere \ Cylinder  

Ray definition  
• Origin O = (Ox, Oy, Oz)  
• Direction D = (Dx, Dy, Dz), assumed normalized  

Goal  
Write a function  
    bool intersectBoredSphere(Ray O,D;   // inputs  
                              float& tHit;        // output: distance along D to first hit (t > 0)  
                              Vec3& normal)      // output: surface normal at hit point  
that returns true if the ray hits the bored sphere and fills tHit and normal, otherwise false.

Part A: Derive intersection intervals  
1. Sphere‐intersection quadratic  
   Let L = O – C = O.  
   A_s = D·D = 1 (if D is normalized)  
   B_s = 2 (D·L)  
   C_s = L·L – R²  
   Δ_s = B_s² – 4 A_s C_s  
   If Δ_s ≤ 0: no sphere hit → no intersection.  
   Otherwise compute two roots  
     t_s₁ = (–B_s – √Δ_s)/(2 A_s)  
     t_s₂ = (–B_s + √Δ_s)/(2 A_s)  
   with t_s₁ ≤ t_s₂.  The ray is inside the sphere between [t_s₁, t_s₂].

2. Cylinder‐intersection quadratic  
   Because the cylinder’s axis is the Z axis, ignore the z‐components:  
     P(t) = O + t D → (x(t), y(t), z(t)).  
   Solve  (x(t))² + (y(t))² = r².  
   A_c = Dₓ² + D_y²  
   B_c = 2 (Oₓ Dₓ + O_y D_y)  
   C_c = Oₓ² + O_y² – r²  
   Δ_c = B_c² – 4 A_c C_c  
   If A_c = 0 (ray parallel to cylinder axis) then either no cylinder hit (if Oₓ²+O_y² > r²) or the ray is always inside the infinite cylinder (if Oₓ²+O_y² < r²).  
   Otherwise, if Δ_c > 0, the two cylinder roots are  
     t_c₁ = (–B_c – √Δ_c)/(2 A_c)  
     t_c₂ = (–B_c + √Δ_c)/(2 A_c)  
   with t_c₁ ≤ t_c₂.  Between [t_c₁, t_c₂] the ray is inside the cylinder.

Part B: CSG subtraction → final intersection intervals  
We know the ray enters/exits the sphere on [t_s₁, t_s₂].  We must “cut out” the part inside the cylinder [t_c₁, t_c₂].  In other words, the ray is inside the solid only where  
    t ∈ [t_s₁, t_s₂]  AND  (t < t_c₁  OR  t > t_c₂).  

Compute the non‐overlapping sub‐intervals of [t_s₁, t_s₂] after removing [t_c₁, t_c₂].  There are up to two disjoint intervals:
  I₁ = [t_s₁, min(t_s₂, t_c₁)]  
  I₂ = [max(t_s₁, t_c₂), t_s₂]

You then pick the smallest t > 0 from among I₁ and I₂’s lower endpoints, provided that it lies within its interval.

Part C: Normal computation  
Let P = O + tHit D be the hit point.  
1. If P lies on the spherical shell (i.e. tHit is from t_s₁ or t_s₂ and outside the cylinder interval), then  
     normal = normalize(P – C).  
2. If P lies on the cylindrical surface (i.e. tHit = t_c₁ or t_c₂ and within [t_s₁, t_s₂]), then compute the foot of P on the z‐axis:  
     F = (Pₓ, P_y, 0).  
   Then  
     normal = normalize(P – F).

Part D: Pseudocode outline  

function intersectBoredSphere(Ray O, Vec3 D, float R, float r, out float tHit, out Vec3 normal) {  
  // 1. Sphere intersection  
  L = O  
  B_s = 2*dot(D, L)  
  C_s = dot(L,L) - R*R  
  Δ_s = B_s*B_s - 4*C_s  
  if Δ_s <= 0 return false  
  sqrtΔ_s = sqrt(Δ_s)  
  t_s1 = (-B_s - sqrtΔ_s)/2  
  t_s2 = (-B_s + sqrtΔ_s)/2  
  if t_s2 < 0 return false   // both behind ray  
  
  // 2. Cylinder intersection  
  A_c = D.x*D.x + D.y*D.y  
  B_c = 2*(O.x*D.x + O.y*D.y)  
  C_c = O.x*O.x + O.y*O.y - r*r  
  if A_c == 0 {  
    // Ray parallel to cylinder axis  
    if C_c >= 0 {  // outside cylinder  
      t_c1 = +∞; t_c2 = -∞  
    } else {      // inside cylinder for all t  
      t_c1 = -∞; t_c2 = +∞  
    }  
  } else {  
    Δ_c = B_c*B_c - 4*A_c*C_c  
    if Δ_c <= 0 { t_c1 = +∞; t_c2 = -∞ }  // no real roots  
    else {  
      sqrtΔ_c = sqrt(Δ_c)  
      t_c1 = (-B_c - sqrtΔ_c)/(2*A_c)  
      t_c2 = (-B_c + sqrtΔ_c)/(2*A_c)  
    }  
  }  
  
  // 3. Subtract cylinder interval from sphere interval  
  intervals = []  
  // First piece before cylinder  
  tA = t_s1  
  tB = min(t_s2, t_c1)  
  if tA < tB and tB > 0 then intervals.append([tA, tB])  
  // Second piece after cylinder  
  tC = max(t_s1, t_c2)  
  tD = t_s2  
  if tC < tD and tD > 0 then intervals.append([tC, tD])  
  
  if intervals.empty() return false  
  
  // 4. Pick nearest positive t from intervals  
  tHit = inf  
  for each [ta, tb] in intervals {  
    if ta > 0 and ta < tHit then tHit = ta  
  }  
  if tHit == inf return false  
  
  // 5. Compute normal at P = O + tHit*D  
  P = O + tHit*D  
  // Check if this tHit lies on the cylinder boundary  
  onCylinder = (abs((P.x*P.x + P.y*P.y) - r*r) < ε)  
             and (tHit >= t_c1 - ε) and (tHit <= t_c2 + ε)  
  if onCylinder {  
    // Cylinder normal  
    F = Vec3(P.x, P.y, 0)  
    normal = normalize(P - F)  
  } else {  
    // Sphere normal  
    normal = normalize(P - C)  
  }  
  return true  
}  

Notes and tips  
• Carefully handle the “ray parallel to cylinder axis” case (A_c=0).  
• Use a small ε (e.g. 1e-6) when testing onCylinder to avoid floating‐point ambiguity.  
• Make sure you discard any t ≤ 0 before choosing tHit.  
• Test your code on rays that:  
  – Miss both shapes entirely  
  – Hit only the sphere (away from the hole)  
  – Hit only the cylinder wall (inside the sphere)  
  – Pass through both sphere and cylinder  
  – Travel parallel to the cylinder axis  

Deliverables  
1. Your intersectBoredSphere routine in C++, Java or pseudocode.  
2. A short explanation of how you subtract the cylinder interval from the sphere interval.  
3. A few test cases (ray origin, direction → expected tHit and normal).
